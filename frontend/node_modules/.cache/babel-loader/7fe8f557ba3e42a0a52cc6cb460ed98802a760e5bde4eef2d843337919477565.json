{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { rescale } from \"../../helpers/math.js\";\nexport const toPercent = (v, min, max) => (v - min) / (max - min) * 100;\nexport const offsetToValue = (startX, width, min, max, step) => {\n  return rescale(startX, [0, width], [min, max], {\n    step\n  });\n};\nconst restrictValueByMinMax = (value, min, max) => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\nexport const updateInternalStateValue = (prevValue, nextValue, min, max, dragging) => {\n  const [prevStartValue, prevEndValue] = prevValue;\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n  switch (dragging) {\n    case 'start':\n      return nextValue > prevEndValue ? [prevEndValue, prevEndValue] : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n    case 'end':\n      return nextValue < prevStartValue ? [prevStartValue, prevStartValue] : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n    case null:\n    default:\n      return prevValue;\n  }\n};\nexport const updateInternalStateValueByNativeChange = (prevValue, nextValue, dragging) => {\n  const [prevStartValue, prevEndValue] = prevValue;\n  switch (dragging) {\n    case 'start':\n      return [nextValue, prevEndValue];\n    case 'end':\n      return [prevStartValue, nextValue];\n    case null:\n    default:\n      return prevValue;\n  }\n};\nexport function isMultipleValues(value) {\n  return value[1] !== null;\n}\nexport const snapDirection = (prevValue, nextValue, type) => {\n  if (type === 'start') {\n    return 'start';\n  }\n  if (type === 'end') {\n    return 'end';\n  }\n  const [startRaw, endRaw] = prevValue;\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n  const FORCE_DIFF_VALUE = 0.1;\n  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? 'start' : 'end';\n};\nexport const getDraggingTypeByTargetDataset = target => {\n  if (target) {\n    if (target.dataset.type === 'start') {\n      return 'start';\n    }\n    if (target.dataset.type === 'end') {\n      return 'end';\n    }\n  }\n  return null;\n};\nconst resetProps = {\n  'aria-label': undefined,\n  'aria-valuetext': undefined,\n  'aria-labelledby': undefined\n};\nexport const extractSliderAriaAttributesFromRestProps = restProps => {\n  const ariaLabel = restProps['aria-label'];\n  const ariaValueText = restProps['aria-valuetext'];\n  const ariaLabelledBy = restProps['aria-labelledby'];\n  return _object_spread_props(_object_spread({}, restProps, resetProps), {\n    ariaLabel,\n    ariaValueText,\n    ariaLabelledBy\n  });\n};","map":{"version":3,"names":["rescale","toPercent","v","min","max","offsetToValue","startX","width","step","restrictValueByMinMax","value","updateInternalStateValue","prevValue","nextValue","dragging","prevStartValue","prevEndValue","updateInternalStateValueByNativeChange","isMultipleValues","snapDirection","type","startRaw","endRaw","FORCE_DIFF_VALUE","start","end","Math","abs","getDraggingTypeByTargetDataset","target","dataset","resetProps","undefined","extractSliderAriaAttributesFromRestProps","restProps","ariaLabel","ariaValueText","ariaLabelledBy","_object_spread_props","_object_spread"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/Slider/helpers.ts"],"sourcesContent":["import type * as React from 'react';\nimport { rescale } from '../../helpers/math';\nimport type { InternalDraggingType, InternalValueState } from './types';\n\nexport const toPercent = (v: number, min: number, max: number): number =>\n  ((v - min) / (max - min)) * 100;\n\nexport const offsetToValue = (\n  startX: number,\n  width: number,\n  min: number,\n  max: number,\n  step?: number,\n): number => {\n  return rescale(startX, [0, width], [min, max], { step });\n};\n\nconst restrictValueByMinMax = (value: number, min: number, max: number) => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\n\nexport const updateInternalStateValue = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  min: number,\n  max: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n\n  switch (dragging) {\n    case 'start':\n      return nextValue > prevEndValue\n        ? [prevEndValue, prevEndValue]\n        : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n    case 'end':\n      return nextValue < prevStartValue\n        ? [prevStartValue, prevStartValue]\n        : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport const updateInternalStateValueByNativeChange = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n  switch (dragging) {\n    case 'start':\n      return [nextValue, prevEndValue];\n    case 'end':\n      return [prevStartValue, nextValue];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport function isMultipleValues(value: InternalValueState): value is [number, number] {\n  return value[1] !== null;\n}\n\nexport const snapDirection = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  type: InternalDraggingType | null,\n): 'start' | 'end' => {\n  if (type === 'start') {\n    return 'start';\n  }\n  if (type === 'end') {\n    return 'end';\n  }\n\n  const [startRaw, endRaw] = prevValue;\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n  const FORCE_DIFF_VALUE = 0.1;\n  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? 'start' : 'end';\n};\n\nexport const getDraggingTypeByTargetDataset = <T extends (EventTarget & HTMLElement) | null>(\n  target: T,\n): 'start' | 'end' | null => {\n  if (target) {\n    if (target.dataset.type === 'start') {\n      return 'start';\n    }\n    if (target.dataset.type === 'end') {\n      return 'end';\n    }\n  }\n  return null;\n};\n\nconst resetProps = {\n  'aria-label': undefined,\n  'aria-valuetext': undefined,\n  'aria-labelledby': undefined,\n};\n\nexport const extractSliderAriaAttributesFromRestProps = <T extends React.AriaAttributes>(\n  restProps: T,\n): T & {\n  ariaLabel: string | undefined;\n  ariaValueText: string | undefined;\n  ariaLabelledBy: string | undefined;\n} => {\n  const ariaLabel = restProps['aria-label'];\n  const ariaValueText = restProps['aria-valuetext'];\n  const ariaLabelledBy = restProps['aria-labelledby'];\n  return { ...restProps, ...resetProps, ariaLabel, ariaValueText, ariaLabelledBy };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}