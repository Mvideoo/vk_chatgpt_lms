{"ast":null,"code":"import * as React from \"react\";\nimport { debounce, noop } from \"@vkontakte/vkjs\";\nimport { getWindow, isHTMLElement } from \"@vkontakte/vkui-floating-ui/utils/dom\";\nimport { useCustomEnsuredControl } from \"../../../hooks/useEnsuredControl.js\";\nimport { useGlobalOnClickOutside } from \"../../../hooks/useGlobalOnClickOutside.js\";\nimport { useStableCallback } from \"../../../hooks/useStableCallback.js\";\nimport { contains, getActiveElementByAnotherElement } from \"../../dom.js\";\nimport { useIsomorphicLayoutEffect } from \"../../useIsomorphicLayoutEffect.js\";\nimport { autoUpdateFloatingElement, useFloating } from \"../adapters.js\";\nimport { convertFloatingDataToReactCSSProperties } from \"../functions.js\";\nimport { DEFAULT_TRIGGER } from \"./constants.js\";\nimport { useResolveTriggerType } from \"./useResolveTriggerType.js\";\nconst whileElementsMounted = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return /* istanbul ignore next: не знаю как проверить */autoUpdateFloatingElement(...args, {\n    elementResize: true\n  });\n};\n/**\n * @private\n */\nexport const useFloatingWithInteractions = _ref => {\n  let {\n    trigger = DEFAULT_TRIGGER,\n    // UseFloating\n    placement: placementProp = 'bottom',\n    strategy: strategyProp = 'fixed',\n    middlewares,\n    hoverDelay = 0,\n    closeAfterClick = false,\n    // disables\n    disabled = false,\n    disableInteractive = false,\n    disableCloseOnClickOutside = false,\n    disableCloseOnEscKey = false,\n    // uncontrolled\n    defaultShown = false,\n    // controlled\n    shown: shownProp,\n    onShownChange: onShownChangeProp,\n    onShownChanged: onShownChangedProp\n  } = _ref;\n  const memoizedValue = React.useMemo(() => shownProp !== undefined ? {\n    shown: shownProp\n  } : undefined, [shownProp]);\n  const [shownLocalState, setShownLocalState] = useCustomEnsuredControl({\n    value: memoizedValue,\n    disabled,\n    defaultValue: {\n      shown: defaultShown\n    },\n    onChange: useStableCallback(_ref2 => {\n      let {\n        shown,\n        reason\n      } = _ref2;\n      if (onShownChangeProp) {\n        onShownChangeProp(shown, reason);\n      }\n    })\n  });\n  const onShownChanged = useStableCallback(onShownChangedProp ? onShownChangedProp : noop);\n  const [shownFinalState, setShownFinalState] = React.useState(() => shownLocalState.shown);\n  const [willBeHide, setWillBeHide] = React.useState(false);\n  const hasCSSAnimation = React.useRef(false);\n  const blockMouseEnterRef = React.useRef(false);\n  const blockFocusRef = React.useRef(false);\n  const blurTimeoutRef = React.useRef(undefined);\n  const handleCloseOnReferenceClickOutsideDisabled = disabled || disableCloseOnClickOutside || willBeHide || !shownLocalState.shown;\n  const handleCloseOnFloatingClickOutsideDisabled = disableInteractive || handleCloseOnReferenceClickOutsideDisabled;\n  const {\n    triggerOnFocus,\n    triggerOnClick,\n    triggerOnHover\n  } = useResolveTriggerType(trigger);\n  // Библиотека `floating-ui`\n  const {\n    placement,\n    x,\n    y,\n    strategy,\n    refs,\n    middlewareData\n  } = useFloating({\n    strategy: strategyProp,\n    placement: placementProp,\n    middleware: middlewares,\n    whileElementsMounted\n  });\n  const commitShownLocalState = React.useCallback((nextShown, reason) => {\n    setShownLocalState(prevState => {\n      if (prevState.shown !== nextShown || prevState.reason !== reason) {\n        return {\n          shown: nextShown,\n          reason\n        };\n      }\n      /* istanbul ignore next: страховка, если вдруг на момент вызова обновления состояния, оно уже будет актуальным */\n      return prevState;\n    });\n  }, [setShownLocalState]);\n  const [mouseEnterDelay, mouseLeaveDelay] = typeof hoverDelay === 'number' ? [hoverDelay, hoverDelay] : hoverDelay;\n  const showWithDelay = React.useMemo(() => debounce(() => commitShownLocalState(true, 'hover'), mouseEnterDelay), [mouseEnterDelay, commitShownLocalState]);\n  const hideWithDelay = React.useMemo(() => debounce(() => commitShownLocalState(false, 'hover'), mouseLeaveDelay), [mouseLeaveDelay, commitShownLocalState]);\n  const handleFocusOnReference = useStableCallback(() => {\n    // Повторный вызов события фокуса - следствие клика на reference-элемент\n    if (shownLocalState.shown) {\n      if (!closeAfterClick && shownLocalState.reason === 'hover') {\n        return;\n      }\n      commitShownLocalState(false, 'focus');\n      return;\n    }\n    if (blockFocusRef.current) {\n      /* istanbul ignore next: в Jest не воспроизводится баг на вебе (cм. onRestoreFocus) */blockFocusRef.current = false;\n      return;\n    }\n    commitShownLocalState(true, 'focus');\n  });\n  const handleBlurOnReference = useStableCallback(event => {\n    blockFocusRef.current = false;\n    blockMouseEnterRef.current = false;\n    if (!shownLocalState.shown) {\n      clearTimeout(blurTimeoutRef.current);\n      return;\n    }\n    const relatedTarget = event.relatedTarget;\n    blurTimeoutRef.current = setTimeout(function waitWindowBlurFire() {\n      const reference = refs.reference.current;\n      // Если пользователь покинул текущее окно в открытом состоянии, то\n      // не закрываем всплывающий элемент.\n      /* istanbul ignore if: не умеем симулировать уход из текущего окна */\n      if (!relatedTarget && getActiveElementByAnotherElement(reference) === reference) {\n        /* istanbul ignore next */return;\n      }\n      // Если пользователь нажал на всплывающий элемент, то не закрываем всплывающий элемент.\n      // Note: для этого элемент должен быть фокусируемый (например, за счёт `tabindex=\"-1\"`).\n      if (contains(refs.floating.current, relatedTarget) || contains(reference, relatedTarget)) {\n        return;\n      }\n      commitShownLocalState(false, 'focus');\n    });\n  });\n  const handleClickOnReference = useStableCallback(() => {\n    // Предыдущий триггер (фокус) уже вызвал открытие/закрытие всплывающего окна, игнорируем вызов\n    if (shownLocalState.reason === 'focus') {\n      commitShownLocalState(shownLocalState.shown, 'click');\n      return;\n    }\n    commitShownLocalState(!shownLocalState.shown, 'click');\n  });\n  const handleClickOnReferenceForOnlyClose = useStableCallback(() => {\n    blockMouseEnterRef.current = true;\n    commitShownLocalState(false, 'click');\n  });\n  const handleMouseEnterOnBoth = useStableCallback(event => {\n    if (willBeHide && event.currentTarget === refs.floating.current) {\n      return;\n    }\n    showWithDelay.cancel();\n    hideWithDelay.cancel();\n    if (!blockMouseEnterRef.current && !shownLocalState.shown) {\n      showWithDelay();\n    }\n  });\n  const handleMouseLeaveOnBothForHoverAndFocusStates = useStableCallback(event => {\n    if (willBeHide && event.currentTarget === refs.floating.current) {\n      return;\n    }\n    blockFocusRef.current = false;\n    blockMouseEnterRef.current = false;\n    if (triggerOnHover) {\n      showWithDelay.cancel();\n      hideWithDelay.cancel();\n      hideWithDelay();\n    }\n  });\n  const handleFloatingAnimationStart = () => {\n    hasCSSAnimation.current = true;\n  };\n  const handleFloatingAnimationEnd = () => {\n    if (willBeHide) {\n      setShownFinalState(false);\n      setWillBeHide(false);\n      onShownChanged(false, shownLocalState.reason);\n    }\n  };\n  const handleOnClose = React.useCallback(() => {\n    blockFocusRef.current = true;\n    commitShownLocalState(false, 'callback');\n  }, [commitShownLocalState]);\n  const handleRestoreFocus = React.useCallback(function () {\n    let restoreFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!restoreFocus) {\n      return false;\n    }\n    if (restoreFocus === true) {\n      return triggerOnFocus ? blockFocusRef.current : true;\n    } else if (restoreFocus === 'anchor-element') {\n      return refs.reference.current;\n    } else if (restoreFocus instanceof HTMLElement) {\n      return restoreFocus;\n    }\n    return false;\n  }, [refs.reference, triggerOnFocus]);\n  const handleEscapeKeyDown = React.useCallback(() => {\n    blockFocusRef.current = true;\n    commitShownLocalState(false, 'escape-key');\n  }, [commitShownLocalState]);\n  const handleClickOutside = React.useCallback(() => {\n    blockFocusRef.current = true;\n    commitShownLocalState(false, 'click-outside');\n  }, [commitShownLocalState]);\n  useGlobalOnClickOutside(handleClickOutside, handleCloseOnReferenceClickOutsideDisabled ? null : refs.reference, handleCloseOnFloatingClickOutsideDisabled ? null : refs.floating);\n  useIsomorphicLayoutEffect(\n  /**\n  * Если пользователь покинул активное окно и:\n  * 1. целевой элемент был в состоянии фокуса;\n  * 2. всплывающий элемент был закрытом состоянии;\n  * то фокус должен быть заблокирован, когда пользователь вернётся обратно. Иначе покажется\n  * всплывающий элемент.\n  */\n  function setGlobalBlurForTriggerOnFocus() {\n    if (!triggerOnFocus || !refs.reference.current) {\n      return;\n    }\n    const handleGlobalBlur = () => {\n      /* istanbul ignore next */const reference = refs.reference.current;\n      /* istanbul ignore if: не умеем симулировать уход из текущего окна */\n      if (!shownLocalState.shown && isHTMLElement(reference) && reference === getActiveElementByAnotherElement(reference)) {\n        /* istanbul ignore next */blockFocusRef.current = true;\n      }\n    };\n    const win = getWindow(refs.reference.current);\n    win.addEventListener('blur', handleGlobalBlur);\n    return () => {\n      win.removeEventListener('blur', handleGlobalBlur);\n    };\n  }, [triggerOnFocus, refs.reference, shownLocalState]);\n  useIsomorphicLayoutEffect(function resolveShownStates() {\n    if (willBeHide || shownLocalState.shown === shownFinalState) {\n      return;\n    }\n    if (shownLocalState.shown) {\n      setShownFinalState(true);\n      onShownChanged(true, shownLocalState.reason);\n    } else if (hasCSSAnimation.current && !willBeHide) {\n      setWillBeHide(true);\n    } else {\n      setShownFinalState(false);\n    }\n    return () => {\n      clearTimeout(blurTimeoutRef.current);\n    };\n  }, [shownLocalState, shownFinalState, willBeHide, onShownChanged]);\n  const referencePropsRef = React.useRef({});\n  const floatingPropsRef = React.useRef({\n    style: {}\n  });\n  useIsomorphicLayoutEffect(() => {\n    referencePropsRef.current = {};\n  }, [triggerOnHover, triggerOnFocus, triggerOnClick]);\n  if (shownFinalState) {\n    floatingPropsRef.current.style = convertFloatingDataToReactCSSProperties({\n      strategy,\n      x,\n      y,\n      middlewareData\n    });\n    if (disableInteractive) {\n      floatingPropsRef.current.style.pointerEvents = 'none';\n    }\n  }\n  if (triggerOnFocus) {\n    referencePropsRef.current.onFocus = handleFocusOnReference;\n    referencePropsRef.current.onBlur = handleBlurOnReference;\n  }\n  if (triggerOnClick) {\n    referencePropsRef.current.onClick = handleClickOnReference;\n  }\n  if (triggerOnHover) {\n    referencePropsRef.current.onMouseOver = handleMouseEnterOnBoth;\n    if (closeAfterClick && !triggerOnClick) {\n      referencePropsRef.current.onClick = handleClickOnReferenceForOnlyClose;\n    }\n    if (!disableInteractive) {\n      floatingPropsRef.current.onMouseOver = handleMouseEnterOnBoth;\n    }\n  }\n  if (triggerOnHover || triggerOnFocus) {\n    referencePropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;\n    if (!disableInteractive) {\n      floatingPropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;\n    }\n  }\n  if (shownFinalState) {\n    floatingPropsRef.current.onAnimationStart = handleFloatingAnimationStart;\n    floatingPropsRef.current.onAnimationEnd = handleFloatingAnimationEnd;\n  }\n  return {\n    placement,\n    shown: shownFinalState,\n    willBeHide,\n    refs,\n    referenceProps: referencePropsRef.current,\n    floatingProps: floatingPropsRef.current,\n    middlewareData,\n    onClose: handleOnClose,\n    // FocusTrap уже определяет нажатие на ESC, поэтому название события содержит конкретный код\n    // кнопки вместо просто onKeyDown.\n    onEscapeKeyDown: !shownFinalState || disableCloseOnEscKey ? undefined : handleEscapeKeyDown,\n    // [Обход баги с FocusTrap]\n    //\n    // Если сфокусироваться на целевой элемент через нажатие, а потом нажать в область за пределами\n    // целевого и всплывающего элемента, то появляется моргание из-за того, что FocusTrap\n    // восстанавливает фокус, из-за чего всплывающий элемент снова показывается за счёт\n    // `handleFocusOnReference`, а потом скрывается за счёт `handleBlurOnReference`.\n    onRestoreFocus: handleRestoreFocus\n  };\n};","map":{"version":3,"names":["React","debounce","noop","getWindow","isHTMLElement","useCustomEnsuredControl","useGlobalOnClickOutside","useStableCallback","contains","getActiveElementByAnotherElement","useIsomorphicLayoutEffect","autoUpdateFloatingElement","useFloating","convertFloatingDataToReactCSSProperties","DEFAULT_TRIGGER","useResolveTriggerType","whileElementsMounted","_len","arguments","length","args","Array","_key","elementResize","useFloatingWithInteractions","_ref","trigger","placement","placementProp","strategy","strategyProp","middlewares","hoverDelay","closeAfterClick","disabled","disableInteractive","disableCloseOnClickOutside","disableCloseOnEscKey","defaultShown","shown","shownProp","onShownChange","onShownChangeProp","onShownChanged","onShownChangedProp","memoizedValue","useMemo","undefined","shownLocalState","setShownLocalState","value","defaultValue","onChange","_ref2","reason","shownFinalState","setShownFinalState","useState","willBeHide","setWillBeHide","hasCSSAnimation","useRef","blockMouseEnterRef","blockFocusRef","blurTimeoutRef","handleCloseOnReferenceClickOutsideDisabled","handleCloseOnFloatingClickOutsideDisabled","triggerOnFocus","triggerOnClick","triggerOnHover","x","y","refs","middlewareData","middleware","commitShownLocalState","useCallback","nextShown","prevState","mouseEnterDelay","mouseLeaveDelay","showWithDelay","hideWithDelay","handleFocusOnReference","current","handleBlurOnReference","event","clearTimeout","relatedTarget","setTimeout","waitWindowBlurFire","reference","floating","handleClickOnReference","handleClickOnReferenceForOnlyClose","handleMouseEnterOnBoth","currentTarget","cancel","handleMouseLeaveOnBothForHoverAndFocusStates","handleFloatingAnimationStart","handleFloatingAnimationEnd","handleOnClose","handleRestoreFocus","restoreFocus","HTMLElement","handleEscapeKeyDown","handleClickOutside","setGlobalBlurForTriggerOnFocus","handleGlobalBlur","win","addEventListener","removeEventListener","resolveShownStates","referencePropsRef","floatingPropsRef","style","pointerEvents","onFocus","onBlur","onClick","onMouseOver","onMouseLeave","onAnimationStart","onAnimationEnd","referenceProps","floatingProps","onClose","onEscapeKeyDown","onRestoreFocus"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.ts"],"sourcesContent":["import * as React from 'react';\nimport { debounce, noop } from '@vkontakte/vkjs';\nimport { getWindow, isHTMLElement } from '@vkontakte/vkui-floating-ui/utils/dom';\nimport { useCustomEnsuredControl } from '../../../hooks/useEnsuredControl';\nimport { useGlobalOnClickOutside } from '../../../hooks/useGlobalOnClickOutside';\nimport { useStableCallback } from '../../../hooks/useStableCallback';\nimport { contains, getActiveElementByAnotherElement } from '../../dom';\nimport { useIsomorphicLayoutEffect } from '../../useIsomorphicLayoutEffect';\nimport { autoUpdateFloatingElement, useFloating } from '../adapters';\nimport { convertFloatingDataToReactCSSProperties } from '../functions';\nimport { type UseFloatingOptions } from '../types/common';\nimport { DEFAULT_TRIGGER } from './constants';\nimport type {\n  FloatingProps,\n  ReferenceProps,\n  ShownChangeReason,\n  UseFloatingWithInteractionsProps,\n  UseFloatingWithInteractionsReturn,\n} from './types';\nimport { useResolveTriggerType } from './useResolveTriggerType';\n\ntype LocalState = { shown: boolean; reason?: ShownChangeReason };\n\nconst whileElementsMounted: UseFloatingOptions['whileElementsMounted'] = (...args) =>\n  /* istanbul ignore next: не знаю как проверить */\n  autoUpdateFloatingElement(...args, { elementResize: true });\n\n/**\n * @private\n */\nexport const useFloatingWithInteractions = <T extends HTMLElement = HTMLElement>({\n  trigger = DEFAULT_TRIGGER,\n\n  // UseFloating\n  placement: placementProp = 'bottom',\n  strategy: strategyProp = 'fixed',\n  middlewares,\n  hoverDelay = 0,\n  closeAfterClick = false,\n\n  // disables\n  disabled = false,\n  disableInteractive = false,\n  disableCloseOnClickOutside = false,\n  disableCloseOnEscKey = false,\n\n  // uncontrolled\n  defaultShown = false,\n\n  // controlled\n  shown: shownProp,\n  onShownChange: onShownChangeProp,\n  onShownChanged: onShownChangedProp,\n}: UseFloatingWithInteractionsProps): UseFloatingWithInteractionsReturn<T> => {\n  const memoizedValue = React.useMemo<LocalState | undefined>(\n    () => (shownProp !== undefined ? { shown: shownProp } : undefined),\n    [shownProp],\n  );\n  const [shownLocalState, setShownLocalState] = useCustomEnsuredControl<LocalState>({\n    value: memoizedValue,\n    disabled,\n    defaultValue: { shown: defaultShown },\n    onChange: useStableCallback(({ shown, reason }) => {\n      if (onShownChangeProp) {\n        onShownChangeProp(shown, reason);\n      }\n    }),\n  });\n  const onShownChanged = useStableCallback(onShownChangedProp ? onShownChangedProp : noop);\n  const [shownFinalState, setShownFinalState] = React.useState(() => shownLocalState.shown);\n  const [willBeHide, setWillBeHide] = React.useState(false);\n\n  const hasCSSAnimation = React.useRef(false);\n\n  const blockMouseEnterRef = React.useRef(false);\n  const blockFocusRef = React.useRef(false);\n  const blurTimeoutRef = React.useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n\n  const handleCloseOnReferenceClickOutsideDisabled =\n    disabled || disableCloseOnClickOutside || willBeHide || !shownLocalState.shown;\n  const handleCloseOnFloatingClickOutsideDisabled =\n    disableInteractive || handleCloseOnReferenceClickOutsideDisabled;\n\n  const { triggerOnFocus, triggerOnClick, triggerOnHover } = useResolveTriggerType(trigger);\n\n  // Библиотека `floating-ui`\n  const { placement, x, y, strategy, refs, middlewareData } = useFloating<T>({\n    strategy: strategyProp,\n    placement: placementProp,\n    middleware: middlewares,\n    whileElementsMounted,\n  });\n\n  const commitShownLocalState = React.useCallback(\n    (nextShown: boolean, reason: ShownChangeReason) => {\n      setShownLocalState((prevState) => {\n        if (prevState.shown !== nextShown || prevState.reason !== reason) {\n          return {\n            shown: nextShown,\n            reason,\n          };\n        }\n        /* istanbul ignore next: страховка, если вдруг на момент вызова обновления состояния, оно уже будет актуальным */\n        return prevState;\n      });\n    },\n    [setShownLocalState],\n  );\n\n  const [mouseEnterDelay, mouseLeaveDelay] =\n    typeof hoverDelay === 'number' ? [hoverDelay, hoverDelay] : hoverDelay;\n\n  const showWithDelay = React.useMemo(\n    () => debounce(() => commitShownLocalState(true, 'hover'), mouseEnterDelay),\n    [mouseEnterDelay, commitShownLocalState],\n  );\n\n  const hideWithDelay = React.useMemo(\n    () => debounce(() => commitShownLocalState(false, 'hover'), mouseLeaveDelay),\n    [mouseLeaveDelay, commitShownLocalState],\n  );\n\n  const handleFocusOnReference = useStableCallback(() => {\n    // Повторный вызов события фокуса - следствие клика на reference-элемент\n    if (shownLocalState.shown) {\n      if (!closeAfterClick && shownLocalState.reason === 'hover') {\n        return;\n      }\n      commitShownLocalState(false, 'focus');\n      return;\n    }\n    if (blockFocusRef.current) {\n      /* istanbul ignore next: в Jest не воспроизводится баг на вебе (cм. onRestoreFocus) */\n      blockFocusRef.current = false;\n      return;\n    }\n\n    commitShownLocalState(true, 'focus');\n  });\n\n  const handleBlurOnReference = useStableCallback((event: React.FocusEvent) => {\n    blockFocusRef.current = false;\n    blockMouseEnterRef.current = false;\n\n    if (!shownLocalState.shown) {\n      clearTimeout(blurTimeoutRef.current);\n      return;\n    }\n\n    const relatedTarget = event.relatedTarget;\n    blurTimeoutRef.current = setTimeout(function waitWindowBlurFire() {\n      const reference = refs.reference.current;\n      // Если пользователь покинул текущее окно в открытом состоянии, то\n      // не закрываем всплывающий элемент.\n      /* istanbul ignore if: не умеем симулировать уход из текущего окна */\n      if (!relatedTarget && getActiveElementByAnotherElement(reference) === reference) {\n        /* istanbul ignore next */\n        return;\n      }\n\n      // Если пользователь нажал на всплывающий элемент, то не закрываем всплывающий элемент.\n      // Note: для этого элемент должен быть фокусируемый (например, за счёт `tabindex=\"-1\"`).\n      if (contains(refs.floating.current, relatedTarget) || contains(reference, relatedTarget)) {\n        return;\n      }\n\n      commitShownLocalState(false, 'focus');\n    });\n  });\n\n  const handleClickOnReference = useStableCallback(() => {\n    // Предыдущий триггер (фокус) уже вызвал открытие/закрытие всплывающего окна, игнорируем вызов\n    if (shownLocalState.reason === 'focus') {\n      commitShownLocalState(shownLocalState.shown, 'click');\n      return;\n    }\n    commitShownLocalState(!shownLocalState.shown, 'click');\n  });\n\n  const handleClickOnReferenceForOnlyClose = useStableCallback(() => {\n    blockMouseEnterRef.current = true;\n    commitShownLocalState(false, 'click');\n  });\n\n  const handleMouseEnterOnBoth = useStableCallback((event: React.MouseEvent<HTMLElement>) => {\n    if (willBeHide && event.currentTarget === refs.floating.current) {\n      return;\n    }\n\n    showWithDelay.cancel();\n    hideWithDelay.cancel();\n\n    if (!blockMouseEnterRef.current && !shownLocalState.shown) {\n      showWithDelay();\n    }\n  });\n\n  const handleMouseLeaveOnBothForHoverAndFocusStates = useStableCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      if (willBeHide && event.currentTarget === refs.floating.current) {\n        return;\n      }\n\n      blockFocusRef.current = false;\n      blockMouseEnterRef.current = false;\n\n      if (triggerOnHover) {\n        showWithDelay.cancel();\n        hideWithDelay.cancel();\n\n        hideWithDelay();\n      }\n    },\n  );\n\n  const handleFloatingAnimationStart = () => {\n    hasCSSAnimation.current = true;\n  };\n\n  const handleFloatingAnimationEnd = () => {\n    if (willBeHide) {\n      setShownFinalState(false);\n      setWillBeHide(false);\n      onShownChanged(false, shownLocalState.reason);\n    }\n  };\n\n  const handleOnClose = React.useCallback(() => {\n    blockFocusRef.current = true;\n    commitShownLocalState(false, 'callback');\n  }, [commitShownLocalState]);\n\n  const handleRestoreFocus: UseFloatingWithInteractionsReturn['onRestoreFocus'] = React.useCallback(\n    (restoreFocus = true) => {\n      if (!restoreFocus) {\n        return false;\n      }\n      if (restoreFocus === true) {\n        return triggerOnFocus ? blockFocusRef.current : true;\n      } else if (restoreFocus === 'anchor-element') {\n        return refs.reference.current as HTMLElement;\n      } else if (restoreFocus instanceof HTMLElement) {\n        return restoreFocus;\n      }\n      return false;\n    },\n    [refs.reference, triggerOnFocus],\n  );\n\n  const handleEscapeKeyDown = React.useCallback(() => {\n    blockFocusRef.current = true;\n    commitShownLocalState(false, 'escape-key');\n  }, [commitShownLocalState]);\n\n  const handleClickOutside = React.useCallback(() => {\n    blockFocusRef.current = true;\n    commitShownLocalState(false, 'click-outside');\n  }, [commitShownLocalState]);\n\n  useGlobalOnClickOutside(\n    handleClickOutside,\n    handleCloseOnReferenceClickOutsideDisabled ? null : refs.reference,\n    handleCloseOnFloatingClickOutsideDisabled ? null : refs.floating,\n  );\n\n  useIsomorphicLayoutEffect(\n    /**\n     * Если пользователь покинул активное окно и:\n     * 1. целевой элемент был в состоянии фокуса;\n     * 2. всплывающий элемент был закрытом состоянии;\n     * то фокус должен быть заблокирован, когда пользователь вернётся обратно. Иначе покажется\n     * всплывающий элемент.\n     */\n    function setGlobalBlurForTriggerOnFocus() {\n      if (!triggerOnFocus || !refs.reference.current) {\n        return;\n      }\n\n      const handleGlobalBlur = () => {\n        /* istanbul ignore next */\n        const reference = refs.reference.current;\n        /* istanbul ignore if: не умеем симулировать уход из текущего окна */\n        if (\n          !shownLocalState.shown &&\n          isHTMLElement(reference) &&\n          reference === getActiveElementByAnotherElement(reference)\n        ) {\n          /* istanbul ignore next */\n          blockFocusRef.current = true;\n        }\n      };\n\n      const win = getWindow(refs.reference.current);\n      win.addEventListener('blur', handleGlobalBlur);\n      return () => {\n        win.removeEventListener('blur', handleGlobalBlur);\n      };\n    },\n    [triggerOnFocus, refs.reference, shownLocalState],\n  );\n\n  useIsomorphicLayoutEffect(\n    function resolveShownStates() {\n      if (willBeHide || shownLocalState.shown === shownFinalState) {\n        return;\n      }\n\n      if (shownLocalState.shown) {\n        setShownFinalState(true);\n        onShownChanged(true, shownLocalState.reason);\n      } else if (hasCSSAnimation.current && !willBeHide) {\n        setWillBeHide(true);\n      } else {\n        setShownFinalState(false);\n      }\n\n      return () => {\n        clearTimeout(blurTimeoutRef.current);\n      };\n    },\n    [shownLocalState, shownFinalState, willBeHide, onShownChanged],\n  );\n\n  const referencePropsRef = React.useRef<ReferenceProps>({});\n  const floatingPropsRef = React.useRef<FloatingProps>({ style: {} });\n\n  useIsomorphicLayoutEffect(() => {\n    referencePropsRef.current = {};\n  }, [triggerOnHover, triggerOnFocus, triggerOnClick]);\n\n  if (shownFinalState) {\n    floatingPropsRef.current.style = convertFloatingDataToReactCSSProperties({\n      strategy,\n      x,\n      y,\n      middlewareData,\n    });\n\n    if (disableInteractive) {\n      floatingPropsRef.current.style.pointerEvents = 'none';\n    }\n  }\n\n  if (triggerOnFocus) {\n    referencePropsRef.current.onFocus = handleFocusOnReference;\n    referencePropsRef.current.onBlur = handleBlurOnReference;\n  }\n\n  if (triggerOnClick) {\n    referencePropsRef.current.onClick = handleClickOnReference;\n  }\n\n  if (triggerOnHover) {\n    referencePropsRef.current.onMouseOver = handleMouseEnterOnBoth;\n\n    if (closeAfterClick && !triggerOnClick) {\n      referencePropsRef.current.onClick = handleClickOnReferenceForOnlyClose;\n    }\n\n    if (!disableInteractive) {\n      floatingPropsRef.current.onMouseOver = handleMouseEnterOnBoth;\n    }\n  }\n\n  if (triggerOnHover || triggerOnFocus) {\n    referencePropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;\n\n    if (!disableInteractive) {\n      floatingPropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;\n    }\n  }\n\n  if (shownFinalState) {\n    floatingPropsRef.current.onAnimationStart = handleFloatingAnimationStart;\n    floatingPropsRef.current.onAnimationEnd = handleFloatingAnimationEnd;\n  }\n\n  return {\n    placement,\n    shown: shownFinalState,\n    willBeHide,\n    refs,\n    referenceProps: referencePropsRef.current,\n    floatingProps: floatingPropsRef.current,\n    middlewareData,\n    onClose: handleOnClose,\n    // FocusTrap уже определяет нажатие на ESC, поэтому название события содержит конкретный код\n    // кнопки вместо просто onKeyDown.\n    onEscapeKeyDown: !shownFinalState || disableCloseOnEscKey ? undefined : handleEscapeKeyDown,\n    // [Обход баги с FocusTrap]\n    //\n    // Если сфокусироваться на целевой элемент через нажатие, а потом нажать в область за пределами\n    // целевого и всплывающего элемента, то появляется моргание из-за того, что FocusTrap\n    // восстанавливает фокус, из-за чего всплывающий элемент снова показывается за счёт\n    // `handleFocusOnReference`, а потом скрывается за счёт `handleBlurOnReference`.\n    onRestoreFocus: handleRestoreFocus,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}