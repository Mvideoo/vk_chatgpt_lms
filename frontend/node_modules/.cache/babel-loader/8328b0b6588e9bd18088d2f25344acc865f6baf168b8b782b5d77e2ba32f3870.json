{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { usePlatform } from \"../../hooks/usePlatform.js\";\nimport { usePrevious } from \"../../hooks/usePrevious.js\";\nimport { blurActiveElement, useDOM } from \"../../lib/dom.js\";\nimport { getNavId } from \"../../lib/getNavId.js\";\nimport { warnOnce } from \"../../lib/warnOnce.js\";\nimport { useScroll } from \"../AppRoot/ScrollContext.js\";\nimport { useConfigProvider } from \"../ConfigProvider/ConfigProviderContext.js\";\nimport { NavViewIdContext } from \"../NavIdContext/NavIdContext.js\";\nimport { NavTransitionProvider } from \"../NavTransitionContext/NavTransitionContext.js\";\nimport { NavTransitionDirectionProvider } from \"../NavTransitionDirectionContext/NavTransitionDirectionContext.js\";\nimport { useSplitCol } from \"../SplitCol/SplitColContext.js\";\nimport { Touch } from \"../Touch/Touch.js\";\nimport { useLayoutEffectCall } from \"./useLayoutEffectCall.js\";\nimport { getSwipeBackPredicates, hasHorizontalScrollableElementWithScrolledToLeft, swipeBackExcluded } from \"./utils.js\";\nexport let scrollsCache = {};\nconst warn = warnOnce('View');\n/**\n * @see https://vkcom.github.io/VKUI/#/View\n */\nexport const View = _param => {\n  var {\n      activePanel: activePanelProp,\n      history,\n      nav,\n      onTransition,\n      onSwipeBack,\n      onSwipeBackStart,\n      onSwipeBackCancel: onSwipeBackCancelProp,\n      children,\n      className\n    } = _param,\n    restProps = _object_without_properties(_param, [\"activePanel\", \"history\", \"nav\", \"onTransition\", \"onSwipeBack\", \"onSwipeBackStart\", \"onSwipeBackCancel\", \"children\", \"className\"]);\n  const id = getNavId({\n    nav,\n    id: restProps.id\n  });\n  const scrolls = React.useRef(scrollsCache[id] || {});\n  const layoutEffectCall = useLayoutEffectCall();\n  React.useEffect(() => () => {\n    if (id) {\n      scrollsCache[id] = scrolls.current;\n    }\n  });\n  const panelNodes = React.useRef({});\n  const {\n    window,\n    document\n  } = useDOM();\n  const scroll = useScroll();\n  const configProvider = useConfigProvider();\n  const splitCol = useSplitCol();\n  const platform = usePlatform();\n  const [animated, setAnimated] = React.useState(false);\n  const [visiblePanels, setVisiblePanels] = React.useState([activePanelProp]);\n  const [activePanel, setActivePanel] = React.useState(activePanelProp);\n  const [isBack, setIsBack] = React.useState(undefined);\n  const [prevPanel, setPrevPanel] = React.useState(null);\n  const [nextPanel, setNextPanel] = React.useState(null);\n  const swipeBackPrevented = React.useRef(false);\n  const [swipingBack, setSwipingBack] = React.useState(undefined);\n  const [swipeBackStartX, setSwipeBackStartX] = React.useState(0);\n  const [swipeBackShift, setSwipeBackShift] = React.useState(0);\n  const [swipeBackNextPanel, setSwipeBackNextPanel] = React.useState(null);\n  const [swipeBackPrevPanel, setSwipeBackPrevPanel] = React.useState(null);\n  const [swipeBackResult, setSwipeBackResult] = React.useState(null);\n  const [browserSwipe, setBrowserSwipe] = React.useState(false);\n  const prevActivePanel = usePrevious(activePanelProp);\n  const prevSwipingBack = usePrevious(swipingBack);\n  const prevBrowserSwipe = usePrevious(browserSwipe);\n  const prevSwipeBackResult = usePrevious(swipeBackResult);\n  const prevSwipeBackShift = usePrevious(swipeBackShift);\n  const prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);\n  const prevOnTransition = usePrevious(onTransition);\n  const panels = React.Children.toArray(children).filter(panel => {\n    const panelId = getNavId(panel.props, warn);\n    return panelId !== undefined && visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;\n  });\n  const disableAnimation = !configProvider.transitionMotionEnabled || !splitCol.animate || platform === 'vkcom';\n  const iOSSwipeBackSimulationEnabled = !disableAnimation && platform === 'ios' && configProvider.isWebView && Boolean(onSwipeBack);\n  const flushTransition = React.useCallback((prevPanel, isBackTransition) => {\n    if (isBackTransition) {\n      scrolls.current[prevPanel] = 0;\n    }\n    setPrevPanel(null);\n    setNextPanel(null);\n    setVisiblePanels([activePanelProp]);\n    setActivePanel(activePanelProp);\n    setAnimated(false);\n    setIsBack(isBackTransition);\n    layoutEffectCall(() => {\n      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);\n      onTransition && onTransition({\n        isBack: isBackTransition,\n        from: prevPanel,\n        to: activePanelProp\n      });\n    });\n  }, [activePanelProp, layoutEffectCall, onTransition, scroll]);\n  const handleAnimatedTargetAnimationEnd = () => {\n    if (prevPanel !== null) {\n      flushTransition(prevPanel, Boolean(isBack));\n    }\n  };\n  const onSwipeBackSuccess = React.useCallback(() => {\n    onSwipeBack && onSwipeBack();\n  }, [onSwipeBack]);\n  const onSwipeBackCancel = React.useCallback(() => {\n    onSwipeBackCancelProp && onSwipeBackCancelProp();\n    setSwipeBackPrevPanel(null);\n    setSwipeBackNextPanel(null);\n    setSwipingBack(false);\n    setSwipeBackResult(null);\n    setSwipeBackStartX(0);\n    setSwipeBackShift(0);\n  }, [onSwipeBackCancelProp]);\n  const swipingBackTransitionEndHandler = React.useCallback(() => {\n    switch (swipeBackResult) {\n      case 'fail':\n        onSwipeBackCancel();\n        break;\n      case 'success':\n        onSwipeBackSuccess();\n    }\n  }, [onSwipeBackCancel, onSwipeBackSuccess, swipeBackResult]);\n  const handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = event => {\n    if (browserSwipe) {\n      return;\n    }\n    const {\n      swipeBackTriggered,\n      viewportStartEdgeTouched,\n      viewportEndEdgeTouched\n    } = getSwipeBackPredicates(event.startX, event.shiftX, window.innerWidth);\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      setBrowserSwipe(true);\n    }\n  };\n  const handleTouchMoveXForIOSSwipeBackSimulation = event => {\n    if (swipeBackPrevented.current || swipeBackExcluded(event)) {\n      return;\n    }\n    const {\n      swipedToOpposite,\n      swipeBackTriggered,\n      viewportStartEdgeTouched\n    } = getSwipeBackPredicates(event.startX, event.shiftX, window.innerWidth);\n    if (animated && swipeBackTriggered) {\n      return;\n    }\n    if (!swipingBack && history && history.length > 1) {\n      if (swipedToOpposite) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n      if (!swipeBackTriggered) {\n        return;\n      }\n      if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n      // Начался свайп назад\n      if (onSwipeBackStart) {\n        const payload = onSwipeBackStart(activePanel);\n        if (payload === 'prevent') {\n          swipeBackPrevented.current = true;\n          return;\n        }\n      }\n      if (activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        blurActiveElement(document);\n        scrolls.current[activePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n      }\n      setSwipingBack(true);\n      setSwipeBackStartX(event.startX);\n      setSwipeBackPrevPanel(activePanel);\n      setSwipeBackNextPanel(history.slice(-2)[0]);\n    }\n    if (swipingBack) {\n      if (event.shiftX < 0) {\n        setSwipeBackShift(0);\n      } else if (event.shiftX > window.innerWidth - swipeBackStartX) {\n        setSwipeBackShift(window.innerWidth);\n      } else {\n        setSwipeBackShift(event.shiftX);\n      }\n    }\n  };\n  const handleTouchEndForIOSSwipeBackSimulation = event => {\n    swipeBackPrevented.current = false;\n    if (swipingBack) {\n      const speed = swipeBackShift / event.duration * 1000;\n      var _window_innerWidth;\n      if (swipeBackShift === 0) {\n        onSwipeBackCancel();\n      } else if (swipeBackShift >= ((_window_innerWidth = window.innerWidth) !== null && _window_innerWidth !== void 0 ? _window_innerWidth : 0)) {\n        onSwipeBackSuccess();\n      } else if (speed > 250 || swipeBackShift >= window.innerWidth / 2) {\n        setSwipeBackResult('success');\n      } else {\n        setSwipeBackResult('fail');\n      }\n    }\n  };\n  const calcPanelSwipeStyles = (isPrev, isNext) => {\n    if (!isPrev && !isNext || swipeBackResult) {\n      return {};\n    }\n    if (isNext) {\n      return window ? {\n        transform: `translate3d(${-50 + swipeBackShift * 100 / window.innerWidth / 2}%, 0, 0)`\n      } : {};\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${swipeBackShift}px, 0, 0)`\n      };\n    }\n    return {};\n  };\n  const calcPanelSwipeBackOverlayStyles = isNext => {\n    if (!window || !isNext) {\n      return {};\n    }\n    const opacityOnSwipeEnd = swipeBackResult === 'success' ? 0 : swipeBackResult === 'fail' ? 1 : null;\n    return {\n      display: 'block',\n      opacity: opacityOnSwipeEnd === null ? 1 - swipeBackShift / window.innerWidth : opacityOnSwipeEnd\n    };\n  };\n  const handleSwipeBackTargetTransitionEnd = event => {\n    if (event.propertyName.includes('transform')) {\n      swipingBackTransitionEndHandler();\n    }\n  };\n  React.useEffect(() => {\n    // Нужен переход\n    if (prevActivePanel && prevActivePanel !== activePanelProp && !prevSwipingBack && !prevBrowserSwipe) {\n      const firstLayerId = React.Children.toArray(children).map(panel => getNavId(panel.props, warn)).find(id => id === prevActivePanel || id === activePanelProp);\n      const isBackTransition = firstLayerId === activePanelProp;\n      scrolls.current[prevActivePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll({\n        compensateKeyboardHeight: false\n      }).y;\n      if (disableAnimation) {\n        flushTransition(prevActivePanel, isBackTransition);\n      } else {\n        blurActiveElement(document);\n        setVisiblePanels([prevActivePanel, activePanelProp]);\n        setPrevPanel(prevActivePanel);\n        setNextPanel(activePanelProp);\n        setActivePanel(null);\n        setAnimated(true);\n        setIsBack(isBackTransition);\n      }\n    }\n    // Закончилась анимация свайпа назад\n    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {\n      const nextPanel = activePanelProp;\n      const prevPanel = prevActivePanel;\n      if (prevSwipeBackPrevPanel) {\n        scrolls.current[prevSwipeBackPrevPanel] = 0;\n      }\n      setSwipeBackPrevPanel(null);\n      setSwipeBackNextPanel(null);\n      setSwipingBack(false);\n      setSwipeBackResult(null);\n      setSwipeBackStartX(0);\n      setSwipeBackShift(0);\n      setActivePanel(nextPanel);\n      setVisiblePanels([nextPanel]);\n      setIsBack(true);\n      layoutEffectCall(() => {\n        if (nextPanel !== null) {\n          scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[nextPanel]);\n        }\n        prevOnTransition && prevOnTransition({\n          isBack: true,\n          from: prevPanel,\n          to: nextPanel\n        });\n      });\n    }\n    // Началась анимация завершения свайпа назад.\n    // см. `onTransitionEnd()`\n    // Закончился Safari свайп\n    if (prevActivePanel !== activePanelProp && browserSwipe) {\n      setBrowserSwipe(false);\n      setNextPanel(null);\n      setPrevPanel(null);\n      setAnimated(false);\n      setVisiblePanels([activePanelProp]);\n      setActivePanel(activePanelProp);\n    }\n  }, [activePanelProp, activePanel, browserSwipe, children, disableAnimation, document, flushTransition, prevActivePanel, prevBrowserSwipe, prevOnTransition, prevSwipeBackPrevPanel, prevSwipeBackResult, prevSwipingBack, scroll, swipeBackNextPanel, swipeBackResult, layoutEffectCall]);\n  React.useEffect(function restoreScrollPositionWhenSwipeBackIsCancelled() {\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    const swipeBackCancelledInTheMiddleOfAction = prevSwipeBackResult === 'fail' && !swipeBackResult;\n    const swipeBackCancelledByMovingPanelBackToInitialPoint = prevSwipingBack && !swipingBack && prevSwipeBackShift === 0;\n    if ((swipeBackCancelledInTheMiddleOfAction || swipeBackCancelledByMovingPanelBackToInitialPoint) && activePanel !== null) {\n      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[activePanel]);\n    }\n  }, [prevSwipeBackResult, swipeBackResult, prevSwipingBack, swipingBack, prevSwipeBackShift, activePanel, scroll]);\n  return /*#__PURE__*/_jsx(NavViewIdContext.Provider, {\n    value: id,\n    children: /*#__PURE__*/_jsx(Touch, _object_spread_props(_object_spread({\n      Component: \"section\"\n    }, restProps), {\n      className: classNames(\"vkuiView__host\", platform === 'ios' && classNames(\"vkuiView__ios\", 'vkuiInternalView--ios'), !disableAnimation && animated && \"vkuiView__animated\", !disableAnimation && swipingBack && \"vkuiView__swipingBack\", disableAnimation && \"vkuiView__noMotion\", className),\n      onMoveX: iOSSwipeBackSimulationEnabled ? handleTouchMoveXForIOSSwipeBackSimulation : platform === 'ios' ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : undefined,\n      onEnd: iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : undefined,\n      children: /*#__PURE__*/_jsx(\"div\", {\n        className: \"vkuiView__panels\",\n        children: panels.map(panel => {\n          const panelId = getNavId(panel.props, warn);\n          const isPanelActive = panelId === activePanel;\n          const isPanelPrev = panelId === prevPanel;\n          const isPanelNext = panelId === nextPanel;\n          const isAnimatedTarget = animated && (isBack ? isPanelPrev : isPanelNext);\n          const isSwipeBackPrev = panelId === swipeBackPrevPanel;\n          const isSwipeBackNext = panelId === swipeBackNextPanel;\n          const isSwipeBackTarget = swipeBackResult && isSwipeBackPrev;\n          let scrollCompensateStyle = undefined;\n          if (isPanelPrev || isPanelNext && isBack || isSwipeBackPrev || isSwipeBackNext) {\n            const marginTop = scrolls.current[panelId];\n            if (marginTop !== undefined) {\n              scrollCompensateStyle = {\n                marginTop: -1 * marginTop\n              };\n            }\n          }\n          return /*#__PURE__*/_jsxs(\"div\", {\n            className: classNames(\"vkuiView__panel\", isPanelActive && \"vkuiView__panelActive\", isPanelPrev && \"vkuiView__panelPrev\", isPanelNext && \"vkuiView__panelNext\", isSwipeBackPrev && \"vkuiView__panelSwipeBackPrev\", isSwipeBackNext && \"vkuiView__panelSwipeBackNext\", swipeBackResult === 'success' && \"vkuiView__panelSwipeBackSuccess\", swipeBackResult === 'fail' && \"vkuiView__panelSwipeBackFailed\"),\n            onTransitionEnd: isSwipeBackTarget ? handleSwipeBackTargetTransitionEnd : undefined,\n            onAnimationEnd: isAnimatedTarget ? handleAnimatedTargetAnimationEnd : undefined,\n            ref: el => {\n              panelId !== undefined && (panelNodes.current[panelId] = el);\n            },\n            style: calcPanelSwipeStyles(isSwipeBackPrev, isSwipeBackNext),\n            children: [platform === 'ios' && /*#__PURE__*/_jsx(\"div\", {\n              className: \"vkuiView__panelOverlay\",\n              style: calcPanelSwipeBackOverlayStyles(isSwipeBackNext)\n            }), /*#__PURE__*/_jsx(\"div\", {\n              className: \"vkuiView__panelIn\",\n              style: scrollCompensateStyle,\n              children: /*#__PURE__*/_jsx(NavTransitionDirectionProvider, {\n                isBack: swipingBack || isBack,\n                children: /*#__PURE__*/_jsx(NavTransitionProvider, {\n                  entering: panelId === nextPanel || panelId === swipeBackNextPanel,\n                  children: panel\n                })\n              })\n            })]\n          }, panelId);\n        })\n      })\n    }))\n  });\n};","map":{"version":3,"names":["React","classNames","usePlatform","usePrevious","blurActiveElement","useDOM","getNavId","warnOnce","useScroll","useConfigProvider","NavViewIdContext","NavTransitionProvider","NavTransitionDirectionProvider","useSplitCol","Touch","useLayoutEffectCall","getSwipeBackPredicates","hasHorizontalScrollableElementWithScrolledToLeft","swipeBackExcluded","scrollsCache","warn","View","_param","activePanel","activePanelProp","history","nav","onTransition","onSwipeBack","onSwipeBackStart","onSwipeBackCancel","onSwipeBackCancelProp","children","className","restProps","_object_without_properties","id","scrolls","useRef","layoutEffectCall","useEffect","current","panelNodes","window","document","scroll","configProvider","splitCol","platform","animated","setAnimated","useState","visiblePanels","setVisiblePanels","setActivePanel","isBack","setIsBack","undefined","prevPanel","setPrevPanel","nextPanel","setNextPanel","swipeBackPrevented","swipingBack","setSwipingBack","swipeBackStartX","setSwipeBackStartX","swipeBackShift","setSwipeBackShift","swipeBackNextPanel","setSwipeBackNextPanel","swipeBackPrevPanel","setSwipeBackPrevPanel","swipeBackResult","setSwipeBackResult","browserSwipe","setBrowserSwipe","prevActivePanel","prevSwipingBack","prevBrowserSwipe","prevSwipeBackResult","prevSwipeBackShift","prevSwipeBackPrevPanel","prevOnTransition","panels","Children","toArray","filter","panel","panelId","props","includes","disableAnimation","transitionMotionEnabled","animate","iOSSwipeBackSimulationEnabled","isWebView","Boolean","flushTransition","useCallback","isBackTransition","scrollTo","from","to","handleAnimatedTargetAnimationEnd","onSwipeBackSuccess","swipingBackTransitionEndHandler","handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext","event","swipeBackTriggered","viewportStartEdgeTouched","viewportEndEdgeTouched","startX","shiftX","innerWidth","handleTouchMoveXForIOSSwipeBackSimulation","swipedToOpposite","length","originalEvent","target","payload","getScroll","y","slice","handleTouchEndForIOSSwipeBackSimulation","speed","duration","_window_innerWidth","calcPanelSwipeStyles","isPrev","isNext","transform","calcPanelSwipeBackOverlayStyles","opacityOnSwipeEnd","display","opacity","handleSwipeBackTargetTransitionEnd","propertyName","firstLayerId","map","find","compensateKeyboardHeight","restoreScrollPositionWhenSwipeBackIsCancelled","swipeBackCancelledInTheMiddleOfAction","swipeBackCancelledByMovingPanelBackToInitialPoint","_jsx","Provider","value","_object_spread_props","_object_spread","Component","onMoveX","onEnd","isPanelActive","isPanelPrev","isPanelNext","isAnimatedTarget","isSwipeBackPrev","isSwipeBackNext","isSwipeBackTarget","scrollCompensateStyle","marginTop","_jsxs","onTransitionEnd","onAnimationEnd","ref","el","style","entering"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/View/View.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { usePrevious } from '../../hooks/usePrevious';\nimport { blurActiveElement, useDOM } from '../../lib/dom';\nimport { getNavId, type NavIdProps } from '../../lib/getNavId';\nimport { warnOnce } from '../../lib/warnOnce';\nimport type { HTMLAttributesWithRootRef } from '../../types';\nimport { useScroll } from '../AppRoot/ScrollContext';\nimport { useConfigProvider } from '../ConfigProvider/ConfigProviderContext';\nimport { NavViewIdContext } from '../NavIdContext/NavIdContext';\nimport { NavTransitionProvider } from '../NavTransitionContext/NavTransitionContext';\nimport { NavTransitionDirectionProvider } from '../NavTransitionDirectionContext/NavTransitionDirectionContext';\nimport { useSplitCol } from '../SplitCol/SplitColContext';\nimport { type CustomTouchEvent, Touch } from '../Touch/Touch';\nimport { useLayoutEffectCall } from './useLayoutEffectCall';\nimport {\n  getSwipeBackPredicates,\n  hasHorizontalScrollableElementWithScrolledToLeft,\n  swipeBackExcluded,\n} from './utils';\nimport styles from './View.module.css';\n\ninterface Scrolls {\n  [index: string]: number | undefined;\n}\n\ninterface ViewsScrolls {\n  [index: string]: Scrolls;\n}\n\nexport let scrollsCache: ViewsScrolls = {};\n\nexport interface ViewProps extends HTMLAttributesWithRootRef<HTMLElement>, NavIdProps {\n  activePanel: string;\n  onTransition?: (params: { isBack: boolean; from: string; to: string }) => void;\n  /**\n   * callback свайпа назад\n   */\n  onSwipeBack?: () => void;\n  /**\n   * callback начала анимации свайпа назад.\n   *\n   * Чтобы остановить свайп назад, возвращайте `\"prevent\"`.\n   */\n  onSwipeBackStart?: (activePanel: string | null) => void | 'prevent';\n  /**\n   * callback завершения анимации отмененного пользователем свайпа\n   */\n  onSwipeBackCancel?: () => void;\n  history?: string[];\n\n  children: React.ReactElement | Iterable<React.ReactElement>;\n}\n\nconst warn = warnOnce('View');\n\n/**\n * @see https://vkcom.github.io/VKUI/#/View\n */\nexport const View = ({\n  activePanel: activePanelProp,\n  history,\n  nav,\n  onTransition,\n  onSwipeBack,\n  onSwipeBackStart,\n  onSwipeBackCancel: onSwipeBackCancelProp,\n  children,\n  className,\n  ...restProps\n}: ViewProps): React.ReactNode => {\n  const id = getNavId({ nav, id: restProps.id });\n  const scrolls = React.useRef(scrollsCache[id as string] || {});\n  const layoutEffectCall = useLayoutEffectCall();\n\n  React.useEffect(() => () => {\n    if (id) {\n      scrollsCache[id] = scrolls.current;\n    }\n  });\n\n  const panelNodes = React.useRef<{ [id: string]: HTMLDivElement | null }>({});\n\n  const { window, document } = useDOM();\n  const scroll = useScroll();\n  const configProvider = useConfigProvider();\n  const splitCol = useSplitCol();\n  const platform = usePlatform();\n\n  const [animated, setAnimated] = React.useState(false);\n\n  const [visiblePanels, setVisiblePanels] = React.useState([activePanelProp]);\n  const [activePanel, setActivePanel] = React.useState<string | null>(activePanelProp);\n  const [isBack, setIsBack] = React.useState<boolean | undefined>(undefined);\n  const [prevPanel, setPrevPanel] = React.useState<string | null>(null);\n  const [nextPanel, setNextPanel] = React.useState<string | null>(null);\n\n  const swipeBackPrevented = React.useRef<boolean>(false);\n  const [swipingBack, setSwipingBack] = React.useState<boolean | undefined>(undefined);\n  const [swipeBackStartX, setSwipeBackStartX] = React.useState<number>(0);\n  const [swipeBackShift, setSwipeBackShift] = React.useState<number>(0);\n  const [swipeBackNextPanel, setSwipeBackNextPanel] = React.useState<string | null>(null);\n  const [swipeBackPrevPanel, setSwipeBackPrevPanel] = React.useState<string | null>(null);\n  const [swipeBackResult, setSwipeBackResult] = React.useState<'success' | 'fail' | null>(null);\n\n  const [browserSwipe, setBrowserSwipe] = React.useState(false);\n\n  const prevActivePanel = usePrevious(activePanelProp);\n  const prevSwipingBack = usePrevious(swipingBack);\n  const prevBrowserSwipe = usePrevious(browserSwipe);\n  const prevSwipeBackResult = usePrevious(swipeBackResult);\n  const prevSwipeBackShift = usePrevious(swipeBackShift);\n  const prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);\n  const prevOnTransition = usePrevious(onTransition);\n\n  const panels = (React.Children.toArray(children) as Array<React.ReactElement<NavIdProps>>).filter(\n    (panel) => {\n      const panelId = getNavId(panel.props, warn);\n\n      return (\n        (panelId !== undefined && visiblePanels.includes(panelId)) ||\n        panelId === swipeBackPrevPanel ||\n        panelId === swipeBackNextPanel\n      );\n    },\n  );\n\n  const disableAnimation =\n    !configProvider.transitionMotionEnabled || !splitCol.animate || platform === 'vkcom';\n  const iOSSwipeBackSimulationEnabled =\n    !disableAnimation && platform === 'ios' && configProvider.isWebView && Boolean(onSwipeBack);\n\n  const flushTransition = React.useCallback(\n    (prevPanel: string, isBackTransition: boolean) => {\n      if (isBackTransition) {\n        scrolls.current[prevPanel] = 0;\n      }\n      setPrevPanel(null);\n      setNextPanel(null);\n      setVisiblePanels([activePanelProp]);\n      setActivePanel(activePanelProp);\n      setAnimated(false);\n      setIsBack(isBackTransition);\n\n      layoutEffectCall(() => {\n        scroll?.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);\n        onTransition &&\n          onTransition({\n            isBack: isBackTransition,\n            from: prevPanel,\n            to: activePanelProp,\n          });\n      });\n    },\n    [activePanelProp, layoutEffectCall, onTransition, scroll],\n  );\n\n  const handleAnimatedTargetAnimationEnd = () => {\n    if (prevPanel !== null) {\n      flushTransition(prevPanel, Boolean(isBack));\n    }\n  };\n\n  const onSwipeBackSuccess = React.useCallback(() => {\n    onSwipeBack && onSwipeBack();\n  }, [onSwipeBack]);\n\n  const onSwipeBackCancel = React.useCallback(() => {\n    onSwipeBackCancelProp && onSwipeBackCancelProp();\n    setSwipeBackPrevPanel(null);\n    setSwipeBackNextPanel(null);\n    setSwipingBack(false);\n    setSwipeBackResult(null);\n    setSwipeBackStartX(0);\n    setSwipeBackShift(0);\n  }, [onSwipeBackCancelProp]);\n\n  const swipingBackTransitionEndHandler = React.useCallback(() => {\n    switch (swipeBackResult) {\n      case 'fail':\n        onSwipeBackCancel();\n        break;\n      case 'success':\n        onSwipeBackSuccess();\n    }\n  }, [onSwipeBackCancel, onSwipeBackSuccess, swipeBackResult]);\n\n  const handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event: CustomTouchEvent) => {\n    if (browserSwipe) {\n      return;\n    }\n    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, window!.innerWidth);\n\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      setBrowserSwipe(true);\n    }\n  };\n\n  const handleTouchMoveXForIOSSwipeBackSimulation = (event: CustomTouchEvent) => {\n    if (swipeBackPrevented.current || swipeBackExcluded(event)) {\n      return;\n    }\n\n    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, window!.innerWidth);\n\n    if (animated && swipeBackTriggered) {\n      return;\n    }\n\n    if (!swipingBack && history && history.length > 1) {\n      if (swipedToOpposite) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n\n      if (!swipeBackTriggered) {\n        return;\n      }\n\n      if (\n        !viewportStartEdgeTouched &&\n        hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target as HTMLElement)\n      ) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n      // Начался свайп назад\n      if (onSwipeBackStart) {\n        const payload = onSwipeBackStart(activePanel);\n        if (payload === 'prevent') {\n          swipeBackPrevented.current = true;\n          return;\n        }\n      }\n\n      if (activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        blurActiveElement(document);\n        scrolls.current[activePanel] = scroll?.getScroll().y;\n      }\n\n      setSwipingBack(true);\n      setSwipeBackStartX(event.startX);\n      setSwipeBackPrevPanel(activePanel);\n      setSwipeBackNextPanel(history.slice(-2)[0]);\n    }\n\n    if (swipingBack) {\n      if (event.shiftX < 0) {\n        setSwipeBackShift(0);\n      } else if (event.shiftX > window!.innerWidth - swipeBackStartX) {\n        setSwipeBackShift(window!.innerWidth);\n      } else {\n        setSwipeBackShift(event.shiftX);\n      }\n    }\n  };\n\n  const handleTouchEndForIOSSwipeBackSimulation = (event: CustomTouchEvent) => {\n    swipeBackPrevented.current = false;\n    if (swipingBack) {\n      const speed = (swipeBackShift / event.duration) * 1000;\n      if (swipeBackShift === 0) {\n        onSwipeBackCancel();\n      } else if (swipeBackShift >= (window!.innerWidth ?? 0)) {\n        onSwipeBackSuccess();\n      } else if (speed > 250 || swipeBackShift >= window!.innerWidth / 2) {\n        setSwipeBackResult('success');\n      } else {\n        setSwipeBackResult('fail');\n      }\n    }\n  };\n\n  const calcPanelSwipeStyles = (isPrev: boolean, isNext: boolean): React.CSSProperties => {\n    if ((!isPrev && !isNext) || swipeBackResult) {\n      return {};\n    }\n\n    if (isNext) {\n      return window\n        ? {\n            transform: `translate3d(${-50 + (swipeBackShift * 100) / window.innerWidth / 2}%, 0, 0)`,\n          }\n        : {};\n    }\n\n    if (isPrev) {\n      return { transform: `translate3d(${swipeBackShift}px, 0, 0)` };\n    }\n\n    return {};\n  };\n\n  const calcPanelSwipeBackOverlayStyles = (isNext: boolean): React.CSSProperties => {\n    if (!window || !isNext) {\n      return {};\n    }\n    const opacityOnSwipeEnd =\n      swipeBackResult === 'success' ? 0 : swipeBackResult === 'fail' ? 1 : null;\n\n    return {\n      display: 'block',\n      opacity:\n        opacityOnSwipeEnd === null ? 1 - swipeBackShift / window.innerWidth : opacityOnSwipeEnd,\n    };\n  };\n\n  const handleSwipeBackTargetTransitionEnd = (event: React.TransitionEvent<HTMLDivElement>) => {\n    if (event.propertyName.includes('transform')) {\n      swipingBackTransitionEndHandler();\n    }\n  };\n\n  React.useEffect(() => {\n    // Нужен переход\n    if (\n      prevActivePanel &&\n      prevActivePanel !== activePanelProp &&\n      !prevSwipingBack &&\n      !prevBrowserSwipe\n    ) {\n      const firstLayerId = (\n        React.Children.toArray(children) as Array<React.ReactElement<NavIdProps>>\n      )\n        .map((panel) => getNavId(panel.props, warn))\n        .find((id) => id === prevActivePanel || id === activePanelProp);\n\n      const isBackTransition = firstLayerId === activePanelProp;\n      scrolls.current[prevActivePanel] = scroll?.getScroll({ compensateKeyboardHeight: false }).y;\n\n      if (disableAnimation) {\n        flushTransition(prevActivePanel, isBackTransition);\n      } else {\n        blurActiveElement(document);\n\n        setVisiblePanels([prevActivePanel, activePanelProp]);\n        setPrevPanel(prevActivePanel);\n        setNextPanel(activePanelProp);\n        setActivePanel(null);\n        setAnimated(true);\n        setIsBack(isBackTransition);\n      }\n    }\n\n    // Закончилась анимация свайпа назад\n    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {\n      const nextPanel = activePanelProp;\n      const prevPanel = prevActivePanel;\n      if (prevSwipeBackPrevPanel) {\n        scrolls.current[prevSwipeBackPrevPanel] = 0;\n      }\n\n      setSwipeBackPrevPanel(null);\n      setSwipeBackNextPanel(null);\n      setSwipingBack(false);\n      setSwipeBackResult(null);\n      setSwipeBackStartX(0);\n      setSwipeBackShift(0);\n      setActivePanel(nextPanel);\n      setVisiblePanels([nextPanel]);\n      setIsBack(true);\n\n      layoutEffectCall(() => {\n        if (nextPanel !== null) {\n          scroll?.scrollTo(0, scrolls.current[nextPanel]);\n        }\n        prevOnTransition &&\n          prevOnTransition({\n            isBack: true,\n            from: prevPanel,\n            to: nextPanel,\n          });\n      });\n    }\n\n    // Началась анимация завершения свайпа назад.\n    // см. `onTransitionEnd()`\n\n    // Закончился Safari свайп\n    if (prevActivePanel !== activePanelProp && browserSwipe) {\n      setBrowserSwipe(false);\n      setNextPanel(null);\n      setPrevPanel(null);\n      setAnimated(false);\n      setVisiblePanels([activePanelProp]);\n      setActivePanel(activePanelProp);\n    }\n  }, [\n    activePanelProp,\n    activePanel,\n    browserSwipe,\n    children,\n    disableAnimation,\n    document,\n    flushTransition,\n    prevActivePanel,\n    prevBrowserSwipe,\n    prevOnTransition,\n    prevSwipeBackPrevPanel,\n    prevSwipeBackResult,\n    prevSwipingBack,\n    scroll,\n    swipeBackNextPanel,\n    swipeBackResult,\n    layoutEffectCall,\n  ]);\n\n  React.useEffect(\n    function restoreScrollPositionWhenSwipeBackIsCancelled() {\n      // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n      const swipeBackCancelledInTheMiddleOfAction =\n        prevSwipeBackResult === 'fail' && !swipeBackResult;\n      const swipeBackCancelledByMovingPanelBackToInitialPoint =\n        prevSwipingBack && !swipingBack && prevSwipeBackShift === 0;\n\n      if (\n        (swipeBackCancelledInTheMiddleOfAction ||\n          swipeBackCancelledByMovingPanelBackToInitialPoint) &&\n        activePanel !== null\n      ) {\n        scroll?.scrollTo(0, scrolls.current[activePanel]);\n      }\n    },\n    [\n      prevSwipeBackResult,\n      swipeBackResult,\n      prevSwipingBack,\n      swipingBack,\n      prevSwipeBackShift,\n      activePanel,\n      scroll,\n    ],\n  );\n\n  return (\n    <NavViewIdContext.Provider value={id}>\n      <Touch\n        Component=\"section\"\n        {...restProps}\n        className={classNames(\n          styles.host,\n          platform === 'ios' && classNames(styles.ios, 'vkuiInternalView--ios'),\n          !disableAnimation && animated && styles.animated,\n          !disableAnimation && swipingBack && styles.swipingBack,\n          disableAnimation && styles.noMotion,\n          className,\n        )}\n        onMoveX={\n          iOSSwipeBackSimulationEnabled\n            ? handleTouchMoveXForIOSSwipeBackSimulation\n            : platform === 'ios'\n              ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\n              : undefined\n        }\n        onEnd={iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : undefined}\n      >\n        <div className={styles.panels}>\n          {panels.map((panel) => {\n            const panelId = getNavId(panel.props, warn);\n\n            const isPanelActive = panelId === activePanel;\n            const isPanelPrev = panelId === prevPanel;\n            const isPanelNext = panelId === nextPanel;\n            const isAnimatedTarget = animated && (isBack ? isPanelPrev : isPanelNext);\n\n            const isSwipeBackPrev = panelId === swipeBackPrevPanel;\n            const isSwipeBackNext = panelId === swipeBackNextPanel;\n            const isSwipeBackTarget = swipeBackResult && isSwipeBackPrev;\n\n            let scrollCompensateStyle: React.CSSProperties | undefined = undefined;\n\n            if (isPanelPrev || (isPanelNext && isBack) || isSwipeBackPrev || isSwipeBackNext) {\n              const marginTop = scrolls.current[panelId];\n              if (marginTop !== undefined) {\n                scrollCompensateStyle = { marginTop: -1 * marginTop };\n              }\n            }\n\n            return (\n              <div\n                className={classNames(\n                  styles.panel,\n\n                  isPanelActive && styles.panelActive,\n                  isPanelPrev && styles.panelPrev,\n                  isPanelNext && styles.panelNext,\n\n                  isSwipeBackPrev && styles.panelSwipeBackPrev,\n                  isSwipeBackNext && styles.panelSwipeBackNext,\n                  swipeBackResult === 'success' && styles.panelSwipeBackSuccess,\n                  swipeBackResult === 'fail' && styles.panelSwipeBackFailed,\n                )}\n                onTransitionEnd={isSwipeBackTarget ? handleSwipeBackTargetTransitionEnd : undefined}\n                onAnimationEnd={isAnimatedTarget ? handleAnimatedTargetAnimationEnd : undefined}\n                ref={(el) => {\n                  panelId !== undefined && (panelNodes.current[panelId] = el);\n                }}\n                style={calcPanelSwipeStyles(isSwipeBackPrev, isSwipeBackNext)}\n                key={panelId}\n              >\n                {platform === 'ios' && (\n                  <div\n                    className={styles.panelOverlay}\n                    style={calcPanelSwipeBackOverlayStyles(isSwipeBackNext)}\n                  />\n                )}\n                <div className={styles.panelIn} style={scrollCompensateStyle}>\n                  <NavTransitionDirectionProvider isBack={swipingBack || isBack}>\n                    <NavTransitionProvider\n                      entering={panelId === nextPanel || panelId === swipeBackNextPanel}\n                    >\n                      {panel}\n                    </NavTransitionProvider>\n                  </NavTransitionDirectionProvider>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </Touch>\n    </NavViewIdContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}