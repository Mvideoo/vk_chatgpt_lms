{"ast":null,"code":"import { useEffect, useRef } from \"react\";\nimport { noop } from \"@vkontakte/vkjs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback.js\";\nimport { useStateWithPrev } from \"../../hooks/useStateWithPrev.js\";\n/* istanbul ignore next: особенность рендера в браузере когда меняется className, в Jest не воспроизвести */\nconst forceReflowForFixNewMountedElement = node => void (node === null || node === void 0 ? void 0 : node.scrollTop);\n/**\n * Хук основан на компоненте `CSSTransition` из библиотеки `react-transition-group`.\n *\n * @link https://reactcommunity.org/react-transition-group/css-transition\n *\n * @private\n */\nexport const useCSSTransition = function (inProp) {\n  let {\n    enableAppear = false,\n    enableEnter = true,\n    enableExit = true,\n    onEnter: onEnterProp,\n    onEntering: onEnteringProp,\n    onEntered: onEnteredProp,\n    onExit: onExitProp,\n    onExiting: onExitingProp,\n    onExited: onExitedProp\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const onEnter = useStableCallback(onEnterProp || noop);\n  const onEntering = useStableCallback(onEnteringProp || noop);\n  const onEntered = useStableCallback(onEnteredProp || noop);\n  const onExit = useStableCallback(onExitProp || noop);\n  const onExiting = useStableCallback(onExitingProp || noop);\n  const onExited = useStableCallback(onExitedProp || noop);\n  const ref = useRef(null);\n  const [[state, prevState], setState] = useStateWithPrev(() => {\n    if (!inProp) {\n      return 'exited';\n    }\n    if (enableAppear) {\n      onEnter(true);\n      return 'appear';\n    }\n    return 'entered';\n  });\n  useEffect(function updateState() {\n    if (inProp) {\n      switch (state) {\n        case 'appear':\n          forceReflowForFixNewMountedElement(ref.current);\n          setState('appearing');\n          onEntering(true);\n          break;\n        case 'enter':\n          forceReflowForFixNewMountedElement(ref.current);\n          setState('entering');\n          onEntering();\n          break;\n        case 'exiting':\n          if (enableEnter) {\n            setState('entering');\n            onEntering();\n            break;\n          }\n          setState('entered');\n          onEntered();\n          break;\n        case 'exited':\n          if (enableEnter) {\n            setState('enter');\n            onEnter();\n            break;\n          }\n          setState('entered');\n          onEntered();\n          break;\n      }\n    } else {\n      switch (state) {\n        case 'exit':\n          forceReflowForFixNewMountedElement(ref.current);\n          setState('exiting');\n          onExiting();\n          break;\n        case 'appearing':\n        case 'entering':\n          if (enableExit) {\n            setState('exiting');\n            onExiting();\n            break;\n          }\n          setState('exited');\n          onExited();\n          break;\n        case 'appeared':\n        case 'entered':\n          if (enableExit) {\n            setState('exit');\n            onExit();\n            break;\n          }\n          setState('exited');\n          onExited();\n          break;\n      }\n    }\n  }, [inProp, state, prevState, setState, enableAppear, enableEnter, onEnter, onEntering, onEntered, enableExit, onExit, onExiting, onExited]);\n  const onTransitionEnd = event => {\n    /* istanbul ignore if: на всякий случай предупреждаем всплытие, нет смысла проверять условие */if (event.target !== ref.current) {\n      return;\n    }\n    switch (state) {\n      case 'appearing':\n        setState('appeared');\n        onEntered(event.propertyName, true);\n        break;\n      case 'entering':\n        setState('entered');\n        onEntered(event.propertyName);\n        break;\n      case 'exiting':\n        setState('exited');\n        onExited(event.propertyName);\n        break;\n    }\n  };\n  return [state, {\n    ref,\n    onTransitionEnd: state !== 'appeared' && state !== 'entered' && state !== 'exited' ? onTransitionEnd : undefined\n  }];\n};","map":{"version":3,"names":["useEffect","useRef","noop","useStableCallback","useStateWithPrev","forceReflowForFixNewMountedElement","node","scrollTop","useCSSTransition","inProp","enableAppear","enableEnter","enableExit","onEnter","onEnterProp","onEntering","onEnteringProp","onEntered","onEnteredProp","onExit","onExitProp","onExiting","onExitingProp","onExited","onExitedProp","arguments","length","undefined","ref","state","prevState","setState","updateState","current","onTransitionEnd","event","target","propertyName"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/lib/animation/useCSSTransition.ts"],"sourcesContent":["import { type TransitionEvent, type TransitionEventHandler, useEffect, useRef } from 'react';\nimport { noop } from '@vkontakte/vkjs';\nimport { useStableCallback } from '../../hooks/useStableCallback';\nimport { useStateWithPrev } from '../../hooks/useStateWithPrev';\n\n/* istanbul ignore next: особенность рендера в браузере когда меняется className, в Jest не воспроизвести */\nconst forceReflowForFixNewMountedElement = (node: Element | null) => void node?.scrollTop;\n\nexport type UseCSSTransitionState =\n  | 'appear'\n  | 'appearing'\n  | 'appeared'\n  | 'enter'\n  | 'entering'\n  | 'entered'\n  | 'exit'\n  | 'exiting'\n  | 'exited';\n\nexport type UseCSSTransitionOptions = {\n  enableAppear?: boolean;\n  enableEnter?: boolean;\n  enableExit?: boolean;\n  onEnter?: (appear?: boolean) => void;\n  onEntering?: (appear?: boolean) => void;\n  onEntered?: (propertyName?: string, appear?: boolean) => void;\n  onExit?: () => void;\n  onExiting?: () => void;\n  onExited?: (propertyName?: string) => void;\n};\n\nexport type UseCSSTransition<Ref extends Element = Element> = [\n  state: UseCSSTransitionState,\n  {\n    ref: React.RefObject<Ref | null>;\n    onTransitionEnd?: TransitionEventHandler;\n  },\n];\n\n/**\n * Хук основан на компоненте `CSSTransition` из библиотеки `react-transition-group`.\n *\n * @link https://reactcommunity.org/react-transition-group/css-transition\n *\n * @private\n */\nexport const useCSSTransition = <Ref extends Element = Element>(\n  inProp?: boolean,\n  {\n    enableAppear = false,\n    enableEnter = true,\n    enableExit = true,\n    onEnter: onEnterProp,\n    onEntering: onEnteringProp,\n    onEntered: onEnteredProp,\n    onExit: onExitProp,\n    onExiting: onExitingProp,\n    onExited: onExitedProp,\n  }: UseCSSTransitionOptions = {},\n): UseCSSTransition<Ref> => {\n  const onEnter = useStableCallback(onEnterProp || noop);\n  const onEntering = useStableCallback(onEnteringProp || noop);\n  const onEntered = useStableCallback(onEnteredProp || noop);\n  const onExit = useStableCallback(onExitProp || noop);\n  const onExiting = useStableCallback(onExitingProp || noop);\n  const onExited = useStableCallback(onExitedProp || noop);\n\n  const ref = useRef<Ref | null>(null);\n  const [[state, prevState], setState] = useStateWithPrev<UseCSSTransitionState>(() => {\n    if (!inProp) {\n      return 'exited';\n    }\n\n    if (enableAppear) {\n      onEnter(true);\n      return 'appear';\n    }\n\n    return 'entered';\n  });\n\n  useEffect(\n    function updateState() {\n      if (inProp) {\n        switch (state) {\n          case 'appear':\n            forceReflowForFixNewMountedElement(ref.current);\n            setState('appearing');\n            onEntering(true);\n            break;\n          case 'enter':\n            forceReflowForFixNewMountedElement(ref.current);\n            setState('entering');\n            onEntering();\n            break;\n          case 'exiting':\n            if (enableEnter) {\n              setState('entering');\n              onEntering();\n              break;\n            }\n\n            setState('entered');\n            onEntered();\n            break;\n          case 'exited':\n            if (enableEnter) {\n              setState('enter');\n              onEnter();\n              break;\n            }\n\n            setState('entered');\n            onEntered();\n            break;\n        }\n      } else {\n        switch (state) {\n          case 'exit':\n            forceReflowForFixNewMountedElement(ref.current);\n            setState('exiting');\n            onExiting();\n            break;\n          case 'appearing':\n          case 'entering':\n            if (enableExit) {\n              setState('exiting');\n              onExiting();\n              break;\n            }\n\n            setState('exited');\n            onExited();\n            break;\n          case 'appeared':\n          case 'entered':\n            if (enableExit) {\n              setState('exit');\n              onExit();\n              break;\n            }\n\n            setState('exited');\n            onExited();\n            break;\n        }\n      }\n    },\n    [\n      inProp,\n\n      state,\n      prevState,\n      setState,\n\n      enableAppear,\n      enableEnter,\n      onEnter,\n      onEntering,\n      onEntered,\n\n      enableExit,\n      onExit,\n      onExiting,\n      onExited,\n    ],\n  );\n\n  const onTransitionEnd = (event: TransitionEvent) => {\n    /* istanbul ignore if: на всякий случай предупреждаем всплытие, нет смысла проверять условие */\n    if (event.target !== ref.current) {\n      return;\n    }\n\n    switch (state) {\n      case 'appearing':\n        setState('appeared');\n        onEntered(event.propertyName, true);\n        break;\n      case 'entering':\n        setState('entered');\n        onEntered(event.propertyName);\n        break;\n      case 'exiting':\n        setState('exited');\n        onExited(event.propertyName);\n        break;\n    }\n  };\n\n  return [\n    state,\n    {\n      ref,\n      onTransitionEnd:\n        state !== 'appeared' && state !== 'entered' && state !== 'exited'\n          ? onTransitionEnd\n          : undefined,\n    },\n  ];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}