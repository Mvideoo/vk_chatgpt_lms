{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames, hasMouse as hasPointerLib, noop } from \"@vkontakte/vkjs\";\nimport { usePlatform } from \"../../hooks/usePlatform.js\";\nimport { getOffsetRect } from \"../../lib/offset.js\";\n/**\n * Возможно нужен Ripple эффект. Данный хук нужен для отказа\n * от двойного ререндера.\n */\nexport const useMaybeNeedRipple = (activeMode, hasPointer) => {\n  const platform = usePlatform();\n  return platform === 'android' && !hasPointer && activeMode === 'background';\n};\nconst DELAY = 70;\nconst WAVE_LIVE = 225;\n/**\n * Хук для создания Ripple эффектов\n */\nexport const useRipple = (needRipple, hasPointerContext) => {\n  const [clicks, setClicks] = React.useState([]);\n  /**\n  * Коллекция нажатий и таймеров задержки появления волны\n  */\n  const pointerDelayTimers = React.useMemo(() => new Map(), []);\n  React.useEffect(function setClearClicksTimeout() {\n    const clicksTimeoutId = clicks.length > 0 ? setTimeout(() => setClicks([]), WAVE_LIVE) : null;\n    return function cancelClearClicksTimeout() {\n      if (clicksTimeoutId) {\n        clearTimeout(clicksTimeoutId);\n      }\n    };\n  }, [clicks]);\n  function addClick(x, y, pointerId) {\n    const dateNow = Date.now();\n    const filteredClicks = clicks.filter(click => click.id + WAVE_LIVE > dateNow);\n    setClicks([...filteredClicks, {\n      x,\n      y,\n      id: dateNow,\n      pointerId\n    }]);\n    pointerDelayTimers.delete(pointerId);\n  }\n  /**\n  * Добавляем волну с задержкой. Задержка необходима при отмене волны.\n  */\n  const onPointerDown = e => {\n    const {\n      top,\n      left\n    } = getOffsetRect(e.currentTarget);\n    const x = e.clientX - (left !== null && left !== void 0 ? left : 0);\n    const y = e.clientY - (top !== null && top !== void 0 ? top : 0);\n    pointerDelayTimers.set(e.pointerId, setTimeout(() => addClick(x, y, e.pointerId), DELAY));\n  };\n  const onPointerCancel = e => {\n    const timer = pointerDelayTimers.get(e.pointerId);\n    clearTimeout(timer);\n    pointerDelayTimers.delete(e.pointerId);\n  };\n  // WARNING: не использовать для рендеринга\n  const reallyNeedRipple = (!hasPointerLib || hasPointerContext === false) && needRipple;\n  return {\n    clicks,\n    onPointerDown: reallyNeedRipple ? onPointerDown : noop,\n    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop\n  };\n};\nexport const Ripple = _ref => {\n  let {\n    needRipple = true,\n    clicks\n  } = _ref;\n  return /*#__PURE__*/_jsx(\"span\", {\n    \"aria-hidden\": true,\n    className: classNames(\"vkuiTappable__stateLayer\", needRipple && \"vkuiTappable__ripple\"),\n    children: clicks.map(wave => /*#__PURE__*/_jsx(\"span\", {\n      className: \"vkuiTappable__wave\",\n      style: {\n        top: wave.y,\n        left: wave.x\n      }\n    }, wave.id))\n  });\n};","map":{"version":3,"names":["React","classNames","hasMouse","hasPointerLib","noop","usePlatform","getOffsetRect","useMaybeNeedRipple","activeMode","hasPointer","platform","DELAY","WAVE_LIVE","useRipple","needRipple","hasPointerContext","clicks","setClicks","useState","pointerDelayTimers","useMemo","Map","useEffect","setClearClicksTimeout","clicksTimeoutId","length","setTimeout","cancelClearClicksTimeout","clearTimeout","addClick","x","y","pointerId","dateNow","Date","now","filteredClicks","filter","click","id","delete","onPointerDown","e","top","left","currentTarget","clientX","clientY","set","onPointerCancel","timer","get","reallyNeedRipple","Ripple","_ref","_jsx","className","map","wave","style"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/Tappable/Ripple.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, hasMouse as hasPointerLib, noop } from '@vkontakte/vkjs';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { getOffsetRect } from '../../lib/offset';\nimport styles from './Tappable.module.css';\n\n/**\n * Возможно нужен Ripple эффект. Данный хук нужен для отказа\n * от двойного ререндера.\n */\nexport const useMaybeNeedRipple = (\n  activeMode: string,\n  hasPointer: boolean | undefined,\n): boolean => {\n  const platform = usePlatform();\n\n  return platform === 'android' && !hasPointer && activeMode === 'background';\n};\n\ninterface Wave {\n  x: number;\n  y: number;\n  id: number;\n  pointerId: number;\n}\n\nconst DELAY = 70;\nconst WAVE_LIVE = 225;\n\n/**\n * Хук для создания Ripple эффектов\n */\nexport const useRipple = (\n  needRipple: boolean,\n  hasPointerContext: boolean | undefined,\n): {\n  clicks: Wave[];\n  onPointerDown: React.PointerEventHandler<HTMLSpanElement>;\n  onPointerCancel: React.PointerEventHandler<HTMLSpanElement>;\n} => {\n  const [clicks, setClicks] = React.useState<Wave[]>([]);\n\n  /**\n   * Коллекция нажатий и таймеров задержки появления волны\n   */\n  const pointerDelayTimers = React.useMemo(\n    () => new Map<number, ReturnType<typeof setTimeout>>(),\n    [],\n  );\n\n  React.useEffect(\n    function setClearClicksTimeout() {\n      const clicksTimeoutId = clicks.length > 0 ? setTimeout(() => setClicks([]), WAVE_LIVE) : null;\n      return function cancelClearClicksTimeout() {\n        if (clicksTimeoutId) {\n          clearTimeout(clicksTimeoutId);\n        }\n      };\n    },\n    [clicks],\n  );\n\n  function addClick(x: number, y: number, pointerId: number) {\n    const dateNow = Date.now();\n    const filteredClicks = clicks.filter((click) => click.id + WAVE_LIVE > dateNow);\n\n    setClicks([...filteredClicks, { x, y, id: dateNow, pointerId }]);\n    pointerDelayTimers.delete(pointerId);\n  }\n\n  /**\n   * Добавляем волну с задержкой. Задержка необходима при отмене волны.\n   */\n  const onPointerDown: React.PointerEventHandler<HTMLSpanElement> = (e) => {\n    const { top, left } = getOffsetRect(e.currentTarget);\n    const x = e.clientX - (left ?? 0);\n    const y = e.clientY - (top ?? 0);\n\n    pointerDelayTimers.set(\n      e.pointerId,\n      setTimeout(() => addClick(x, y, e.pointerId), DELAY),\n    );\n  };\n\n  const onPointerCancel: React.PointerEventHandler<HTMLSpanElement> = (e) => {\n    const timer = pointerDelayTimers.get(e.pointerId);\n    clearTimeout(timer);\n    pointerDelayTimers.delete(e.pointerId);\n  };\n\n  // WARNING: не использовать для рендеринга\n  const reallyNeedRipple = (!hasPointerLib || hasPointerContext === false) && needRipple;\n\n  return {\n    clicks,\n    onPointerDown: reallyNeedRipple ? onPointerDown : noop,\n    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop,\n  };\n};\n\nexport interface RippleProps {\n  needRipple: boolean;\n  clicks: Wave[];\n}\n\nexport const Ripple = ({ needRipple = true, clicks }: RippleProps): React.ReactNode => {\n  return (\n    <span aria-hidden className={classNames(styles.stateLayer, needRipple && styles.ripple)}>\n      {clicks.map((wave) => (\n        <span key={wave.id} className={styles.wave} style={{ top: wave.y, left: wave.x }} />\n      ))}\n    </span>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}