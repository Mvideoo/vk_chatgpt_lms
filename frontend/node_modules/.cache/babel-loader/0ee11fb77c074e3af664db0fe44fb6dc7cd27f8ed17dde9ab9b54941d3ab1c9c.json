{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames, noop } from \"@vkontakte/vkjs\";\nimport { useAdaptivityHasPointer } from \"../../hooks/useAdaptivityHasPointer.js\";\nimport { useConfigDirection } from \"../../hooks/useConfigDirection.js\";\nimport { useExternRef } from \"../../hooks/useExternRef.js\";\nimport { easeInOutSine } from \"../../lib/fx.js\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect.js\";\nimport { RootComponent } from \"../RootComponent/RootComponent.js\";\nimport { ScrollArrow } from \"../ScrollArrow/ScrollArrow.js\";\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n/**\n * Округление к большему по модулю\n *\n * ## Пример\n *\n * ```ts\n * import { strict as assert } from 'node:assert';\n *\n * assert.equal(roundingAwayFromZero(5.1), 6)\n * assert.equal(roundingAwayFromZero(-5.1), -6)\n * ```\n */\nfunction roundingAwayFromZero(value) {\n  return value > 0 ? Math.ceil(value) : Math.floor(value);\n}\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nconst roundUpElementScrollLeft = el => roundingAwayFromZero(el.scrollLeft);\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\nfunction doScroll(_ref) {\n  let {\n    scrollElement,\n    getScrollPosition,\n    animationQueue,\n    onScrollToEndBorder,\n    onScrollEnd,\n    onScrollStart,\n    initialScrollWidth,\n    scrollAnimationDuration,\n    textDirection\n  } = _ref;\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n  /**\n  * крайнее значение сдвига\n  */\n  const extremeScrollLeft = (textDirection === 'ltr' ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);\n  const startScrollLeft = roundUpElementScrollLeft(scrollElement);\n  const remappedStartScrollLeft = startScrollLeft * (textDirection === 'rtl' ? -1 : 1);\n  let endScrollLeft = getScrollPosition(remappedStartScrollLeft);\n  const diff = endScrollLeft - remappedStartScrollLeft;\n  if (textDirection === 'rtl') {\n    endScrollLeft = startScrollLeft - diff;\n  }\n  onScrollStart();\n  /**\n  * Если окончание прокрутки вышло за ноль\n  */\n  if (startScrollLeft * endScrollLeft < 0) {\n    endScrollLeft = 0;\n  }\n  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {\n    onScrollToEndBorder();\n    endScrollLeft = extremeScrollLeft;\n  }\n  const startTime = now();\n  (function scroll() {\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    const value = easeInOutSine(elapsed);\n    const currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;\n    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);\n    const scrollEnd = textDirection === 'ltr' ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);\n    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport const HorizontalScroll = _param => {\n  var {\n      children,\n      getScrollToLeft,\n      getScrollToRight,\n      showArrows = true,\n      arrowSize = 'm',\n      arrowOffsetY,\n      scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n      getRef,\n      scrollOnAnyWheel = false,\n      prevButtonTestId,\n      nextButtonTestId,\n      // ContentWrapper\n      ContentWrapperComponent = 'div',\n      contentWrapperRef,\n      contentWrapperClassName\n    } = _param,\n    restProps = _object_without_properties(_param, [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"arrowSize\", \"arrowOffsetY\", \"scrollAnimationDuration\", \"getRef\", \"scrollOnAnyWheel\", \"prevButtonTestId\", \"nextButtonTestId\", \"ContentWrapperComponent\", \"contentWrapperRef\", \"contentWrapperClassName\"]);\n  const [canScrollStart, setCanScrollStart] = React.useState(false);\n  const [canScrollEnd, setCanScrollEnd] = React.useState(false);\n  const direction = useConfigDirection();\n  const isRtl = direction === 'rtl';\n  const isCustomScrollingRef = React.useRef(false);\n  const scrollerRef = useExternRef(getRef);\n  const animationQueue = React.useRef([]);\n  const hasPointer = useAdaptivityHasPointer();\n  const scrollTo = React.useCallback(getScrollPosition => {\n    const scrollElement = scrollerRef.current;\n    animationQueue.current.push(() => {\n      var _scrollElement_firstElementChild;\n      return doScroll({\n        scrollElement,\n        getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToEndBorder: () => setCanScrollEnd(false),\n        onScrollEnd: () => isCustomScrollingRef.current = false,\n        onScrollStart: () => isCustomScrollingRef.current = true,\n        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement_firstElementChild = scrollElement.firstElementChild) === null || _scrollElement_firstElementChild === void 0 ? void 0 : _scrollElement_firstElementChild.scrollWidth) || 0,\n        scrollAnimationDuration,\n        textDirection: direction\n      });\n    });\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }, [scrollerRef, scrollAnimationDuration, direction, setCanScrollEnd]);\n  const scrollToStart = React.useCallback(() => {\n    const getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : i => i - scrollerRef.current.offsetWidth;\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n  const scrollToEnd = React.useCallback(() => {\n    const getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : i => i + scrollerRef.current.offsetWidth;\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n  const calculateArrowsVisibility = React.useCallback(() => {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n      const scrollLeft = scrollElement.scrollLeft;\n      setCanScrollStart(isRtl ? scrollLeft < 0 : scrollLeft > 0);\n      setCanScrollEnd(Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [showArrows, hasPointer, scrollerRef, isRtl]);\n  React.useEffect(calculateArrowsVisibility, [calculateArrowsVisibility, children]);\n  useIsomorphicLayoutEffect(function addWheelEventHandler() {\n    const scrollEl = scrollerRef.current;\n    if (!scrollEl) {\n      return noop;\n    }\n    /**\n    * Прокрутка с помощью любого колеса мыши\n    */\n    const onWheel = e => {\n      scrollerRef.current.scrollBy({\n        left: e.deltaX + e.deltaY,\n        behavior: 'auto'\n      });\n      e.preventDefault();\n    };\n    const listenerOptions = {\n      passive: false\n    };\n    if (scrollOnAnyWheel) {\n      scrollEl.addEventListener('wheel', onWheel, listenerOptions);\n    }\n    scrollEl.addEventListener('scroll', calculateArrowsVisibility, listenerOptions);\n    return () => {\n      if (scrollOnAnyWheel) {\n        // @ts-expect-error: TS2769 В интерфейсе EventListenerOptions для wheel нет passive свойства\n        scrollEl.removeEventListener('wheel', onWheel, listenerOptions);\n      }\n      // @ts-expect-error: TS2769 В интерфейсе EventListenerOptions для scroll нет passive свойства\n      scrollEl.removeEventListener('scroll', calculateArrowsVisibility, listenerOptions);\n    };\n  }, [scrollOnAnyWheel, calculateArrowsVisibility, scrollerRef]);\n  return /*#__PURE__*/_jsxs(RootComponent, _object_spread_props(_object_spread({}, restProps), {\n    baseClassName: classNames(\"vkuiHorizontalScroll__host\", 'vkuiInternalHorizontalScroll', showArrows === 'always' && \"vkuiHorizontalScroll__withConstArrows\", isRtl && \"vkuiHorizontalScroll__rtl\"),\n    onMouseEnter: calculateArrowsVisibility,\n    children: [showArrows && (hasPointer || hasPointer === undefined) && canScrollStart && /*#__PURE__*/_jsx(ScrollArrow, {\n      \"data-testid\": prevButtonTestId,\n      size: arrowSize,\n      offsetY: arrowOffsetY,\n      direction: \"left\",\n      \"aria-hidden\": true,\n      tabIndex: -1,\n      className: classNames(\"vkuiHorizontalScroll__arrow\", \"vkuiHorizontalScroll__arrowLeft\"),\n      onClick: scrollToStart\n    }), showArrows && (hasPointer || hasPointer === undefined) && canScrollEnd && /*#__PURE__*/_jsx(ScrollArrow, {\n      \"data-testid\": nextButtonTestId,\n      size: arrowSize,\n      offsetY: arrowOffsetY,\n      direction: \"right\",\n      \"aria-hidden\": true,\n      tabIndex: -1,\n      className: classNames(\"vkuiHorizontalScroll__arrow\", \"vkuiHorizontalScroll__arrowRight\"),\n      onClick: scrollToEnd\n    }), /*#__PURE__*/_jsx(\"div\", {\n      className: \"vkuiHorizontalScroll__in\",\n      ref: scrollerRef,\n      children: /*#__PURE__*/_jsx(ContentWrapperComponent, {\n        className: classNames(\"vkuiHorizontalScroll__inWrapper\", contentWrapperClassName),\n        ref: contentWrapperRef,\n        children: children\n      })\n    })]\n  }));\n};","map":{"version":3,"names":["React","classNames","noop","useAdaptivityHasPointer","useConfigDirection","useExternRef","easeInOutSine","useIsomorphicLayoutEffect","RootComponent","ScrollArrow","now","performance","Date","roundingAwayFromZero","value","Math","ceil","floor","roundUpElementScrollLeft","el","scrollLeft","SCROLL_ONE_FRAME_TIME","doScroll","_ref","scrollElement","getScrollPosition","animationQueue","onScrollToEndBorder","onScrollEnd","onScrollStart","initialScrollWidth","scrollAnimationDuration","textDirection","extremeScrollLeft","offsetWidth","startScrollLeft","remappedStartScrollLeft","endScrollLeft","diff","abs","startTime","scroll","time","elapsed","min","currentScrollLeft","scrollEnd","max","requestAnimationFrame","shift","length","HorizontalScroll","_param","children","getScrollToLeft","getScrollToRight","showArrows","arrowSize","arrowOffsetY","getRef","scrollOnAnyWheel","prevButtonTestId","nextButtonTestId","ContentWrapperComponent","contentWrapperRef","contentWrapperClassName","restProps","_object_without_properties","canScrollStart","setCanScrollStart","useState","canScrollEnd","setCanScrollEnd","direction","isRtl","isCustomScrollingRef","useRef","scrollerRef","hasPointer","scrollTo","useCallback","current","push","_scrollElement_firstElementChild","firstElementChild","scrollWidth","scrollToStart","i","scrollToEnd","calculateArrowsVisibility","useEffect","addWheelEventHandler","scrollEl","onWheel","e","scrollBy","left","deltaX","deltaY","behavior","preventDefault","listenerOptions","passive","addEventListener","removeEventListener","_jsxs","_object_spread_props","_object_spread","baseClassName","onMouseEnter","undefined","_jsx","size","offsetY","tabIndex","className","onClick","ref"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/HorizontalScroll/HorizontalScroll.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { useConfigDirection } from '../../hooks/useConfigDirection';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { easeInOutSine } from '../../lib/fx';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport type { HasRef, HTMLAttributesWithRootRef } from '../../types';\nimport { RootComponent } from '../RootComponent/RootComponent';\nimport { ScrollArrow, type ScrollArrowProps } from '../ScrollArrow/ScrollArrow';\nimport styles from './HorizontalScroll.module.css';\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToEndBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n  textDirection: 'ltr' | 'rtl';\n}\n\nexport type ScrollPositionHandler = (currentPosition: number) => number;\n\nexport interface HorizontalScrollProps\n  extends HTMLAttributesWithRootRef<HTMLDivElement>,\n    HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: ScrollPositionHandler;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: ScrollPositionHandler;\n  arrowSize?: ScrollArrowProps['size'];\n  /**\n   * Смещает иконки кнопок навигации по вертикали.\n   */\n  arrowOffsetY?: number | string;\n  showArrows?: boolean | 'always';\n  scrollAnimationDuration?: number;\n  /**\n   * Добавляет возможность прокручивать контент на любое колесо мыши.\n   * По умолчанию прокручивается как любой горизонтальный контент через shift.\n   */\n  scrollOnAnyWheel?: boolean;\n  /**\n   * Передает атрибут `data-testid` для кнопки прокрутки горизонтального скролла в направлении предыдущего элемента\n   */\n  prevButtonTestId?: string;\n  /**\n   * Передает атрибут `data-testid` для кнопки прокрутки горизонтального скролла в направлении следующего элемента\n   */\n  nextButtonTestId?: string;\n  /**\n   * Позволяет поменять тег используемый для обертки над контентом, прокинутым в `children`\n   */\n  ContentWrapperComponent?: React.ElementType;\n  /**\n   * `ref` для обертки над контентом, прокинутым в `children`\n   */\n  contentWrapperRef?: React.Ref<HTMLElement>;\n  /**\n   * Специфичный `className` для обертки над контентом, прокинутым в `children`\n   */\n  contentWrapperClassName?: string;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Округление к большему по модулю\n *\n * ## Пример\n *\n * ```ts\n * import { strict as assert } from 'node:assert';\n *\n * assert.equal(roundingAwayFromZero(5.1), 6)\n * assert.equal(roundingAwayFromZero(-5.1), -6)\n * ```\n */\nfunction roundingAwayFromZero(value: number): number {\n  return value > 0 ? Math.ceil(value) : Math.floor(value);\n}\n\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nconst roundUpElementScrollLeft = (el: HTMLElement) => roundingAwayFromZero(el.scrollLeft);\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToEndBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration,\n  textDirection,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * крайнее значение сдвига\n   */\n  const extremeScrollLeft =\n    (textDirection === 'ltr' ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);\n\n  const startScrollLeft = roundUpElementScrollLeft(scrollElement);\n  const remappedStartScrollLeft = startScrollLeft * (textDirection === 'rtl' ? -1 : 1);\n\n  let endScrollLeft = getScrollPosition(remappedStartScrollLeft);\n\n  const diff = endScrollLeft - remappedStartScrollLeft;\n  if (textDirection === 'rtl') {\n    endScrollLeft = startScrollLeft - diff;\n  }\n\n  onScrollStart();\n\n  /**\n   * Если окончание прокрутки вышло за ноль\n   */\n  if (startScrollLeft * endScrollLeft < 0) {\n    endScrollLeft = 0;\n  }\n\n  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {\n    onScrollToEndBorder();\n    endScrollLeft = extremeScrollLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;\n    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);\n\n    const scrollEnd =\n      textDirection === 'ltr' ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);\n    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport const HorizontalScroll = ({\n  children,\n  getScrollToLeft,\n  getScrollToRight,\n  showArrows = true,\n  arrowSize = 'm',\n  arrowOffsetY,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  getRef,\n  scrollOnAnyWheel = false,\n  prevButtonTestId,\n  nextButtonTestId,\n  // ContentWrapper\n  ContentWrapperComponent = 'div',\n  contentWrapperRef,\n  contentWrapperClassName,\n  ...restProps\n}: HorizontalScrollProps): React.ReactNode => {\n  const [canScrollStart, setCanScrollStart] = React.useState(false);\n  const [canScrollEnd, setCanScrollEnd] = React.useState(false);\n  const direction = useConfigDirection();\n  const isRtl = direction === 'rtl';\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  const hasPointer = useAdaptivityHasPointer();\n\n  const scrollTo = React.useCallback(\n    (getScrollPosition: ScrollPositionHandler) => {\n      const scrollElement = scrollerRef.current;\n\n      animationQueue.current.push(() =>\n        doScroll({\n          scrollElement,\n          getScrollPosition,\n          animationQueue: animationQueue.current,\n          onScrollToEndBorder: () => setCanScrollEnd(false),\n          onScrollEnd: () => (isCustomScrollingRef.current = false),\n          onScrollStart: () => (isCustomScrollingRef.current = true),\n          initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n          scrollAnimationDuration,\n          textDirection: direction,\n        }),\n      );\n      if (animationQueue.current.length === 1) {\n        animationQueue.current[0]();\n      }\n    },\n    [scrollerRef, scrollAnimationDuration, direction, setCanScrollEnd],\n  );\n\n  const scrollToStart = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToLeft ?? ((i: number) => i - scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n\n  const scrollToEnd = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToRight ?? ((i: number) => i + scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n\n  const calculateArrowsVisibility = React.useCallback(() => {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n      const scrollLeft = scrollElement.scrollLeft;\n\n      setCanScrollStart(isRtl ? scrollLeft < 0 : scrollLeft > 0);\n      setCanScrollEnd(\n        Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth <\n          scrollElement.scrollWidth,\n      );\n    }\n  }, [showArrows, hasPointer, scrollerRef, isRtl]);\n\n  React.useEffect(calculateArrowsVisibility, [calculateArrowsVisibility, children]);\n\n  useIsomorphicLayoutEffect(\n    function addWheelEventHandler() {\n      const scrollEl = scrollerRef.current;\n      if (!scrollEl) {\n        return noop;\n      }\n      /**\n       * Прокрутка с помощью любого колеса мыши\n       */\n      const onWheel = (e: WheelEvent) => {\n        scrollerRef.current!.scrollBy({ left: e.deltaX + e.deltaY, behavior: 'auto' });\n        e.preventDefault();\n      };\n\n      const listenerOptions = { passive: false };\n\n      if (scrollOnAnyWheel) {\n        scrollEl.addEventListener('wheel', onWheel, listenerOptions);\n      }\n      scrollEl.addEventListener('scroll', calculateArrowsVisibility, listenerOptions);\n\n      return () => {\n        if (scrollOnAnyWheel) {\n          // @ts-expect-error: TS2769 В интерфейсе EventListenerOptions для wheel нет passive свойства\n          scrollEl.removeEventListener('wheel', onWheel, listenerOptions);\n        }\n        // @ts-expect-error: TS2769 В интерфейсе EventListenerOptions для scroll нет passive свойства\n        scrollEl.removeEventListener('scroll', calculateArrowsVisibility, listenerOptions);\n      };\n    },\n    [scrollOnAnyWheel, calculateArrowsVisibility, scrollerRef],\n  );\n\n  return (\n    <RootComponent\n      {...restProps}\n      baseClassName={classNames(\n        styles.host,\n        'vkuiInternalHorizontalScroll',\n        showArrows === 'always' && styles.withConstArrows,\n        isRtl && styles.rtl,\n      )}\n      onMouseEnter={calculateArrowsVisibility}\n    >\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollStart && (\n        <ScrollArrow\n          data-testid={prevButtonTestId}\n          size={arrowSize}\n          offsetY={arrowOffsetY}\n          direction=\"left\"\n          aria-hidden\n          tabIndex={-1}\n          className={classNames(styles.arrow, styles.arrowLeft)}\n          onClick={scrollToStart}\n        />\n      )}\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollEnd && (\n        <ScrollArrow\n          data-testid={nextButtonTestId}\n          size={arrowSize}\n          offsetY={arrowOffsetY}\n          direction=\"right\"\n          aria-hidden\n          tabIndex={-1}\n          className={classNames(styles.arrow, styles.arrowRight)}\n          onClick={scrollToEnd}\n        />\n      )}\n      <div className={styles.in} ref={scrollerRef}>\n        <ContentWrapperComponent\n          className={classNames(styles.inWrapper, contentWrapperClassName)}\n          ref={contentWrapperRef}\n        >\n          {children}\n        </ContentWrapperComponent>\n      </div>\n    </RootComponent>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}