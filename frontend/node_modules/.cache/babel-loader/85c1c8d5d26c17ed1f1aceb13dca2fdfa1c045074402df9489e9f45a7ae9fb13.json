{"ast":null,"code":"import { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { noop } from \"@vkontakte/vkjs\";\nimport { clamp } from \"../../../helpers/math.js\";\nimport { rubberbandIfOutOfBounds } from \"../../animation/index.js\";\nimport { getNearestOverflowAncestor, hasSelectionWithRangeType } from \"../../dom.js\";\nimport { UIPanGestureRecognizer } from \"../../touch/UIPanGestureRecognizer.js\";\nimport { BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY, DRAG_THRESHOLDS, DYNAMIC_SNAP_POINT_DATA, SNAP_POINT_DETENTS } from \"../constants.js\";\nexport class BottomSheetController {\n  init(snapPoint) {\n    this.isInitialized = true;\n    if (snapPoint === 'auto') {\n      this.unit = 'px';\n      this.currentSnapPoint = DYNAMIC_SNAP_POINT_DATA.IDLE_POINT_VALUE;\n      this.snapPointDetents = [SNAP_POINT_DETENTS.MIN, DYNAMIC_SNAP_POINT_DATA.IDLE_POINT_VALUE];\n    } else {\n      this.unit = '%';\n      this.currentSnapPoint = snapPoint.initial;\n      this.snapPointDetents = snapPoint.detents;\n    }\n  }\n  destroy() {\n    var _this_backdropTransitionController;\n    this.isInitialized = false;\n    this.pannedEl = null;\n    this.sheetTransitionController.cleanup();\n    (_this_backdropTransitionController = this.backdropTransitionController) === null || _this_backdropTransitionController === void 0 ? void 0 : _this_backdropTransitionController.cleanup();\n    this.disableVerticalScrollBouncingDispose();\n    this.disableVerticalScrollBouncingDispose = noop;\n  }\n  panStart(event) {\n    if (!this.isInitialized || this.panState !== 'idle' || hasSelectionWithRangeType(event.target)) {\n      return;\n    }\n    this.panState = 'start';\n    this.pannedEl = event.target;\n    this.panGestureRecognizer.setStartCoords(event);\n  }\n  panMove(event) {\n    switch (this.panState) {\n      case 'start':\n        this.panGestureRecognizer.setInitialTimeOnce();\n        this.panGestureRecognizer.setEndCoords(event);\n        if (this.preventUntilPanGestureBecomesExpected()) {\n          return;\n        }\n        if (this.preventImmediatelyIfPannedElIsNotValid()) {\n          this.panState = 'idle';\n          return;\n        }\n        if (this.preventUntilVerticalScrollingOnSheetScrollElBecomesExpected()) {\n          return;\n        }\n        if (this.preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled()) {\n          this.panState = 'idle';\n          return;\n        }\n        this.panState = 'moving';\n        this.panGestureRecognizer.setStartCoords(event);\n        this.sheetHeight = this.sheetEl.offsetHeight;\n        this.disableVerticalScrollBouncingDispose = BottomSheetController.disableVerticalScrollBouncingIfNeeded(this.sheetScrollEl, this.pannedEl);\n        if (this.isDynamicSnapPoint) {\n          this.currentSnapPoint = this.sheetHeight;\n          this.snapPointDetents[DYNAMIC_SNAP_POINT_DATA.COMPUTED_INDEX] = this.sheetHeight;\n        }\n        break;\n      case 'moving':\n        this.panGestureRecognizer.setEndCoords(event);\n        const {\n          y1,\n          y2\n        } = this.panGestureRecognizer;\n        this.nextSnapPoint = rubberbandIfOutOfBounds(this.currentSnapPoint - (y2 - y1) / this.sheetHeight * this.currentSnapPoint, SNAP_POINT_DETENTS.MIN, this.isDynamicSnapPoint ? this.sheetHeight : SNAP_POINT_DETENTS.LARGE);\n        this.calculateSnapPoint(this.nextSnapPoint, true);\n        break;\n    }\n  }\n  panEnd() {\n    switch (this.panState) {\n      case 'moving':\n        const prevCurrentSnapPoint = this.currentSnapPoint;\n        this.currentSnapPoint = this.getSnapPointTo(this.nextSnapPoint);\n        if (prevCurrentSnapPoint !== this.currentSnapPoint && this.currentSnapPoint > SNAP_POINT_DETENTS.MIN) {\n          this.onSnapPointChange(this.currentSnapPoint);\n        }\n        this.calculateSnapPoint(this.currentSnapPoint);\n        break;\n    }\n    this.panState = 'idle';\n    this.panGestureRecognizer.reset();\n    this.disableVerticalScrollBouncingDispose();\n    this.disableVerticalScrollBouncingDispose = noop;\n  }\n  get isDynamicSnapPoint() {\n    return this.unit === 'px';\n  }\n  calculateSnapPoint(nextSnapPoint) {\n    let immediately = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    if (nextSnapPoint <= SNAP_POINT_DETENTS.MIN) {\n      var _this_backdropTransitionController;\n      this.sheetTransitionController.enableTransition();\n      (_this_backdropTransitionController = this.backdropTransitionController) === null || _this_backdropTransitionController === void 0 ? void 0 : _this_backdropTransitionController.enableTransition();\n      this.panState = 'idle';\n      this.onDismiss();\n      return;\n    }\n    const backdropOpacity = clamp(this.isDynamicSnapPoint ? nextSnapPoint / this.sheetHeight : nextSnapPoint * 2 / SNAP_POINT_DETENTS.LARGE, 0, 1);\n    this.rafId = requestAnimationFrame(() => {\n      var _this_backdropTransitionController;\n      if (immediately) {\n        var _this_backdropTransitionController1;\n        (_this_backdropTransitionController1 = this.backdropTransitionController) === null || _this_backdropTransitionController1 === void 0 ? void 0 : _this_backdropTransitionController1.disableTransition().set(backdropOpacity);\n        this.sheetTransitionController.disableTransition().set(`${nextSnapPoint}${this.unit}`);\n        return;\n      }\n      if (this.isDynamicSnapPoint) {\n        this.sheetTransitionController.cleanupOnTransitionEnd();\n      }\n      (_this_backdropTransitionController = this.backdropTransitionController) === null || _this_backdropTransitionController === void 0 ? void 0 : _this_backdropTransitionController.unset();\n      this.sheetTransitionController.enableTransition().set(`${this.currentSnapPoint}${this.unit}`);\n    });\n  }\n  getSnapPointTo(nextSnapPoint) {\n    const closestSnapPoint = BottomSheetController.getClosestSnapPoint(this.snapPointDetents, nextSnapPoint);\n    if (closestSnapPoint !== this.currentSnapPoint) {\n      return closestSnapPoint;\n    }\n    const panDirection = this.panGestureRecognizer.direction();\n    if (panDirection.axis !== 'y' || panDirection.direction === null) {\n      return this.currentSnapPoint;\n    }\n    const velocity = this.panGestureRecognizer.velocity();\n    if (Math.abs(velocity.y) < DRAG_THRESHOLDS.VELOCITY) {\n      return this.currentSnapPoint;\n    }\n    const closestSnapPointByDirection = BottomSheetController.getClosestSnapPointByDirection(this.snapPointDetents, closestSnapPoint, panDirection.direction);\n    return closestSnapPointByDirection;\n  }\n  preventUntilPanGestureBecomesExpected() {\n    return this.panGestureRecognizer.direction().axis === 'x' || this.panGestureRecognizer.distance() < DRAG_THRESHOLDS.DISTANCE_FOR_MOVING_START;\n  }\n  preventImmediatelyIfPannedElIsNotValid() {\n    return this.pannedEl === null ||\n    // Элемент со специальным атрибутом\n    this.pannedEl.closest(`[${BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY}=true]`) !== null ||\n    // eslint-disable-line no-restricted-properties\n    // Элемент за пределами панели.\n    !this.sheetEl.contains(this.pannedEl);\n  }\n  preventUntilVerticalScrollingOnSheetScrollElBecomesExpected() {\n    if (this.sheetScrollEl === null || !this.sheetScrollEl.contains(this.pannedEl) || this.sheetScrollEl.scrollHeight <= this.sheetScrollEl.clientHeight) {\n      return false;\n    }\n    if (this.sheetScrollEl.scrollTop === 0) {\n      return this.panGestureRecognizer.direction().direction === -1 && BottomSheetController.isLastSnapPointDetents(this.snapPointDetents, this.currentSnapPoint);\n    }\n    return true;\n  }\n  preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled() {\n    if (/* istanbul ignore next: покрываем TypeScript */this.pannedEl === null || this.pannedEl === this.sheetEl || this.pannedEl === this.sheetScrollEl) {\n      return false;\n    }\n    const overflowAncestor = getNearestOverflowAncestor(this.pannedEl, this.sheetEl);\n    if (overflowAncestor === null || this.sheetScrollEl === overflowAncestor || overflowAncestor.scrollHeight <= overflowAncestor.clientHeight) {\n      return false;\n    }\n    return overflowAncestor.scrollTop !== 0 || this.panGestureRecognizer.direction().direction === -1;\n  }\n  static disableVerticalScrollBouncingIfNeeded(sheetScrollEl, targetEl) {\n    if (sheetScrollEl !== null && sheetScrollEl.scrollTop <= 0 && sheetScrollEl.contains(targetEl) && sheetScrollEl.scrollHeight > sheetScrollEl.clientHeight) {\n      sheetScrollEl.style.setProperty('overflow-y', 'hidden');\n      return function dispose() {\n        sheetScrollEl.style.removeProperty('overflow-y');\n      };\n    }\n    return noop;\n  }\n  static isLastSnapPointDetents(snapPointDetents, currentY) {\n    return currentY === snapPointDetents[snapPointDetents.length - 1];\n  }\n  static getClosestSnapPointByDirection(snapPointDetents, currentY, direction) {\n    const foundIndex = snapPointDetents.findIndex(i => i === currentY);\n    switch (direction) {\n      case -1:\n        var _snapPointDetents_;\n        return (_snapPointDetents_ = snapPointDetents[foundIndex + 1]) !== null && _snapPointDetents_ !== void 0 ? _snapPointDetents_ : snapPointDetents[snapPointDetents.length - 1];\n      case 1:\n        var _snapPointDetents_1;\n        return (_snapPointDetents_1 = snapPointDetents[foundIndex - 1]) !== null && _snapPointDetents_1 !== void 0 ? _snapPointDetents_1 : snapPointDetents[0];\n    }\n  }\n  static getClosestSnapPoint(snapPointDetents, currentY) {\n    let closest = snapPointDetents[0];\n    let minDifference = Math.abs(snapPointDetents[0] - currentY);\n    for (let i = 1; i < snapPointDetents.length; i += 1) {\n      const difference = Math.abs(snapPointDetents[i] - currentY);\n      if (difference < minDifference) {\n        closest = snapPointDetents[i];\n        minDifference = difference;\n      }\n    }\n    return closest;\n  }\n  constructor(sheetEl, _ref) {\n    let {\n      sheetScrollEl,\n      sheetTransitionController,\n      backdropTransitionController,\n      onSnapPointChange,\n      onDismiss\n    } = _ref;\n    _define_property(this, \"sheetEl\", void 0);\n    _define_property(this, \"isInitialized\", false);\n    _define_property(this, \"panState\", 'idle');\n    _define_property(this, \"pannedEl\", null);\n    _define_property(this, \"sheetHeight\", 0);\n    _define_property(this, \"rafId\", null);\n    _define_property(this, \"currentSnapPoint\", 0);\n    _define_property(this, \"nextSnapPoint\", 0);\n    _define_property(this, \"snapPointDetents\", [0, 0]);\n    _define_property(this, \"unit\", '%');\n    _define_property(this, \"disableVerticalScrollBouncingDispose\", noop);\n    _define_property(this, \"sheetScrollEl\", void 0);\n    _define_property(this, \"sheetTransitionController\", void 0);\n    _define_property(this, \"backdropTransitionController\", void 0);\n    _define_property(this, \"panGestureRecognizer\", void 0);\n    _define_property(this, \"onSnapPointChange\", void 0);\n    _define_property(this, \"onDismiss\", void 0);\n    this.sheetEl = sheetEl;\n    this.onSnapPointChange = onSnapPointChange;\n    this.onDismiss = onDismiss;\n    this.panGestureRecognizer = new UIPanGestureRecognizer();\n    this.sheetScrollEl = sheetScrollEl;\n    this.sheetTransitionController = sheetTransitionController;\n    this.backdropTransitionController = backdropTransitionController;\n  }\n}","map":{"version":3,"names":["noop","clamp","rubberbandIfOutOfBounds","getNearestOverflowAncestor","hasSelectionWithRangeType","UIPanGestureRecognizer","BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY","DRAG_THRESHOLDS","DYNAMIC_SNAP_POINT_DATA","SNAP_POINT_DETENTS","BottomSheetController","init","snapPoint","isInitialized","unit","currentSnapPoint","IDLE_POINT_VALUE","snapPointDetents","MIN","initial","detents","destroy","_this_backdropTransitionController","pannedEl","sheetTransitionController","cleanup","backdropTransitionController","disableVerticalScrollBouncingDispose","panStart","event","panState","target","panGestureRecognizer","setStartCoords","panMove","setInitialTimeOnce","setEndCoords","preventUntilPanGestureBecomesExpected","preventImmediatelyIfPannedElIsNotValid","preventUntilVerticalScrollingOnSheetScrollElBecomesExpected","preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled","sheetHeight","sheetEl","offsetHeight","disableVerticalScrollBouncingIfNeeded","sheetScrollEl","isDynamicSnapPoint","COMPUTED_INDEX","y1","y2","nextSnapPoint","LARGE","calculateSnapPoint","panEnd","prevCurrentSnapPoint","getSnapPointTo","onSnapPointChange","reset","immediately","arguments","length","undefined","rafId","cancelAnimationFrame","enableTransition","onDismiss","backdropOpacity","requestAnimationFrame","_this_backdropTransitionController1","disableTransition","set","cleanupOnTransitionEnd","unset","closestSnapPoint","getClosestSnapPoint","panDirection","direction","axis","velocity","Math","abs","y","VELOCITY","closestSnapPointByDirection","getClosestSnapPointByDirection","distance","DISTANCE_FOR_MOVING_START","closest","contains","scrollHeight","clientHeight","scrollTop","isLastSnapPointDetents","overflowAncestor","targetEl","style","setProperty","dispose","removeProperty","currentY","foundIndex","findIndex","i","_snapPointDetents_","_snapPointDetents_1","minDifference","difference","constructor","_ref","_define_property"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/lib/sheet/controllers/BottomSheetController.ts"],"sourcesContent":["import { noop } from '@vkontakte/vkjs';\nimport { clamp } from '../../../helpers/math';\nimport { rubberbandIfOutOfBounds } from '../../animation';\nimport { getNearestOverflowAncestor, hasSelectionWithRangeType } from '../../dom';\nimport { UIPanGestureRecognizer } from '../../touch/UIPanGestureRecognizer';\nimport {\n  BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY,\n  DRAG_THRESHOLDS,\n  DYNAMIC_SNAP_POINT_DATA,\n  SNAP_POINT_DETENTS,\n} from '../constants';\nimport type { CSSTransitionController } from './CSSTransitionController';\n\nexport type SnapPointDetents = [number, number] | [number, number, number];\n\nexport type SnapPoint = 'auto' | { initial: number; detents: SnapPointDetents };\n\nexport type SnapPointChange = (snapPoint: number) => void;\n\nexport type BottomSheetControllerOptions = {\n  sheetScrollEl: HTMLElement | null;\n  sheetTransitionController: CSSTransitionController<string>;\n  backdropTransitionController: CSSTransitionController | null;\n  onSnapPointChange: SnapPointChange;\n  onDismiss: VoidFunction;\n};\n\nexport class BottomSheetController {\n  private readonly sheetEl: HTMLElement;\n\n  constructor(\n    sheetEl: HTMLElement,\n    {\n      sheetScrollEl,\n      sheetTransitionController,\n      backdropTransitionController,\n      onSnapPointChange,\n      onDismiss,\n    }: BottomSheetControllerOptions,\n  ) {\n    this.sheetEl = sheetEl;\n    this.onSnapPointChange = onSnapPointChange;\n    this.onDismiss = onDismiss;\n    this.panGestureRecognizer = new UIPanGestureRecognizer();\n    this.sheetScrollEl = sheetScrollEl;\n    this.sheetTransitionController = sheetTransitionController;\n    this.backdropTransitionController = backdropTransitionController;\n  }\n\n  init(snapPoint: SnapPoint) {\n    this.isInitialized = true;\n\n    if (snapPoint === 'auto') {\n      this.unit = 'px';\n      this.currentSnapPoint = DYNAMIC_SNAP_POINT_DATA.IDLE_POINT_VALUE;\n      this.snapPointDetents = [SNAP_POINT_DETENTS.MIN, DYNAMIC_SNAP_POINT_DATA.IDLE_POINT_VALUE];\n    } else {\n      this.unit = '%';\n      this.currentSnapPoint = snapPoint.initial;\n      this.snapPointDetents = snapPoint.detents;\n    }\n  }\n\n  destroy() {\n    this.isInitialized = false;\n    this.pannedEl = null;\n    this.sheetTransitionController.cleanup();\n    this.backdropTransitionController?.cleanup();\n\n    this.disableVerticalScrollBouncingDispose();\n    this.disableVerticalScrollBouncingDispose = noop;\n  }\n\n  panStart(event: UIEvent) {\n    if (\n      !this.isInitialized ||\n      this.panState !== 'idle' ||\n      hasSelectionWithRangeType(event.target)\n    ) {\n      return;\n    }\n\n    this.panState = 'start';\n    this.pannedEl = event.target as HTMLElement;\n    this.panGestureRecognizer.setStartCoords(event);\n  }\n\n  panMove(event: UIEvent) {\n    switch (this.panState) {\n      case 'start':\n        this.panGestureRecognizer.setInitialTimeOnce();\n        this.panGestureRecognizer.setEndCoords(event);\n\n        if (this.preventUntilPanGestureBecomesExpected()) {\n          return;\n        }\n\n        if (this.preventImmediatelyIfPannedElIsNotValid()) {\n          this.panState = 'idle';\n          return;\n        }\n\n        if (this.preventUntilVerticalScrollingOnSheetScrollElBecomesExpected()) {\n          return;\n        }\n\n        if (this.preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled()) {\n          this.panState = 'idle';\n          return;\n        }\n\n        this.panState = 'moving';\n        this.panGestureRecognizer.setStartCoords(event);\n\n        this.sheetHeight = this.sheetEl.offsetHeight;\n\n        this.disableVerticalScrollBouncingDispose =\n          BottomSheetController.disableVerticalScrollBouncingIfNeeded(\n            this.sheetScrollEl,\n            this.pannedEl,\n          );\n\n        if (this.isDynamicSnapPoint) {\n          this.currentSnapPoint = this.sheetHeight;\n          this.snapPointDetents[DYNAMIC_SNAP_POINT_DATA.COMPUTED_INDEX] = this.sheetHeight;\n        }\n        break;\n      case 'moving':\n        this.panGestureRecognizer.setEndCoords(event);\n\n        const { y1, y2 } = this.panGestureRecognizer;\n\n        this.nextSnapPoint = rubberbandIfOutOfBounds(\n          this.currentSnapPoint - ((y2 - y1) / this.sheetHeight) * this.currentSnapPoint,\n          SNAP_POINT_DETENTS.MIN,\n          this.isDynamicSnapPoint ? this.sheetHeight : SNAP_POINT_DETENTS.LARGE,\n        );\n\n        this.calculateSnapPoint(this.nextSnapPoint, true);\n        break;\n    }\n  }\n\n  panEnd() {\n    switch (this.panState) {\n      case 'moving':\n        const prevCurrentSnapPoint = this.currentSnapPoint;\n        this.currentSnapPoint = this.getSnapPointTo(this.nextSnapPoint);\n\n        if (\n          prevCurrentSnapPoint !== this.currentSnapPoint &&\n          this.currentSnapPoint > SNAP_POINT_DETENTS.MIN\n        ) {\n          this.onSnapPointChange(this.currentSnapPoint);\n        }\n\n        this.calculateSnapPoint(this.currentSnapPoint);\n        break;\n    }\n\n    this.panState = 'idle';\n    this.panGestureRecognizer.reset();\n\n    this.disableVerticalScrollBouncingDispose();\n    this.disableVerticalScrollBouncingDispose = noop;\n  }\n\n  private isInitialized = false;\n  private panState: 'idle' | 'start' | 'moving' = 'idle';\n  private pannedEl: HTMLElement | null = null;\n  private sheetHeight = 0;\n  private rafId: number | null = null;\n  private currentSnapPoint = 0;\n  private nextSnapPoint = 0;\n  private snapPointDetents: SnapPointDetents = [0, 0];\n  private unit: 'px' | '%' = '%';\n  private get isDynamicSnapPoint() {\n    return this.unit === 'px';\n  }\n  private disableVerticalScrollBouncingDispose = noop;\n  private readonly sheetScrollEl: HTMLElement | null;\n  private readonly sheetTransitionController: CSSTransitionController<string>;\n  private readonly backdropTransitionController: CSSTransitionController | null;\n  private readonly panGestureRecognizer: UIPanGestureRecognizer;\n  private readonly onSnapPointChange: SnapPointChange;\n  private readonly onDismiss: VoidFunction;\n\n  private calculateSnapPoint(nextSnapPoint: number, immediately = false) {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n\n    if (nextSnapPoint <= SNAP_POINT_DETENTS.MIN) {\n      this.sheetTransitionController.enableTransition();\n      this.backdropTransitionController?.enableTransition();\n      this.panState = 'idle';\n      this.onDismiss();\n      return;\n    }\n\n    const backdropOpacity = clamp(\n      this.isDynamicSnapPoint\n        ? nextSnapPoint / this.sheetHeight\n        : (nextSnapPoint * 2) / SNAP_POINT_DETENTS.LARGE,\n      0,\n      1,\n    );\n\n    this.rafId = requestAnimationFrame(() => {\n      if (immediately) {\n        this.backdropTransitionController?.disableTransition().set(backdropOpacity);\n        this.sheetTransitionController.disableTransition().set(`${nextSnapPoint}${this.unit}`);\n        return;\n      }\n\n      if (this.isDynamicSnapPoint) {\n        this.sheetTransitionController.cleanupOnTransitionEnd();\n      }\n\n      this.backdropTransitionController?.unset();\n      this.sheetTransitionController.enableTransition().set(`${this.currentSnapPoint}${this.unit}`);\n    });\n  }\n\n  private getSnapPointTo(nextSnapPoint: number) {\n    const closestSnapPoint = BottomSheetController.getClosestSnapPoint(\n      this.snapPointDetents,\n      nextSnapPoint,\n    );\n    if (closestSnapPoint !== this.currentSnapPoint) {\n      return closestSnapPoint;\n    }\n\n    const panDirection = this.panGestureRecognizer.direction();\n    if (panDirection.axis !== 'y' || panDirection.direction === null) {\n      return this.currentSnapPoint;\n    }\n\n    const velocity = this.panGestureRecognizer.velocity();\n    if (Math.abs(velocity.y) < DRAG_THRESHOLDS.VELOCITY) {\n      return this.currentSnapPoint;\n    }\n\n    const closestSnapPointByDirection = BottomSheetController.getClosestSnapPointByDirection(\n      this.snapPointDetents,\n      closestSnapPoint,\n      panDirection.direction,\n    );\n\n    return closestSnapPointByDirection;\n  }\n\n  private preventUntilPanGestureBecomesExpected() {\n    return (\n      this.panGestureRecognizer.direction().axis === 'x' ||\n      this.panGestureRecognizer.distance() < DRAG_THRESHOLDS.DISTANCE_FOR_MOVING_START\n    );\n  }\n\n  private preventImmediatelyIfPannedElIsNotValid() {\n    return (\n      this.pannedEl === null ||\n      // Элемент со специальным атрибутом\n      this.pannedEl.closest(`[${BLOCK_SHEET_BEHAVIOR_DATA_ATTRIBUTE_KEY}=true]`) !== null || // eslint-disable-line no-restricted-properties\n      // Элемент за пределами панели.\n      !this.sheetEl.contains(this.pannedEl)\n    );\n  }\n\n  private preventUntilVerticalScrollingOnSheetScrollElBecomesExpected() {\n    if (\n      this.sheetScrollEl === null ||\n      !this.sheetScrollEl.contains(this.pannedEl) ||\n      this.sheetScrollEl.scrollHeight <= this.sheetScrollEl.clientHeight\n    ) {\n      return false;\n    }\n\n    if (this.sheetScrollEl.scrollTop === 0) {\n      return (\n        this.panGestureRecognizer.direction().direction === -1 &&\n        BottomSheetController.isLastSnapPointDetents(this.snapPointDetents, this.currentSnapPoint)\n      );\n    }\n\n    return true;\n  }\n\n  private preventImmediatelyIfVerticalScrollingOnPannedElIsScrolled() {\n    if (\n      /* istanbul ignore next: покрываем TypeScript */\n      this.pannedEl === null ||\n      this.pannedEl === this.sheetEl ||\n      this.pannedEl === this.sheetScrollEl\n    ) {\n      return false;\n    }\n\n    const overflowAncestor = getNearestOverflowAncestor(this.pannedEl, this.sheetEl);\n\n    if (\n      overflowAncestor === null ||\n      this.sheetScrollEl === overflowAncestor ||\n      overflowAncestor.scrollHeight <= overflowAncestor.clientHeight\n    ) {\n      return false;\n    }\n\n    return (\n      overflowAncestor.scrollTop !== 0 || this.panGestureRecognizer.direction().direction === -1\n    );\n  }\n\n  private static disableVerticalScrollBouncingIfNeeded(\n    sheetScrollEl: HTMLElement | null,\n    targetEl: HTMLElement | null,\n  ) {\n    if (\n      sheetScrollEl !== null &&\n      sheetScrollEl.scrollTop <= 0 &&\n      sheetScrollEl.contains(targetEl) &&\n      sheetScrollEl.scrollHeight > sheetScrollEl.clientHeight\n    ) {\n      sheetScrollEl.style.setProperty('overflow-y', 'hidden');\n      return function dispose() {\n        sheetScrollEl.style.removeProperty('overflow-y');\n      };\n    }\n    return noop;\n  }\n\n  private static isLastSnapPointDetents(\n    snapPointDetents: SnapPointDetents,\n    currentY: number,\n  ): boolean {\n    return currentY === snapPointDetents[snapPointDetents.length - 1];\n  }\n\n  private static getClosestSnapPointByDirection(\n    snapPointDetents: SnapPointDetents,\n    currentY: number,\n    direction: -1 | 1,\n  ): number {\n    const foundIndex = snapPointDetents.findIndex((i) => i === currentY);\n    switch (direction) {\n      case -1:\n        return snapPointDetents[foundIndex + 1] ?? snapPointDetents[snapPointDetents.length - 1];\n      case 1:\n        return snapPointDetents[foundIndex - 1] ?? snapPointDetents[0];\n    }\n  }\n\n  private static getClosestSnapPoint(snapPointDetents: SnapPointDetents, currentY: number) {\n    let closest = snapPointDetents[0];\n    let minDifference = Math.abs(snapPointDetents[0] - currentY);\n\n    for (let i = 1; i < snapPointDetents.length; i += 1) {\n      const difference = Math.abs(snapPointDetents[i] - currentY);\n      if (difference < minDifference) {\n        closest = snapPointDetents[i];\n        minDifference = difference;\n      }\n    }\n\n    return closest;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}