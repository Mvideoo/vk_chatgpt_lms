{"ast":null,"code":"import * as React from \"react\";\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from \"../../lib/dom.js\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect.js\";\nimport { createAutoScrollController, getAutoScrollingData } from \"./autoScroll.js\";\nimport { AUTO_SCROLL_START_DELAY, DATA_DRAGGABLE_PLACEHOLDER_KEY, ITEM_INITIAL_INDEX } from \"./constants.js\";\nimport { getTargetIsOverOrUnderElData, setDraggingItemShiftStyles, setInitialDraggingItemStyles, setInitialPlaceholderItemStyles, setInitialSiblingItemStyles, setSiblingItemsShiftStyles, unsetInitialDraggingItemStyles, unsetInitialPlaceholderItemStyles, unsetInitialSiblingItemStyles } from \"./utils.js\";\nexport const useDraggableWithDomApi = _ref => {\n  let {\n    elRef: draggingElRef,\n    onDragFinish\n  } = _ref;\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n  const scrollElRef = React.useRef(null);\n  const lastScrollTopRef = React.useRef(0);\n  const scrollControllerRef = React.useRef(null);\n  const initializeScrollRefs = draggableEl => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    var _scrollControllerRef_current;\n    lastScrollTopRef.current = 0;\n    (_scrollControllerRef_current = scrollControllerRef.current) === null || _scrollControllerRef_current === void 0 ? void 0 : _scrollControllerRef_current.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n  const lastDragDirectionRef = React.useRef(undefined);\n  const toggleDragDirection = (prevShiftY, nextShiftY) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n  const itemStartIndexRef = React.useRef(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef(null);\n  const placeholderItemRef = React.useRef(null);\n  const siblingItemsRef = React.useRef([]);\n  const itemsGapRef = React.useRef(0);\n  const initializeItems = draggingEl => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const parentElement = draggingEl.parentElement;\n    itemsGapRef.current = parentElement ? parseInt(parentElement.style.gridGap) : 0;\n    const {\n      children\n    } = parentElement || {\n      children: []\n    };\n    Array.prototype.forEach.call(children, (el, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = {\n          index,\n          el,\n          draggingElRect\n        };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = {\n          index,\n          el,\n          draggingElRect\n        };\n      } else {\n        siblingItemsRef.current.push({\n          index,\n          el,\n          shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index,\n          draggingElRect\n        }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(sibling => setInitialSiblingItemStyles(sibling, itemsGapRef.current)); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n    const swappedItemIndexRange = {\n      from: itemStartIndexRef.current,\n      to: itemEndIndexRef.current\n    };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = clientY => {\n    const shiftItemEls = [];\n    const unshiftItemEls = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach(siblingItem => {\n      const {\n        isOverEl,\n        isUnderEl\n      } = getTargetIsOverOrUnderElData(clientY, getBoundingClientRect(siblingItem.el));\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (shiftItemEls, unshiftItemEls) => {\n    shiftItemEls.forEach(item => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n    unshiftItemEls.forEach(item => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n  };\n  const schedulingAutoScrollTimeoutIdRef = React.useRef(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current) : {\n          shouldScrolling: false,\n          y: 0\n        };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n  const onDragStart = event => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n  const onDragMove = event => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n    const draggingEl = draggingElRef.current;\n    if (!draggingEl) {\n      return;\n    }\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(lastClientYRef.current);\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging(prevDragging => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n  const onDragEnd = event => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n    const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n  useIsomorphicLayoutEffect(function recalculateOnScroll() {\n    const scrollEl = scrollElRef.current;\n    if (!dragging || !scrollEl) {\n      return;\n    }\n    scrollEl.addEventListener('scroll', handleScroll);\n    return () => {\n      if (scrollEl) {\n        scrollEl.removeEventListener('scroll', handleScroll);\n      }\n    };\n  }, [dragging, handleScroll]);\n  useIsomorphicLayoutEffect(() => function componentWillUnmount() {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n    }\n  }, []);\n  return {\n    dragging,\n    onDragStart,\n    onDragMove,\n    onDragEnd\n  };\n};","map":{"version":3,"names":["React","getBoundingClientRect","getNearestOverflowAncestor","getNodeScroll","useIsomorphicLayoutEffect","createAutoScrollController","getAutoScrollingData","AUTO_SCROLL_START_DELAY","DATA_DRAGGABLE_PLACEHOLDER_KEY","ITEM_INITIAL_INDEX","getTargetIsOverOrUnderElData","setDraggingItemShiftStyles","setInitialDraggingItemStyles","setInitialPlaceholderItemStyles","setInitialSiblingItemStyles","setSiblingItemsShiftStyles","unsetInitialDraggingItemStyles","unsetInitialPlaceholderItemStyles","unsetInitialSiblingItemStyles","useDraggableWithDomApi","_ref","elRef","draggingElRef","onDragFinish","dragging","setDragging","useState","lastClientYRef","useRef","lastDragShiftYRef","scrollElRef","lastScrollTopRef","scrollControllerRef","initializeScrollRefs","draggableEl","node","current","scrollTop","cleanupScrollRefs","_scrollControllerRef_current","stop","lastDragDirectionRef","undefined","toggleDragDirection","prevShiftY","nextShiftY","shiftYDiff","itemStartIndexRef","itemEndIndexRef","draggingItemRef","placeholderItemRef","siblingItemsRef","itemsGapRef","initializeItems","draggingEl","draggingElRect","parentElement","parseInt","style","gridGap","children","Array","prototype","forEach","call","el","index","getAttribute","push","shifted","sibling","cleanupItems","swappedItemIndexRange","from","to","getShiftAndUnshiftItemsPreparedData","clientY","shiftItemEls","unshiftItemEls","siblingItem","isOverEl","isUnderEl","setShiftAndUnshiftItemStyles","item","schedulingAutoScrollTimeoutIdRef","clearSchedulingAutoScrollTimeout","clearTimeout","tryAutoScroll","shouldScrolling","y","schedulingAutoScroll","setTimeout","onDragStart","event","originalEvent","stopPropagation","preventDefault","onDragMove","shiftY","isRunning","prevDragging","onDragEnd","swappedItemRange","handleScroll","useCallback","nextScrollTop","scrollDiff","clientYWithScrollOffset","recalculateOnScroll","scrollEl","addEventListener","removeEventListener","componentWillUnmount"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/hooks/useDraggableWithDomApi/useDraggableWithDomApi.ts"],"sourcesContent":["import * as React from 'react';\nimport type { CustomTouchEvent } from '../../components/Touch/Touch';\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { createAutoScrollController, getAutoScrollingData } from './autoScroll';\nimport {\n  AUTO_SCROLL_START_DELAY,\n  DATA_DRAGGABLE_PLACEHOLDER_KEY,\n  ITEM_INITIAL_INDEX,\n} from './constants';\nimport type {\n  Direction,\n  DraggingItem,\n  PlaceholderItem,\n  SiblingItem,\n  UseDraggable,\n  UseDraggableProps,\n} from './types';\nimport {\n  getTargetIsOverOrUnderElData,\n  setDraggingItemShiftStyles,\n  setInitialDraggingItemStyles,\n  setInitialPlaceholderItemStyles,\n  setInitialSiblingItemStyles,\n  setSiblingItemsShiftStyles,\n  unsetInitialDraggingItemStyles,\n  unsetInitialPlaceholderItemStyles,\n  unsetInitialSiblingItemStyles,\n} from './utils';\n\nexport const useDraggableWithDomApi = <T extends HTMLElement>({\n  elRef: draggingElRef,\n  onDragFinish,\n}: UseDraggableProps<T>): UseDraggable => {\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n\n  const scrollElRef = React.useRef<Element | Window | null>(null);\n  const lastScrollTopRef = React.useRef<number>(0);\n  const scrollControllerRef = React.useRef<ReturnType<typeof createAutoScrollController> | null>(\n    null,\n  );\n  const initializeScrollRefs = (draggableEl: HTMLElement) => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    lastScrollTopRef.current = 0;\n    scrollControllerRef.current?.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n\n  const lastDragDirectionRef = React.useRef<Direction | undefined>(undefined);\n  const toggleDragDirection = (prevShiftY: number, nextShiftY: number) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n\n  const itemStartIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef<DraggingItem | null>(null);\n  const placeholderItemRef = React.useRef<PlaceholderItem | null>(null);\n  const siblingItemsRef = React.useRef<SiblingItem[]>([]);\n  const itemsGapRef = React.useRef<number>(0);\n  const initializeItems = (draggingEl: HTMLElement) => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const parentElement = draggingEl.parentElement;\n    itemsGapRef.current = parentElement ? parseInt(parentElement.style.gridGap) : 0;\n\n    const { children } = parentElement || { children: [] };\n    Array.prototype.forEach.call(children, (el: HTMLElement, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = { index, el, draggingElRect };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = { index, el, draggingElRect };\n      } else {\n        siblingItemsRef.current.push({ index, el, shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index, draggingElRect }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach((sibling) =>\n      setInitialSiblingItemStyles(sibling, itemsGapRef.current),\n    ); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n\n    const swappedItemIndexRange = { from: itemStartIndexRef.current, to: itemEndIndexRef.current };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = (\n    clientY: number,\n  ): [Array<[SiblingItem, Direction]>, Array<[SiblingItem, Direction]>] => {\n    const shiftItemEls: Array<[SiblingItem, Direction]> = [];\n    const unshiftItemEls: Array<[SiblingItem, Direction]> = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach((siblingItem) => {\n      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(\n        clientY,\n        getBoundingClientRect(siblingItem.el),\n      );\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (\n    shiftItemEls: Array<[SiblingItem, Direction]>,\n    unshiftItemEls: Array<[SiblingItem, Direction]>,\n  ) => {\n    shiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n    unshiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n  };\n\n  const schedulingAutoScrollTimeoutIdRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current\n          ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current)\n          : {\n              shouldScrolling: false,\n              y: 0,\n            };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n\n  const onDragStart = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const onDragMove = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    const draggingEl = draggingElRef.current;\n\n    if (!draggingEl) {\n      return;\n    }\n\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(\n          lastClientYRef.current,\n        );\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging((prevDragging) => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n\n  const onDragEnd = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n\n    const [shiftItemEls, unshiftItemEls] =\n      getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n\n  useIsomorphicLayoutEffect(\n    function recalculateOnScroll() {\n      const scrollEl = scrollElRef.current;\n      if (!dragging || !scrollEl) {\n        return;\n      }\n      scrollEl.addEventListener('scroll', handleScroll);\n      return () => {\n        if (scrollEl) {\n          scrollEl.removeEventListener('scroll', handleScroll);\n        }\n      };\n    },\n    [dragging, handleScroll],\n  );\n\n  useIsomorphicLayoutEffect(\n    () =>\n      function componentWillUnmount() {\n        if (placeholderItemRef.current) {\n          unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n        }\n      },\n    [],\n  );\n\n  return { dragging, onDragStart, onDragMove, onDragEnd };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}