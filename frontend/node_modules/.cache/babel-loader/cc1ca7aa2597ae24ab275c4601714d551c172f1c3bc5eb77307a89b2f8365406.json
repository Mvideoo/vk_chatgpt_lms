{"ast":null,"code":"import * as React from \"react\";\nimport { hasMouse as hasPointerLib } from \"@vkontakte/vkjs\";\nimport { useAdaptivity } from \"../../../hooks/useAdaptivity.js\";\nimport { useFocusWithin } from \"../../../hooks/useFocusWithin.js\";\nimport { useIsClient } from \"../../../hooks/useIsClient.js\";\nimport { useIsomorphicLayoutEffect } from \"../../../lib/useIsomorphicLayoutEffect.js\";\nexport function useNonInteractiveOverlayProps(rootRef) {\n  const focusWithin = useFocusWithin(rootRef);\n  const [nonInteractiveFocusShown, setNonInteractiveFocusShown] = React.useState(false);\n  function onClick(event) {\n    if (event.detail > 0) {\n      // Если мы попали на вложенный в оверлей элемент через focus,\n      // то при клике мышкой мы должны начать реагировать на hover-состояние,\n      // даже если фокус всё ещё остался на вложенном элементе (был по нему клик)\n      setNonInteractiveFocusShown(false);\n    }\n  }\n  useIsomorphicLayoutEffect(() => {\n    setNonInteractiveFocusShown(focusWithin);\n  }, [focusWithin]);\n  return {\n    shown: nonInteractiveFocusShown && focusWithin,\n    onClick\n  };\n}\n/*\n * Определям значение по умолчанию для свойства visibility.\n *\n * Задача состоит в том, чтобы правильно рендерить Overlay.\n * Для устройств с мышкой, мы можем показывать его по наведению,\n * а для остальных устройств он должен быть виден всегда.\n *\n * Задача в том, чтобы избежать проблем при гидратации,\n * и отложить использование значения `always`, пока мы точно не уверены, что у пользоватея действительно нет мышки.\n * Иначе Overlay при первом рендере может показаться, а потом исчезнуть.\n *\n * Основано на хуке `useAdaptivityHasPointer`, но если при первом рендере мы точно не знаем значения hasPointer, то возвращаем `on-hover`.\n * */\nexport function useCalculatedDefaultVisibility() {\n  const {\n    hasPointer: hasPointerContext\n  } = useAdaptivity();\n  const needTwoPassRendering = hasPointerContext === undefined;\n  const isClient = useIsClient(!needTwoPassRendering);\n  if (!isClient && hasPointerContext === undefined) {\n    return 'on-hover';\n  }\n  const hasPointer = hasPointerContext !== null && hasPointerContext !== void 0 ? hasPointerContext : hasPointerLib;\n  return hasPointer ? 'on-hover' : 'always';\n}","map":{"version":3,"names":["React","hasMouse","hasPointerLib","useAdaptivity","useFocusWithin","useIsClient","useIsomorphicLayoutEffect","useNonInteractiveOverlayProps","rootRef","focusWithin","nonInteractiveFocusShown","setNonInteractiveFocusShown","useState","onClick","event","detail","shown","useCalculatedDefaultVisibility","hasPointer","hasPointerContext","needTwoPassRendering","undefined","isClient"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/ImageBase/ImageBaseOverlay/hooks.ts"],"sourcesContent":["import * as React from 'react';\nimport { hasMouse as hasPointerLib } from '@vkontakte/vkjs';\nimport { useAdaptivity } from '../../../hooks/useAdaptivity';\nimport { useFocusWithin } from '../../../hooks/useFocusWithin';\nimport { useIsClient } from '../../../hooks/useIsClient';\nimport { useIsomorphicLayoutEffect } from '../../../lib/useIsomorphicLayoutEffect';\n\nexport function useNonInteractiveOverlayProps(rootRef: React.RefObject<HTMLElement | null>) {\n  const focusWithin = useFocusWithin(rootRef);\n  const [nonInteractiveFocusShown, setNonInteractiveFocusShown] = React.useState(false);\n\n  function onClick(event: React.MouseEvent) {\n    if (event.detail > 0) {\n      // Если мы попали на вложенный в оверлей элемент через focus,\n      // то при клике мышкой мы должны начать реагировать на hover-состояние,\n      // даже если фокус всё ещё остался на вложенном элементе (был по нему клик)\n      setNonInteractiveFocusShown(false);\n    }\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    setNonInteractiveFocusShown(focusWithin);\n  }, [focusWithin]);\n\n  return {\n    shown: nonInteractiveFocusShown && focusWithin,\n    onClick,\n  };\n}\n\n/*\n * Определям значение по умолчанию для свойства visibility.\n *\n * Задача состоит в том, чтобы правильно рендерить Overlay.\n * Для устройств с мышкой, мы можем показывать его по наведению,\n * а для остальных устройств он должен быть виден всегда.\n *\n * Задача в том, чтобы избежать проблем при гидратации,\n * и отложить использование значения `always`, пока мы точно не уверены, что у пользоватея действительно нет мышки.\n * Иначе Overlay при первом рендере может показаться, а потом исчезнуть.\n *\n * Основано на хуке `useAdaptivityHasPointer`, но если при первом рендере мы точно не знаем значения hasPointer, то возвращаем `on-hover`.\n * */\nexport function useCalculatedDefaultVisibility() {\n  const { hasPointer: hasPointerContext } = useAdaptivity();\n\n  const needTwoPassRendering = hasPointerContext === undefined;\n  const isClient = useIsClient(!needTwoPassRendering);\n\n  if (!isClient && hasPointerContext === undefined) {\n    return 'on-hover';\n  }\n\n  const hasPointer = hasPointerContext ?? hasPointerLib;\n\n  return hasPointer ? 'on-hover' : 'always';\n}\n"],"mappings":"AAAA,YAAYA,KAAA,MAAW;AACvB,SAASC,QAAA,IAAYC,aAAa,QAAQ;AAC1C,SAASC,aAAa,QAAQ;AAC9B,SAASC,cAAc,QAAQ;AAC/B,SAASC,WAAW,QAAQ;AAC5B,SAASC,yBAAyB,QAAQ;AAE1C,OAAO,SAASC,8BAA8BC,OAA4C;EACxF,MAAMC,WAAA,GAAcL,cAAA,CAAeI,OAAA;EACnC,MAAM,CAACE,wBAAA,EAA0BC,2BAAA,CAA4B,GAAGX,KAAA,CAAMY,QAAQ,CAAC;EAE/E,SAASC,QAAQC,KAAuB;IACtC,IAAIA,KAAA,CAAMC,MAAM,GAAG,GAAG;MACpB;MACA;MACA;MACAJ,2BAAA,CAA4B;IAC9B;EACF;EAEAL,yBAAA,CAA0B;IACxBK,2BAAA,CAA4BF,WAAA;EAC9B,GAAG,CAACA,WAAA,CAAY;EAEhB,OAAO;IACLO,KAAA,EAAON,wBAAA,IAA4BD,WAAA;IACnCI;EACF;AACF;AAEA;;;;;;;;;;;;;AAaA,OAAO,SAASI,+BAAA;EACd,MAAM;IAAEC,UAAA,EAAYC;EAAiB,CAAE,GAAGhB,aAAA;EAE1C,MAAMiB,oBAAA,GAAuBD,iBAAA,KAAsBE,SAAA;EACnD,MAAMC,QAAA,GAAWjB,WAAA,CAAY,CAACe,oBAAA;EAE9B,IAAI,CAACE,QAAA,IAAYH,iBAAA,KAAsBE,SAAA,EAAW;IAChD,OAAO;EACT;EAEA,MAAMH,UAAA,GAAaC,iBAAA,aAAAA,iBAAA,cAAAA,iBAAA,GAAqBjB,aAAA;EAExC,OAAOgB,UAAA,GAAa,aAAa;AACnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}