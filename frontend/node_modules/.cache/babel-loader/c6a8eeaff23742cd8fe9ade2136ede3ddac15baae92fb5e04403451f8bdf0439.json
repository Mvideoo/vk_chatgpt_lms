{"ast":null,"code":"import { useEffect, useRef, useState } from \"react\";\nimport { debounce, throttle } from \"@vkontakte/vkjs\";\nimport { getVisualViewport, isHTMLContentEditableElement, useDOM } from \"../lib/dom.js\";\n/**\n * > см. [Неудобно работать с клавиатурой в ModalPage на iOS #3792](https://github.com/VKCOM/VKUI/discussions/3792)\n *\n * Для реализации модальных окон для тач-устройств, мы вынуждены отслеживать открытие виртуальной\n * клавиатуры. По состоянию `opened` компоненты должны временно блокировать дальнейшее взаимодействие\n * с ними. Например, отключить закрытие по свайпу, чтобы не мешать пользователю работать с полями\n * ввода.\n *\n * Помимо этого в **Safari** и в **Chrome Android** нам нужно отслеживать прокрутку области видимости\n * пользователем, т.к. в упомянутых браузерах, виртуальная клавиатура поднимает контент вверх\n * не изменяя её высоту. Из-за этого появляется возможность прокручивать `window`, что визуально\n * выглядит плохо. В хуке мы ловим фокус на поле ввода и далее, если это тач-устройство, то\n * отлавливаем события прокрутки на `window`, чтобы сохранять текущую её позицию через `scrollTo(x, y)`.\n *\n * **Troubleshooting**\n *\n * - в **Safari** и в **Chrome Android** шапка будет выдвигаться вверх – хаки с выставлением `offsetTop`\n *   из `VisualViewport` порождают reflow/repaint и прыгания контента;\n * - в **Safari** изменение высоты виртуальной клавиатуры, например, на выбор эмодзи, не поднимет\n *   `VisualViewport` из-за чего клавиатура может частично перекрыть элементы интерфейса.\n *\n * **Полезные ссылки**\n *\n * - [The Eccentric Ways of iOS Safari with the Keyboard](https://web.archive.org/web/20240920081850/https://blog.opendigerati.com/the-eccentric-ways-of-ios-safari-with-the-keyboard-b5aa3f34228d?gi=5411141a13e0)\n * - [Dealing with the visual viewport](https://web.archive.org/web/20240920082109/https://rdavis.io/articles/dealing-with-the-visual-viewport)\n * - [How to get the document height in iOS Safari when the on-screen keyboard is open](https://web.archive.org/web/20240920082743/https://martijnhols.nl/gists/how-to-get-document-height-ios-safari-osk)\n */\nexport function useVirtualKeyboardState() {\n  let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  const {\n    window,\n    document\n  } = useDOM();\n  const [focusedEl, setFocusedEl] = useState(null);\n  const [keyboardOpened, setKeyboardOpened] = useState(false);\n  const prevVisualViewportRef = useRef(null);\n  useEffect(function handleFocusedEl() {\n    if (!enabled || !window || !document) {\n      return;\n    }\n    const handleFocus = event => {\n      const activeElement = event === true ? document.activeElement : event.target;\n      if (isHTMLContentEditableElement(activeElement)) {\n        const patchedEvent = event === true ? {\n          type: 'focusin'\n        } : event;\n        switch (patchedEvent.type) {\n          case 'focusin':\n            prevVisualViewportRef.current = getVisualViewport(window);\n            setFocusedEl(activeElement);\n            break;\n          case 'focusout':\n            prevVisualViewportRef.current = null;\n            setKeyboardOpened(false);\n            setFocusedEl(null);\n            break;\n        }\n      }\n    };\n    /**\n    * У полей с autoFocus не отлавливаются события `focus`, для этого вызываем обработчик\n    * вручную, чтобы иметь хоть какое-то понимание происходящего.\n    */\n    handleFocus(true);\n    const eventOptions = {\n      passive: true,\n      capture: false\n    };\n    document.addEventListener('focusin', handleFocus, eventOptions);\n    document.addEventListener('focusout', handleFocus, eventOptions);\n    return () => {\n      prevVisualViewportRef.current = null;\n      document.removeEventListener('focusin', handleFocus, eventOptions);\n      document.removeEventListener('focusout', handleFocus, eventOptions);\n    };\n  }, [enabled, window, document]);\n  useEffect(function handleVirtualKeyboardOpened() {\n    if (!focusedEl || !window) {\n      return;\n    }\n    const handleResize = debounce(() => {\n      /* istanbul ignore if: нереалистичный кейс, проверяем в угоду TypeScript */if (prevVisualViewportRef.current === null) {\n        return;\n      }\n      const nextVisualViewport = getVisualViewport(window);\n      const {\n        offsetTop: prevOffsetTop,\n        height: prevHeight\n      } = prevVisualViewportRef.current;\n      const {\n        offsetTop: nextOffsetTop,\n        height: nextHeight\n      } = nextVisualViewport;\n      if (prevOffsetTop !== nextOffsetTop || prevHeight !== nextHeight) {\n        setKeyboardOpened(true);\n        prevVisualViewportRef.current = nextVisualViewport;\n      }\n    }, 100);\n    if (window.visualViewport) {\n      window.visualViewport.addEventListener('resize', handleResize);\n    } else {\n      window.addEventListener('resize', handleResize);\n    }\n    return function dispose() {\n      if (window.visualViewport) {\n        window.visualViewport.removeEventListener('resize', handleResize);\n      } else {\n        window.removeEventListener('resize', handleResize);\n      }\n    };\n  }, [focusedEl, window]);\n  useEffect(function preventWindowScrollIfKeyboardOpened() {\n    if (!keyboardOpened || !window) {\n      return;\n    }\n    const prevent = throttle(() => {\n      if (prevVisualViewportRef.current) {\n        window.scrollTo(0, prevVisualViewportRef.current.offsetTop);\n      }\n    }, 100);\n    window.addEventListener('scroll', prevent, {\n      passive: true\n    });\n    return function dispose() {\n      window.removeEventListener('scroll', prevent);\n    };\n  }, [keyboardOpened, window]);\n  return {\n    opened: keyboardOpened\n  };\n}","map":{"version":3,"names":["useEffect","useRef","useState","debounce","throttle","getVisualViewport","isHTMLContentEditableElement","useDOM","useVirtualKeyboardState","enabled","arguments","length","undefined","window","document","focusedEl","setFocusedEl","keyboardOpened","setKeyboardOpened","prevVisualViewportRef","handleFocusedEl","handleFocus","event","activeElement","target","patchedEvent","type","current","eventOptions","passive","capture","addEventListener","removeEventListener","handleVirtualKeyboardOpened","handleResize","nextVisualViewport","offsetTop","prevOffsetTop","height","prevHeight","nextOffsetTop","nextHeight","visualViewport","dispose","preventWindowScrollIfKeyboardOpened","prevent","scrollTo","opened"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/hooks/useVirtualKeyboardState.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { debounce, throttle } from '@vkontakte/vkjs';\nimport {\n  getVisualViewport,\n  isHTMLContentEditableElement,\n  useDOM,\n  type VisualViewport,\n} from '../lib/dom';\n\nexport type VirtualKeyboardState = { opened: boolean };\n\n/**\n * > см. [Неудобно работать с клавиатурой в ModalPage на iOS #3792](https://github.com/VKCOM/VKUI/discussions/3792)\n *\n * Для реализации модальных окон для тач-устройств, мы вынуждены отслеживать открытие виртуальной\n * клавиатуры. По состоянию `opened` компоненты должны временно блокировать дальнейшее взаимодействие\n * с ними. Например, отключить закрытие по свайпу, чтобы не мешать пользователю работать с полями\n * ввода.\n *\n * Помимо этого в **Safari** и в **Chrome Android** нам нужно отслеживать прокрутку области видимости\n * пользователем, т.к. в упомянутых браузерах, виртуальная клавиатура поднимает контент вверх\n * не изменяя её высоту. Из-за этого появляется возможность прокручивать `window`, что визуально\n * выглядит плохо. В хуке мы ловим фокус на поле ввода и далее, если это тач-устройство, то\n * отлавливаем события прокрутки на `window`, чтобы сохранять текущую её позицию через `scrollTo(x, y)`.\n *\n * **Troubleshooting**\n *\n * - в **Safari** и в **Chrome Android** шапка будет выдвигаться вверх – хаки с выставлением `offsetTop`\n *   из `VisualViewport` порождают reflow/repaint и прыгания контента;\n * - в **Safari** изменение высоты виртуальной клавиатуры, например, на выбор эмодзи, не поднимет\n *   `VisualViewport` из-за чего клавиатура может частично перекрыть элементы интерфейса.\n *\n * **Полезные ссылки**\n *\n * - [The Eccentric Ways of iOS Safari with the Keyboard](https://web.archive.org/web/20240920081850/https://blog.opendigerati.com/the-eccentric-ways-of-ios-safari-with-the-keyboard-b5aa3f34228d?gi=5411141a13e0)\n * - [Dealing with the visual viewport](https://web.archive.org/web/20240920082109/https://rdavis.io/articles/dealing-with-the-visual-viewport)\n * - [How to get the document height in iOS Safari when the on-screen keyboard is open](https://web.archive.org/web/20240920082743/https://martijnhols.nl/gists/how-to-get-document-height-ios-safari-osk)\n */\nexport function useVirtualKeyboardState(enabled = true): VirtualKeyboardState {\n  const { window, document } = useDOM();\n\n  const [focusedEl, setFocusedEl] = useState<Element | null>(null);\n  const [keyboardOpened, setKeyboardOpened] = useState(false);\n\n  const prevVisualViewportRef = useRef<VisualViewport | null>(null);\n\n  useEffect(\n    function handleFocusedEl() {\n      if (!enabled || !window || !document) {\n        return;\n      }\n\n      const handleFocus = (event: FocusEvent | true) => {\n        const activeElement = event === true ? document.activeElement : (event.target as Element);\n\n        if (isHTMLContentEditableElement(activeElement)) {\n          const patchedEvent = event === true ? { type: 'focusin' } : event;\n          switch (patchedEvent.type) {\n            case 'focusin':\n              prevVisualViewportRef.current = getVisualViewport(window);\n              setFocusedEl(activeElement);\n              break;\n            case 'focusout':\n              prevVisualViewportRef.current = null;\n              setKeyboardOpened(false);\n              setFocusedEl(null);\n              break;\n          }\n        }\n      };\n\n      /**\n       * У полей с autoFocus не отлавливаются события `focus`, для этого вызываем обработчик\n       * вручную, чтобы иметь хоть какое-то понимание происходящего.\n       */\n      handleFocus(true);\n\n      const eventOptions = { passive: true, capture: false };\n      document.addEventListener('focusin', handleFocus, eventOptions);\n      document.addEventListener('focusout', handleFocus, eventOptions);\n\n      return () => {\n        prevVisualViewportRef.current = null;\n        document.removeEventListener('focusin', handleFocus, eventOptions);\n        document.removeEventListener('focusout', handleFocus, eventOptions);\n      };\n    },\n    [enabled, window, document],\n  );\n\n  useEffect(\n    function handleVirtualKeyboardOpened() {\n      if (!focusedEl || !window) {\n        return;\n      }\n\n      const handleResize = debounce(() => {\n        /* istanbul ignore if: нереалистичный кейс, проверяем в угоду TypeScript */\n        if (prevVisualViewportRef.current === null) {\n          return;\n        }\n\n        const nextVisualViewport = getVisualViewport(window);\n\n        const { offsetTop: prevOffsetTop, height: prevHeight } = prevVisualViewportRef.current;\n        const { offsetTop: nextOffsetTop, height: nextHeight } = nextVisualViewport;\n        if (prevOffsetTop !== nextOffsetTop || prevHeight !== nextHeight) {\n          setKeyboardOpened(true);\n          prevVisualViewportRef.current = nextVisualViewport;\n        }\n      }, 100);\n\n      if (window.visualViewport) {\n        window.visualViewport.addEventListener('resize', handleResize);\n      } else {\n        window.addEventListener('resize', handleResize);\n      }\n\n      return function dispose() {\n        if (window.visualViewport) {\n          window.visualViewport.removeEventListener('resize', handleResize);\n        } else {\n          window.removeEventListener('resize', handleResize);\n        }\n      };\n    },\n    [focusedEl, window],\n  );\n\n  useEffect(\n    function preventWindowScrollIfKeyboardOpened() {\n      if (!keyboardOpened || !window) {\n        return;\n      }\n\n      const prevent = throttle(() => {\n        if (prevVisualViewportRef.current) {\n          window.scrollTo(0, prevVisualViewportRef.current.offsetTop);\n        }\n      }, 100);\n\n      window.addEventListener('scroll', prevent, { passive: true });\n\n      return function dispose() {\n        window.removeEventListener('scroll', prevent);\n      };\n    },\n    [keyboardOpened, window],\n  );\n\n  return { opened: keyboardOpened };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}