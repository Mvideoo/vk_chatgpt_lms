{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { canUseDOM } from \"@vkontakte/vkjs\";\nimport { rectToClientRect } from \"@vkontakte/vkui-floating-ui/core\";\nimport { getParentNode, getWindow, isElement, isHTMLElement, isLastTraversableNode, isOverflowElement } from \"@vkontakte/vkui-floating-ui/utils/dom\";\nexport { getWindow, getNodeScroll, isHTMLElement, isElement, getParentNode } from \"@vkontakte/vkui-floating-ui/utils/dom\";\nexport { canUseDOM, canUseEventListeners, onDOMLoaded } from \"@vkontakte/vkjs\";\n/* eslint-disable no-restricted-globals */\nconst getDOM = () => ({\n  window: canUseDOM ? window : undefined,\n  document: canUseDOM ? document : undefined\n});\n/* eslint-enable no-restricted-globals */\nexport const DOMContext = /*#__PURE__*/React.createContext(getDOM());\nexport const useDOM = () => {\n  return React.useContext(DOMContext);\n};\n/**\n * В случае, если используется DOMContext, при проверке 'node instanceOf Window' – Window может быть\n * другим объектом.\n */\nexport const isWindow = node => {\n  return node !== null && node !== undefined && 'navigator' in node;\n};\nexport const isBody = node => {\n  return node !== null && node !== undefined && 'tagName' in node && node.tagName === 'BODY';\n};\nexport const isDocumentElement = node => {\n  return node !== null && node !== undefined && 'tagName' in node && node.tagName === 'HTML';\n};\nexport function withDOM(Component) {\n  const WithDOM = props => {\n    const dom = useDOM();\n    return /*#__PURE__*/_jsx(Component, _object_spread({}, props, dom));\n  };\n  return WithDOM;\n}\nexport function blurActiveElement(document1) {\n  if (document1 && document1.activeElement) {\n    document1.activeElement.blur();\n  }\n}\nexport const TRANSFORM_DEFAULT_VALUES = ['none', 'initial', 'inherit', 'unset'];\nexport const WILL_CHANGE_DEFAULT_VALUES = ['auto', 'initial', 'inherit', 'unset'];\nexport function getTransformedParentCoords(element) {\n  let parentNode = element.parentNode;\n  while (parentNode !== null) {\n    if (isHTMLElement(parentNode)) {\n      const {\n        transform,\n        willChange\n      } = getComputedStyle(parentNode);\n      if (!TRANSFORM_DEFAULT_VALUES.includes(transform) || !WILL_CHANGE_DEFAULT_VALUES.includes(willChange)) {\n        const {\n          x,\n          y\n        } = parentNode.getBoundingClientRect();\n        return {\n          x,\n          y\n        };\n      }\n    }\n    parentNode = parentNode.parentNode;\n  }\n  return {\n    x: 0,\n    y: 0\n  };\n}\nexport const getBoundingClientRect = function (node) {\n  let isFixedStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const element = isWindow(node) ? node.document.documentElement : node;\n  const clientRect = element.getBoundingClientRect();\n  if (isDocumentElement(element)) {\n    /**\n    * Если на странице не используется `html, body { height: 100% }` (или `height: 100vh`), то\n    * `height`, полученный из `document.documentElement.getBoundingClientRect()`, будет возвращать\n    * `scrollHeight`, а не `clientHeight`. Поэтому перебиваем `height` на `clientHeight`.\n    */\n    clientRect.height = element.clientHeight;\n  }\n  let offsetX = 0;\n  let offsetY = 0;\n  if (isFixedStrategy) {\n    const {\n      x,\n      y\n    } = getTransformedParentCoords(element);\n    offsetX = x;\n    offsetY = y;\n  }\n  return rectToClientRect({\n    x: clientRect.left - offsetX,\n    y: clientRect.top - offsetY,\n    width: clientRect.width,\n    height: clientRect.height\n  });\n};\nexport const getRelativeBoundingClientRect = (parent, child) => {\n  const parentRect = getBoundingClientRect(parent);\n  const childRect = getBoundingClientRect(child);\n  return rectToClientRect({\n    x: childRect.left - parentRect.left,\n    y: childRect.top - parentRect.top,\n    width: childRect.width,\n    height: childRect.height\n  });\n};\nexport function getNearestOverflowAncestor(node, terminalNode) {\n  const parentNode = getParentNode(node);\n  if (terminalNode === parentNode) {\n    return null; /* [1] */\n  }\n  if (isLastTraversableNode(parentNode)) {\n    return getWindow(parentNode); /* [2] */\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode, terminalNode);\n}\nexport const getScrollHeight = node => {\n  return isWindow(node) ? node.document.documentElement.scrollHeight : node.scrollHeight;\n};\nexport const getScrollRect = node => {\n  const window1 = isElement(node) ? getWindow(node) : node;\n  const scrollElRect = getBoundingClientRect(node);\n  const edgeTop = window1.scrollY + scrollElRect.top;\n  const edgeBottom = edgeTop + scrollElRect.height;\n  const y = [edgeTop, edgeBottom];\n  return {\n    relative: scrollElRect,\n    edges: {\n      y\n    }\n  };\n};\nexport const getDocumentBody = node => getWindow(node).document.body;\nexport const getActiveElementByAnotherElement = el => el ? el.ownerDocument.activeElement : null;\nexport const contains = (parent, child) => {\n  return parent && child ? parent.contains(child) : false;\n};\nexport const getFirstTouchEventData = event => {\n  let dataRaw = function resolveData() {\n    switch (event.type) {\n      case 'touchend':\n        return event.changedTouches[0];\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchcancel':\n        return event.touches[0];\n      case 'mousedown':\n      case 'mousemove':\n      case 'mouseup':\n      case 'mouseleave':\n        return event;\n      default:\n        return {\n          screenX: 0,\n          screenY: 0,\n          clientX: 0,\n          clientY: 0,\n          pageX: 0,\n          pageY: 0\n        };\n    }\n  }();\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV === 'test') {\n    dataRaw = dataRaw ? dataRaw : {\n      screenX: 0,\n      screenY: 0,\n      clientX: 0,\n      clientY: 0,\n      pageX: 0,\n      pageY: 0\n    };\n  }\n  return {\n    screenX: dataRaw.screenX || 0,\n    screenY: dataRaw.screenY || 0,\n    clientX: dataRaw.clientX || 0,\n    clientY: dataRaw.clientY || 0,\n    pageX: dataRaw.pageX || 0,\n    pageY: dataRaw.pageY || 0\n  };\n};\n/**\n * ⚠️ В частности, необходимо для iOS 15. Начиная с этой версии в Safari добавили\n * pull-to-refresh. CSS св-во `overflow-behavior` появился только с iOS 16.\n *\n * Во вторую очередь, полезна блокированием скролла, чтобы пользователь дождался обновления\n * данных.\n */\nexport const initializeBrowserGesturePreventionEffect = window1 => {\n  const options = {\n    passive: false\n  };\n  const handleWindowTouchMove = event => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n  window1.document.documentElement.classList.add('vkui--disable-overscroll-behavior'); // eslint-disable-line no-restricted-properties\n  window1.addEventListener('touchmove', handleWindowTouchMove, options);\n  return function dispose() {\n    window1.document.documentElement.classList.remove('vkui--disable-overscroll-behavior'); // eslint-disable-line no-restricted-properties\n    window1.removeEventListener('touchmove', handleWindowTouchMove, options);\n  };\n};\nconst nonTextInputTypes = {\n  button: true,\n  submit: true,\n  reset: true,\n  color: true,\n  file: true,\n  image: true,\n  checkbox: true,\n  radio: true\n}; // prettier-ignore\nexport const isHTMLContentEditableElement = el => {\n  if (el === null) {\n    return false;\n  }\n  if (el.tagName === 'INPUT') {\n    // @ts-expect-error: TS2339 за счёт `tagName` удовлетворяемся, что это `HTMLInputElement`\n    return !nonTextInputTypes[el.type]; // prettier-ignore\n  }\n  return el.tagName === 'TEXTAREA' ||\n  // eslint-disable-next-line no-restricted-properties\n  el.closest('[contenteditable=true]') !== null;\n};\n/**\n * Фоллбек `visualViewport` для **Safari 12**.\n */\nexport function getVisualViewport(win) {\n  const result = {\n    offsetTop: 0,\n    offsetLeft: 0,\n    width: 0,\n    height: 0\n  };\n  if (win.visualViewport) {\n    const {\n      offsetTop,\n      offsetLeft,\n      width,\n      height\n    } = win.visualViewport;\n    result.offsetTop = Math.round(offsetTop);\n    result.offsetLeft = offsetLeft;\n    result.width = width;\n    result.height = Math.round(height);\n    return result;\n  }\n  // TODO[Safari@>=13] Удалить фоллбек\n  result.offsetTop = win.pageYOffset;\n  result.offsetLeft = win.pageXOffset;\n  result.width = win.innerWidth; // note: вызывает reflow в отличии от visualViewport\n  result.height = win.innerHeight; // note: вызывает reflow в отличии от visualViewport\n  return result;\n}\nexport const hasSelectionWithRangeType = node => {\n  const selection = getWindow(node).getSelection();\n  return selection ? selection.type === 'Range' : false;\n};","map":{"version":3,"names":["React","canUseDOM","rectToClientRect","getParentNode","getWindow","isElement","isHTMLElement","isLastTraversableNode","isOverflowElement","getNodeScroll","canUseEventListeners","onDOMLoaded","getDOM","window","undefined","document","DOMContext","createContext","useDOM","useContext","isWindow","node","isBody","tagName","isDocumentElement","withDOM","Component","WithDOM","props","dom","_jsx","_object_spread","blurActiveElement","document1","activeElement","blur","TRANSFORM_DEFAULT_VALUES","WILL_CHANGE_DEFAULT_VALUES","getTransformedParentCoords","element","parentNode","transform","willChange","getComputedStyle","includes","x","y","getBoundingClientRect","isFixedStrategy","arguments","length","documentElement","clientRect","height","clientHeight","offsetX","offsetY","left","top","width","getRelativeBoundingClientRect","parent","child","parentRect","childRect","getNearestOverflowAncestor","terminalNode","getScrollHeight","scrollHeight","getScrollRect","window1","scrollElRect","edgeTop","scrollY","edgeBottom","relative","edges","getDocumentBody","body","getActiveElementByAnotherElement","el","ownerDocument","contains","getFirstTouchEventData","event","dataRaw","resolveData","type","changedTouches","touches","screenX","screenY","clientX","clientY","pageX","pageY","process","env","NODE_ENV","initializeBrowserGesturePreventionEffect","options","passive","handleWindowTouchMove","preventDefault","stopPropagation","classList","add","addEventListener","dispose","remove","removeEventListener","nonTextInputTypes","button","submit","reset","color","file","image","checkbox","radio","isHTMLContentEditableElement","closest","getVisualViewport","win","result","offsetTop","offsetLeft","visualViewport","Math","round","pageYOffset","pageXOffset","innerWidth","innerHeight","hasSelectionWithRangeType","selection","getSelection"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/lib/dom.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { canUseDOM } from '@vkontakte/vkjs';\nimport { rectToClientRect } from '@vkontakte/vkui-floating-ui/core';\nimport {\n  getParentNode,\n  getWindow,\n  isElement,\n  isHTMLElement,\n  isLastTraversableNode,\n  isOverflowElement,\n} from '@vkontakte/vkui-floating-ui/utils/dom';\n\nexport {\n  getWindow,\n  getNodeScroll,\n  isHTMLElement,\n  isElement,\n  getParentNode,\n} from '@vkontakte/vkui-floating-ui/utils/dom';\n\nexport { canUseDOM, canUseEventListeners, onDOMLoaded } from '@vkontakte/vkjs';\nexport interface DOMContextInterface {\n  /**\n   * @ignore\n   */\n  window?: Window;\n  /**\n   * @ignore\n   */\n  document?: Document;\n}\n\nexport type DOMProps = DOMContextInterface;\n\n/* eslint-disable no-restricted-globals */\nconst getDOM = (): DOMContextInterface => ({\n  window: canUseDOM ? window : undefined,\n  document: canUseDOM ? document : undefined,\n});\n/* eslint-enable no-restricted-globals */\n\nexport const DOMContext: React.Context<DOMContextInterface> =\n  React.createContext<DOMContextInterface>(getDOM());\n\nexport const useDOM = (): DOMContextInterface => {\n  return React.useContext(DOMContext);\n};\n\n/**\n * В случае, если используется DOMContext, при проверке 'node instanceOf Window' – Window может быть\n * другим объектом.\n */\nexport const isWindow = (\n  node: Element | Window | VisualViewport | undefined | null,\n): node is Window => {\n  return node !== null && node !== undefined && 'navigator' in node;\n};\n\nexport const isBody = (\n  node: Element | Window | VisualViewport | undefined | null,\n): node is HTMLBodyElement => {\n  return node !== null && node !== undefined && 'tagName' in node && node.tagName === 'BODY';\n};\n\nexport const isDocumentElement = (\n  node: Element | Window | VisualViewport | undefined | null,\n): node is HTMLHtmlElement => {\n  return node !== null && node !== undefined && 'tagName' in node && node.tagName === 'HTML';\n};\n\nexport function withDOM<Props>(\n  Component: React.ComponentType<Props & DOMProps>,\n): React.ComponentType<Props> {\n  const WithDOM = (props: Props) => {\n    const dom = useDOM();\n    return <Component {...props} {...dom} />;\n  };\n  return WithDOM;\n}\n\nexport function blurActiveElement(document: Document | undefined): void {\n  if (document && document.activeElement) {\n    (document.activeElement as HTMLElement).blur();\n  }\n}\n\nexport const TRANSFORM_DEFAULT_VALUES: string[] = ['none', 'initial', 'inherit', 'unset'];\nexport const WILL_CHANGE_DEFAULT_VALUES: string[] = ['auto', 'initial', 'inherit', 'unset'];\nexport function getTransformedParentCoords(element: Element): {\n  x: number;\n  y: number;\n} {\n  let parentNode = element.parentNode;\n  while (parentNode !== null) {\n    if (isHTMLElement(parentNode)) {\n      const { transform, willChange } = getComputedStyle(parentNode);\n      if (\n        !TRANSFORM_DEFAULT_VALUES.includes(transform) ||\n        !WILL_CHANGE_DEFAULT_VALUES.includes(willChange)\n      ) {\n        const { x, y } = parentNode.getBoundingClientRect();\n        return { x, y };\n      }\n    }\n    parentNode = parentNode.parentNode;\n  }\n  return { x: 0, y: 0 };\n}\n\nexport const getBoundingClientRect = (node: Element | Window, isFixedStrategy = false) => {\n  const element = isWindow(node) ? node.document.documentElement : node;\n  const clientRect = element.getBoundingClientRect();\n\n  if (isDocumentElement(element)) {\n    /**\n     * Если на странице не используется `html, body { height: 100% }` (или `height: 100vh`), то\n     * `height`, полученный из `document.documentElement.getBoundingClientRect()`, будет возвращать\n     * `scrollHeight`, а не `clientHeight`. Поэтому перебиваем `height` на `clientHeight`.\n     */\n    clientRect.height = element.clientHeight;\n  }\n\n  let offsetX = 0;\n  let offsetY = 0;\n  if (isFixedStrategy) {\n    const { x, y } = getTransformedParentCoords(element);\n    offsetX = x;\n    offsetY = y;\n  }\n\n  return rectToClientRect({\n    x: clientRect.left - offsetX,\n    y: clientRect.top - offsetY,\n    width: clientRect.width,\n    height: clientRect.height,\n  }) as DOMRect;\n};\n\nexport const getRelativeBoundingClientRect = (parent: Element, child: Element) => {\n  const parentRect = getBoundingClientRect(parent);\n  const childRect = getBoundingClientRect(child);\n  return rectToClientRect({\n    x: childRect.left - parentRect.left,\n    y: childRect.top - parentRect.top,\n    width: childRect.width,\n    height: childRect.height,\n  }) as DOMRect;\n};\n\n/**\n * Переписанный `getNearestOverflowAncestor` из @floating-ui/utils/dom.\n *\n * [1] добавляем ноду, на которой нужно остановить рекурсию\n * [2] document.body подменяем на window, т.к. на document.body нельзя применить скролл.\n *\n * @link https://github.com/floating-ui/floating-ui/blob/%40floating-ui/dom%401.6.3/packages/utils/src/dom.ts#L143\n */\nexport function getNearestOverflowAncestor(node: Node): HTMLElement | Window | null;\nexport function getNearestOverflowAncestor(node: Node, terminalNode: Node): HTMLElement | null;\nexport function getNearestOverflowAncestor(node: Node, terminalNode?: any): any {\n  const parentNode = getParentNode(node);\n\n  if (terminalNode === parentNode) {\n    return null; /* [1] */\n  }\n\n  if (isLastTraversableNode(parentNode)) {\n    return getWindow(parentNode); /* [2] */\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode, terminalNode);\n}\n\nexport const getScrollHeight = (node: Element | Window): number => {\n  return isWindow(node) ? node.document.documentElement.scrollHeight : node.scrollHeight;\n};\n\nexport const getScrollRect = (\n  node: Element | Window,\n): {\n  relative: DOMRect;\n  edges: {\n    y: [number, number];\n  };\n} => {\n  const window = isElement(node) ? getWindow(node) : node;\n  const scrollElRect = getBoundingClientRect(node);\n\n  const edgeTop = window.scrollY + scrollElRect.top;\n  const edgeBottom = edgeTop + scrollElRect.height;\n  const y: [number, number] = [edgeTop, edgeBottom];\n\n  return {\n    relative: scrollElRect,\n    edges: { y },\n  };\n};\n\nexport const getDocumentBody = (node?: any): HTMLElement => getWindow(node).document.body;\n\nexport const getActiveElementByAnotherElement = (el: Element | null): Element | null =>\n  el ? el.ownerDocument.activeElement : null;\n\nexport const contains = (parent?: Element | null, child?: Element | null): boolean => {\n  return parent && child ? parent.contains(child) : false;\n};\n\nexport const getFirstTouchEventData = (\n  event: UIEvent | React.UIEvent<HTMLElement>,\n): {\n  screenX: number;\n  screenY: number;\n  clientX: number;\n  clientY: number;\n  pageX: number;\n  pageY: number;\n} => {\n  let dataRaw = (function resolveData() {\n    switch (event.type) {\n      case 'touchend':\n        return (event as TouchEvent).changedTouches[0];\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchcancel':\n        return (event as TouchEvent).touches[0];\n      case 'mousedown':\n      case 'mousemove':\n      case 'mouseup':\n      case 'mouseleave':\n        return event as MouseEvent;\n      default:\n        return { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0 };\n    }\n  })();\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV === 'test') {\n    dataRaw = dataRaw\n      ? dataRaw\n      : { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0 };\n  }\n  return {\n    screenX: dataRaw.screenX || 0,\n    screenY: dataRaw.screenY || 0,\n    clientX: dataRaw.clientX || 0,\n    clientY: dataRaw.clientY || 0,\n    pageX: dataRaw.pageX || 0,\n    pageY: dataRaw.pageY || 0,\n  };\n};\n\n/**\n * ⚠️ В частности, необходимо для iOS 15. Начиная с этой версии в Safari добавили\n * pull-to-refresh. CSS св-во `overflow-behavior` появился только с iOS 16.\n *\n * Во вторую очередь, полезна блокированием скролла, чтобы пользователь дождался обновления\n * данных.\n */\nexport const initializeBrowserGesturePreventionEffect = (window: Window): VoidFunction => {\n  const options: AddEventListenerOptions & EventListenerOptions = { passive: false };\n  const handleWindowTouchMove = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  window.document.documentElement.classList.add('vkui--disable-overscroll-behavior'); // eslint-disable-line no-restricted-properties\n  window.addEventListener('touchmove', handleWindowTouchMove, options);\n\n  return function dispose() {\n    window.document.documentElement.classList.remove('vkui--disable-overscroll-behavior'); // eslint-disable-line no-restricted-properties\n    window.removeEventListener('touchmove', handleWindowTouchMove, options);\n  };\n};\n\nconst nonTextInputTypes = { button: true, submit: true, reset: true, color: true, file: true, image: true, checkbox: true, radio: true }; // prettier-ignore\n\nexport const isHTMLContentEditableElement = (\n  el: Element | null,\n): el is HTMLInputElement | HTMLTextAreaElement | HTMLElement => {\n  if (el === null) {\n    return false;\n  }\n\n  if (el.tagName === 'INPUT') {\n    // @ts-expect-error: TS2339 за счёт `tagName` удовлетворяемся, что это `HTMLInputElement`\n    return !nonTextInputTypes[el.type]; // prettier-ignore\n  }\n\n  return (\n    el.tagName === 'TEXTAREA' ||\n    // eslint-disable-next-line no-restricted-properties\n    el.closest('[contenteditable=true]') !== null\n  );\n};\n\nexport type VisualViewport = {\n  offsetTop: number;\n  offsetLeft: number;\n  width: number;\n  height: number;\n};\n\n/**\n * Фоллбек `visualViewport` для **Safari 12**.\n */\nexport function getVisualViewport(win: Window): VisualViewport {\n  const result: VisualViewport = { offsetTop: 0, offsetLeft: 0, width: 0, height: 0 };\n  if (win.visualViewport) {\n    const { offsetTop, offsetLeft, width, height } = win.visualViewport;\n    result.offsetTop = Math.round(offsetTop);\n    result.offsetLeft = offsetLeft;\n    result.width = width;\n    result.height = Math.round(height);\n\n    return result;\n  }\n\n  // TODO[Safari@>=13] Удалить фоллбек\n  result.offsetTop = win.pageYOffset;\n  result.offsetLeft = win.pageXOffset;\n  result.width = win.innerWidth; // note: вызывает reflow в отличии от visualViewport\n  result.height = win.innerHeight; // note: вызывает reflow в отличии от visualViewport\n  return result;\n}\n\nexport const hasSelectionWithRangeType = (node: unknown) => {\n  const selection = getWindow(node).getSelection();\n  return selection ? selection.type === 'Range' : false;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}