{"ast":null,"code":"import { getRequiredValueByKey } from \"../../helpers/getValueByKey.js\";\nimport { SLIDE_THRESHOLD } from \"./constants.js\";\nexport const revertRtlValue = (n, isRtl) => {\n  return isRtl ? -n : n;\n};\nexport const isBigger = (a, b, isRtl) => isRtl ? a < b : a > b;\nexport const isBiggerOrEqual = (a, b, isRtl) => isRtl ? a <= b : a >= b;\nexport const isLower = (a, b, isRtl) => isRtl ? a > b : a < b;\nexport const isLowerOrEqual = (a, b, isRtl) => isRtl ? a >= b : a <= b;\n/*\n * Считает отступ слоя галереи во время драга\n * Используется только для looped=false галереи\n * так как только у нее есть пределы по краям\n */\nexport const validateIndent = function (slidesManager, value, isRtl) {\n  let bounded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var _slidesManager_max;\n  const localMax = (_slidesManager_max = slidesManager.max) !== null && _slidesManager_max !== void 0 ? _slidesManager_max : 0;\n  var _slidesManager_min;\n  const localMin = (_slidesManager_min = slidesManager.min) !== null && _slidesManager_min !== void 0 ? _slidesManager_min : 0;\n  const moreThanMax = isBigger(value, localMax, isRtl);\n  if (moreThanMax) {\n    if (bounded) {\n      return localMax;\n    } else {\n      return localMax + Number((value - localMax) / 3);\n    }\n  }\n  const lessThanMin = isLower(value, localMin, isRtl);\n  if (lessThanMin) {\n    if (bounded) {\n      return localMin;\n    } else {\n      return localMin + Number((value - localMin) / 3);\n    }\n  }\n  return value;\n};\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent(_ref) {\n  let {\n    targetIndex,\n    slidesManager,\n    isCenter,\n    looped = false,\n    isRtl = false\n  } = _ref;\n  if (!slidesManager.slides.length) {\n    return 0;\n  }\n  const targetSlide = slidesManager.slides[targetIndex];\n  if (targetSlide) {\n    const {\n      coordX,\n      width\n    } = targetSlide;\n    if (isCenter) {\n      return revertRtlValue(slidesManager.containerWidth / 2 - coordX - width / 2, isRtl);\n    }\n    const indent = revertRtlValue(-1 * coordX, isRtl);\n    return looped ? indent : validateIndent(slidesManager, indent, isRtl);\n  }\n  return 0;\n}\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(direction, slides, availableWidth) {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n  for (let i = startIndex; (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0; i += direction) {\n    const slideWidth = slides[i].width;\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n  return shiftedSlideIndexes;\n}\nfunction calculateLoopPoints(indexes, edge, slidesManager, containerWidth, isRtl) {\n  const {\n    contentSize,\n    slides,\n    snaps\n  } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n  return indexes.map(index => {\n    const initial = revertRtlValue(isStartEdge ? 0 : -contentSize, isRtl);\n    const altered = revertRtlValue(isStartEdge ? contentSize : 0, isRtl);\n    const snap = revertRtlValue(snaps[index], isRtl);\n    const firstSnap = revertRtlValue(snaps[0], isRtl);\n    const loopPoint = revertRtlValue(isStartEdge ? snap + containerWidth + offset : snap - slides[index].width + offset - firstSnap, isRtl);\n    return {\n      index,\n      target: currentLocation => isBiggerOrEqual(currentLocation, loopPoint, isRtl) ? initial : altered\n    };\n  });\n}\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(slidesManager, containerWidth) {\n  let isRtl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const {\n    slides,\n    snaps\n  } = slidesManager;\n  const firstSnap = revertRtlValue(snaps[0], isRtl);\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, firstSnap);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - firstSnap);\n  return [...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth, isRtl), ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth, isRtl)];\n}\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex(_ref2) {\n  let {\n    slides,\n    slideIndex,\n    currentShiftX,\n    currentShiftXDelta,\n    looped = false,\n    max = null,\n    isRtl = false\n  } = _ref2;\n  max = max !== null && max !== void 0 ? max : 0;\n  // Инвертируем значения смещения для RTL режима\n  const shift = revertRtlValue(currentShiftX + currentShiftXDelta - max, isRtl);\n  // Инвертируем направление для RTL режима\n  const direction = isLower(currentShiftXDelta, 0, isRtl) ? 1 : -1;\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val, item, index) => {\n    // Инвертируем координаты для RTL режима\n    const previousCoordX = slides[val].coordX;\n    const currentCoordX = item.coordX;\n    const previousValue = Math.abs(previousCoordX + shift);\n    const currentValue = Math.abs(currentCoordX + shift);\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    if (!looped) {\n      return direction < 0 ? Math.max(targetIndex, 0) : Math.min(targetIndex, slides.length - 1);\n    }\n    return direction < 0 ? (targetSlide + slides.length) % slides.length : targetSlide % slides.length;\n  }\n  return targetIndex;\n}\nexport const calcMin = _ref3 => {\n  let {\n    containerWidth = 0,\n    layerWidth = 0,\n    slides = [],\n    viewportOffsetWidth = 0,\n    isFullyVisible,\n    align,\n    isRtl = false\n  } = _ref3;\n  if (align !== 'center' && isFullyVisible) {\n    return 0;\n  }\n  const result = getRequiredValueByKey(align, {\n    left: () => containerWidth - layerWidth,\n    right: () => viewportOffsetWidth - layerWidth,\n    center: () => {\n      const {\n        coordX,\n        width\n      } = slides[slides.length - 1];\n      return containerWidth / 2 - coordX - width / 2;\n    }\n  })();\n  return revertRtlValue(result, isRtl);\n};\nexport const calcMax = _ref4 => {\n  let {\n    slides = [],\n    containerWidth = 0,\n    isCenterAlign,\n    isRtl = false\n  } = _ref4;\n  if (isCenterAlign && slides.length) {\n    const {\n      width,\n      coordX\n    } = slides[0];\n    const result = containerWidth / 2 - coordX - width / 2;\n    return revertRtlValue(result, isRtl);\n  }\n  return 0;\n};","map":{"version":3,"names":["getRequiredValueByKey","SLIDE_THRESHOLD","revertRtlValue","n","isRtl","isBigger","a","b","isBiggerOrEqual","isLower","isLowerOrEqual","validateIndent","slidesManager","value","bounded","arguments","length","undefined","_slidesManager_max","localMax","max","_slidesManager_min","localMin","min","moreThanMax","Number","lessThanMin","calculateIndent","_ref","targetIndex","isCenter","looped","slides","targetSlide","coordX","width","containerWidth","indent","getShiftedIndexes","direction","availableWidth","gap","shiftedSlideIndexes","startIndex","endIndex","i","slideWidth","push","calculateLoopPoints","indexes","edge","contentSize","snaps","isStartEdge","offset","map","index","initial","altered","snap","firstSnap","loopPoint","target","currentLocation","getLoopPoints","startShiftedIndexes","endShiftedIndexes","getTargetIndex","_ref2","slideIndex","currentShiftX","currentShiftXDelta","shift","reduce","val","item","previousCoordX","currentCoordX","previousValue","Math","abs","currentValue","calcMin","_ref3","layerWidth","viewportOffsetWidth","isFullyVisible","align","result","left","right","center","calcMax","_ref4","isCenterAlign"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/CarouselBase/helpers.ts"],"sourcesContent":["import { getRequiredValueByKey } from '../../helpers/getValueByKey';\nimport { type AlignType } from '../../types';\nimport { SLIDE_THRESHOLD } from './constants';\nimport {\n  type GallerySlidesState,\n  type LayoutState,\n  type LoopPoint,\n  type SlidesManagerState,\n} from './types';\n\nexport const revertRtlValue = (n: number, isRtl: boolean) => {\n  return isRtl ? -n : n;\n};\n\nexport const isBigger = (a: number, b: number, isRtl: boolean) => (isRtl ? a < b : a > b);\nexport const isBiggerOrEqual = (a: number, b: number, isRtl: boolean) => (isRtl ? a <= b : a >= b);\n\nexport const isLower = (a: number, b: number, isRtl: boolean) => (isRtl ? a > b : a < b);\nexport const isLowerOrEqual = (a: number, b: number, isRtl: boolean) => (isRtl ? a >= b : a <= b);\n\n/*\n * Считает отступ слоя галереи во время драга\n * Используется только для looped=false галереи\n * так как только у нее есть пределы по краям\n */\nexport const validateIndent = (\n  slidesManager: SlidesManagerState,\n  value: number,\n  isRtl: boolean,\n  bounded = true,\n) => {\n  const localMax = slidesManager.max ?? 0;\n  const localMin = slidesManager.min ?? 0;\n\n  const moreThanMax = isBigger(value, localMax, isRtl);\n  if (moreThanMax) {\n    if (bounded) {\n      return localMax;\n    } else {\n      return localMax + Number((value - localMax) / 3);\n    }\n  }\n\n  const lessThanMin = isLower(value, localMin, isRtl);\n  if (lessThanMin) {\n    if (bounded) {\n      return localMin;\n    } else {\n      return localMin + Number((value - localMin) / 3);\n    }\n  }\n\n  return value;\n};\n\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent({\n  targetIndex,\n  slidesManager,\n  isCenter,\n  looped = false,\n  isRtl = false,\n}: {\n  targetIndex: number;\n  slidesManager: SlidesManagerState;\n  isCenter: boolean;\n  looped: boolean;\n  isRtl: boolean;\n}): number {\n  if (!slidesManager.slides.length) {\n    return 0;\n  }\n\n  const targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    const { coordX, width } = targetSlide;\n\n    if (isCenter) {\n      return revertRtlValue(slidesManager.containerWidth / 2 - coordX - width / 2, isRtl);\n    }\n    const indent = revertRtlValue(-1 * coordX, isRtl);\n    return looped ? indent : validateIndent(slidesManager, indent, isRtl);\n  }\n\n  return 0;\n}\n\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(\n  direction: 1 | -1,\n  slides: GallerySlidesState[],\n  availableWidth: number,\n): number[] {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (\n    let i = startIndex;\n    (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0;\n    i += direction\n  ) {\n    const slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\n\nfunction calculateLoopPoints(\n  indexes: number[],\n  edge: 'start' | 'end',\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n  isRtl: boolean,\n): LoopPoint[] {\n  const { contentSize, slides, snaps } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n\n  return indexes.map((index) => {\n    const initial = revertRtlValue(isStartEdge ? 0 : -contentSize, isRtl);\n    const altered = revertRtlValue(isStartEdge ? contentSize : 0, isRtl);\n\n    const snap = revertRtlValue(snaps[index], isRtl);\n    const firstSnap = revertRtlValue(snaps[0], isRtl);\n    const loopPoint = revertRtlValue(\n      isStartEdge\n        ? snap + containerWidth + offset\n        : snap - slides[index].width + offset - firstSnap,\n      isRtl,\n    );\n\n    return {\n      index,\n      target: (currentLocation) =>\n        isBiggerOrEqual(currentLocation, loopPoint, isRtl) ? initial : altered,\n    };\n  });\n}\n\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n  isRtl = false,\n): LoopPoint[] {\n  const { slides, snaps } = slidesManager;\n  const firstSnap = revertRtlValue(snaps[0], isRtl);\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, firstSnap);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - firstSnap);\n\n  return [\n    ...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth, isRtl),\n    ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth, isRtl),\n  ];\n}\n\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex({\n  slides,\n  slideIndex,\n  currentShiftX,\n  currentShiftXDelta,\n  looped = false,\n  max = null,\n  isRtl = false,\n}: {\n  slides: GallerySlidesState[];\n  slideIndex: number;\n  currentShiftX: number;\n  currentShiftXDelta: number;\n  looped: boolean;\n  max?: number | null;\n  isRtl?: boolean;\n}): number {\n  max = max ?? 0;\n  // Инвертируем значения смещения для RTL режима\n  const shift = revertRtlValue(currentShiftX + currentShiftXDelta - max, isRtl);\n\n  // Инвертируем направление для RTL режима\n  const direction = isLower(currentShiftXDelta, 0, isRtl) ? 1 : -1;\n\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val: number, item: GallerySlidesState, index: number) => {\n    // Инвертируем координаты для RTL режима\n    const previousCoordX = slides[val].coordX;\n    const currentCoordX = item.coordX;\n\n    const previousValue = Math.abs(previousCoordX + shift);\n    const currentValue = Math.abs(currentCoordX + shift);\n\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    if (!looped) {\n      return direction < 0 ? Math.max(targetIndex, 0) : Math.min(targetIndex, slides.length - 1);\n    }\n\n    return direction < 0\n      ? (targetSlide + slides.length) % slides.length\n      : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}\n\ninterface CalcMin extends Partial<LayoutState> {\n  isRtl?: boolean;\n  align: AlignType;\n}\n\nexport const calcMin = ({\n  containerWidth = 0,\n  layerWidth = 0,\n  slides = [],\n  viewportOffsetWidth = 0,\n  isFullyVisible,\n  align,\n  isRtl = false,\n}: CalcMin): number => {\n  if (align !== 'center' && isFullyVisible) {\n    return 0;\n  }\n  const result = getRequiredValueByKey(align, {\n    left: () => containerWidth - layerWidth,\n    right: () => viewportOffsetWidth - layerWidth,\n    center: () => {\n      const { coordX, width } = slides[slides.length - 1];\n      return containerWidth / 2 - coordX - width / 2;\n    },\n  })();\n  return revertRtlValue(result, isRtl);\n};\n\ninterface CalcMax extends Partial<LayoutState> {\n  isRtl?: boolean;\n  isCenterAlign: boolean;\n}\n\nexport const calcMax = ({\n  slides = [],\n  containerWidth = 0,\n  isCenterAlign,\n  isRtl = false,\n}: CalcMax): number => {\n  if (isCenterAlign && slides.length) {\n    const { width, coordX } = slides[0];\n    const result = containerWidth / 2 - coordX - width / 2;\n    return revertRtlValue(result, isRtl);\n  }\n  return 0;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}