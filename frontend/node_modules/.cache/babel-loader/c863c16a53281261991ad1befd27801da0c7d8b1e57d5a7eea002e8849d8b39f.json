{"ast":null,"code":"'use client';\n\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames, noop } from \"@vkontakte/vkjs\";\nimport { withContext } from \"../../hoc/withContext.js\";\nimport { withPlatform } from \"../../hoc/withPlatform.js\";\nimport { canUseDOM, withDOM } from \"../../lib/dom.js\";\nimport { getNavId } from \"../../lib/getNavId.js\";\nimport { warnOnce } from \"../../lib/warnOnce.js\";\nimport { ScrollContext } from \"../AppRoot/ScrollContext.js\";\nimport { ConfigProviderContext } from \"../ConfigProvider/ConfigProviderContext.js\";\nimport { NavViewIdContext } from \"../NavIdContext/NavIdContext.js\";\nimport { NavTransitionProvider } from \"../NavTransitionContext/NavTransitionContext.js\";\nimport { NavTransitionDirectionProvider } from \"../NavTransitionDirectionContext/NavTransitionDirectionContext.js\";\nimport { SplitColContext } from \"../SplitCol/SplitColContext.js\";\nimport { Touch } from \"../Touch/Touch.js\";\nimport { getSwipeBackPredicates, hasHorizontalScrollableElementWithScrolledToLeft, swipeBackExcluded } from \"./utils.js\";\nconst warn = warnOnce('ViewInfinite');\nexport let scrollsCache = {};\nvar _React_Component;\nclass ViewInfiniteComponent extends (_React_Component = React.Component) {\n  get document() {\n    return this.props.document;\n  }\n  get window() {\n    return this.props.window;\n  }\n  get panels() {\n    return React.Children.toArray(this.props.children);\n  }\n  componentWillUnmount() {\n    const id = getNavId(this.props);\n    if (id) {\n      scrollsCache[id] = this.scrolls;\n    }\n    if (this.animationFinishTimeout) {\n      clearTimeout(this.animationFinishTimeout);\n    }\n  }\n  componentDidUpdate(prevProps, prevState) {\n    // Нужен переход\n    if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {\n      var _this_props_scroll;\n      let isBack = false;\n      if (this.props.isBackCheck) {\n        isBack = this.props.isBackCheck({\n          from: prevProps.activePanel,\n          to: this.props.activePanel\n        });\n      } else {\n        const firstLayerId = this.panels.map(panel => getNavId(panel.props, warn)).find(id => id === prevProps.activePanel || id === this.props.activePanel);\n        isBack = firstLayerId === this.props.activePanel;\n      }\n      this.blurActiveElement();\n      const prevScrolls = this.scrolls[prevProps.activePanel] || [];\n      const scrolls = _object_spread_props(_object_spread({}, this.scrolls), {\n        [prevProps.activePanel]: [...prevScrolls, (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll({\n          compensateKeyboardHeight: false\n        }).y]\n      });\n      this.scrolls = scrolls;\n      if (this.shouldDisableTransitionMotion()) {\n        this.flushTransition(prevProps.activePanel, isBack);\n      } else {\n        this.setState({\n          visiblePanels: [prevProps.activePanel, this.props.activePanel],\n          prevPanel: prevProps.activePanel,\n          nextPanel: this.props.activePanel,\n          activePanel: null,\n          animated: true,\n          isBack\n        });\n      }\n    }\n    // Закончилась анимация свайпа назад\n    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n      const nextPanel = this.state.swipeBackNextPanel;\n      const prevPanel = this.state.swipeBackPrevPanel;\n      let scrollPosition = undefined;\n      this.scrolls = _object_spread({}, this.scrolls);\n      if (prevPanel !== null) {\n        const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n        this.scrolls[prevPanel] = prevPanelScrolls;\n      }\n      if (nextPanel !== null) {\n        const newPanelScrolls = [...(this.scrolls[nextPanel] || [])];\n        scrollPosition = newPanelScrolls.pop();\n        this.scrolls[nextPanel] = newPanelScrolls;\n      }\n      this.setState({\n        swipeBackPrevPanel: null,\n        swipeBackNextPanel: null,\n        swipingBack: false,\n        swipeBackResult: null,\n        swipeBackStartX: 0,\n        swipeBackShift: 0,\n        activePanel: nextPanel,\n        visiblePanels: [nextPanel]\n      }, () => {\n        var _this_props_scroll;\n        (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, scrollPosition);\n        prevProps.onTransition && prevProps.onTransition({\n          isBack: true,\n          from: prevPanel,\n          to: nextPanel\n        });\n      });\n    }\n    // Началась анимация завершения свайпа назад.\n    if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n      this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);\n    }\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (prevState.swipeBackResult === 'fail' && !this.state.swipeBackResult && this.state.activePanel !== null) {\n      var _this_props_scroll1;\n      const newPanelScrolls = [...(this.scrolls[this.state.activePanel] || [])];\n      const scrollPosition = newPanelScrolls.pop();\n      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {\n        [this.state.activePanel]: newPanelScrolls\n      });\n      (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition);\n    }\n    // Закончился Safari свайп\n    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n      this.setState({\n        browserSwipe: false,\n        nextPanel: null,\n        prevPanel: null,\n        animated: false,\n        visiblePanels: [this.props.activePanel],\n        activePanel: this.props.activePanel\n      });\n    }\n  }\n  shouldDisableTransitionMotion() {\n    var _this_props_configProvider, _this_props_splitCol;\n    return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === 'vkcom';\n  }\n  disposeTransition() {\n    this.transitionDisposer();\n    this.transitionDisposer = noop;\n  }\n  waitTransitionFinish(elem, eventHandler) {\n    if (this.shouldDisableTransitionMotion()) {\n      this.disposeTransition();\n      this.transitionFinishTimeout = setTimeout(eventHandler);\n    } else if (elem) {\n      this.disposeTransition();\n      elem.addEventListener('transitionend', eventHandler);\n      this.transitionDisposer = () => {\n        elem.removeEventListener('transitionend', eventHandler);\n      };\n    } else {\n      if (this.transitionFinishTimeout) {\n        clearTimeout(this.transitionFinishTimeout);\n      }\n      this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === 'android' || this.props.platform === 'vkcom' ? 300 : 600);\n    }\n  }\n  blurActiveElement() {\n    var _this_document;\n    if (typeof this.window !== 'undefined' && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {\n      this.document.activeElement.blur();\n    }\n  }\n  pickPanel(id) {\n    if (id === null) {\n      return undefined;\n    }\n    return this.panelNodes[id];\n  }\n  flushTransition(prevPanel, isBack) {\n    const activePanel = this.props.activePanel;\n    const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n    const newPanelScrolls = [...(this.scrolls[activePanel] || [])];\n    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n    if (isBack) {\n      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {\n        [prevPanel]: prevPanelScrolls,\n        [activePanel]: newPanelScrolls\n      });\n    }\n    this.setState({\n      prevPanel: null,\n      nextPanel: null,\n      visiblePanels: [activePanel],\n      activePanel: activePanel,\n      animated: false,\n      isBack\n    }, () => {\n      var _this_props_scroll;\n      (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);\n      this.props.onTransition && this.props.onTransition({\n        isBack,\n        from: prevPanel,\n        to: activePanel\n      });\n    });\n  }\n  onSwipeBackSuccess() {\n    this.props.onSwipeBack && this.props.onSwipeBack();\n  }\n  onSwipeBackCancel() {\n    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n    this.setState({\n      swipeBackPrevPanel: null,\n      swipeBackNextPanel: null,\n      swipingBack: false,\n      swipeBackResult: null,\n      swipeBackStartX: 0,\n      swipeBackShift: 0\n    });\n  }\n  calcPanelSwipeStyles(panelId) {\n    if (!canUseDOM || !this.window) {\n      return {};\n    }\n    const isPrev = panelId === this.state.swipeBackPrevPanel;\n    const isNext = panelId === this.state.swipeBackNextPanel;\n    if (!isPrev && !isNext || this.state.swipeBackResult) {\n      return {};\n    }\n    let prevPanelTranslate = `${this.state.swipeBackShift}px`;\n    let nextPanelTranslate = `${-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2}%`;\n    let prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;\n    if (this.state.swipeBackResult) {\n      return isPrev ? {\n        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`\n      } : {};\n    }\n    if (isNext) {\n      return {\n        transform: `translate3d(${nextPanelTranslate}, 0, 0)`\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`\n      };\n    }\n    return {};\n  }\n  render() {\n    const _this_props = this.props,\n      {\n        platform,\n        activePanel: _1,\n        splitCol,\n        configProvider,\n        history,\n        id,\n        nav,\n        onTransition,\n        onSwipeBack,\n        onSwipeBackStart,\n        onSwipeBackCancel,\n        window,\n        document,\n        scroll,\n        isBackCheck,\n        className\n      } = _this_props,\n      restProps = _object_without_properties(_this_props, [\"platform\", \"activePanel\", \"splitCol\", \"configProvider\", \"history\", \"id\", \"nav\", \"onTransition\", \"onSwipeBack\", \"onSwipeBackStart\", \"onSwipeBackCancel\", \"window\", \"document\", \"scroll\", \"isBackCheck\", \"className\"]);\n    const {\n      prevPanel,\n      nextPanel,\n      activePanel,\n      isBack,\n      animated,\n      swipeBackPrevPanel,\n      swipeBackNextPanel,\n      swipeBackResult,\n      swipingBack\n    } = this.state;\n    const panels = this.panels.filter(panel => {\n      const panelId = getNavId(panel.props, warn);\n      return panelId !== undefined && this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;\n    }).sort(panel => {\n      const panelId = getNavId(panel.props, warn);\n      const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n      const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n      if (isNextPanel) {\n        return swipingBack || this.state.isBack ? -1 : 1;\n      }\n      if (isPrevPanel) {\n        return swipingBack || this.state.isBack ? 1 : -1;\n      }\n      return 0;\n    });\n    const disableAnimation = this.shouldDisableTransitionMotion();\n    const iOSSwipeBackSimulationEnabled = !disableAnimation && platform === 'ios' && (configProvider === null || configProvider === void 0 ? void 0 : configProvider.isWebView) && Boolean(onSwipeBack);\n    return /*#__PURE__*/_jsx(NavViewIdContext.Provider, {\n      value: id || nav,\n      children: /*#__PURE__*/_jsx(Touch, _object_spread_props(_object_spread({\n        Component: \"section\"\n      }, restProps), {\n        className: classNames(\"vkuiView__host\", platform === 'ios' && classNames(\"vkuiView__ios\", 'vkuiInternalView--ios'), !disableAnimation && this.state.animated && \"vkuiView__animated\", !disableAnimation && this.state.swipingBack && \"vkuiView__swipingBack\", disableAnimation && \"vkuiView__noMotion\", className),\n        onMoveX: iOSSwipeBackSimulationEnabled ? this.handleTouchMoveXForIOSSwipeBackSimulation : platform === 'ios' ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : undefined,\n        onEnd: iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : undefined,\n        children: /*#__PURE__*/_jsx(\"div\", {\n          className: \"vkuiView__panels\",\n          children: panels.map(panel => {\n            const panelId = getNavId(panel.props, warn);\n            const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n            const compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;\n            const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n            const scrollList = panelId && this.scrolls[panelId] || [];\n            const scroll = scrollList[scrollList.length - 1] || 0;\n            return /*#__PURE__*/_jsx(\"div\", {\n              className: classNames(\"vkuiView__panel\", panelId === activePanel && \"vkuiView__panelActive\", panelId === prevPanel && \"vkuiView__panelPrev\", panelId === nextPanel && \"vkuiView__panelNext\", panelId === swipeBackPrevPanel && \"vkuiView__panelSwipeBackPrev\", panelId === swipeBackNextPanel && \"vkuiView__panelSwipeBackNext\", swipeBackResult === 'success' && \"vkuiView__panelSwipeBackSuccess\", swipeBackResult === 'fail' && \"vkuiView__panelSwipeBackFailed\"),\n              onAnimationEnd: isTransitionTarget ? this.transitionEndHandler : undefined,\n              ref: el => {\n                panelId !== undefined && (this.panelNodes[panelId] = el);\n              },\n              style: this.calcPanelSwipeStyles(panelId),\n              children: /*#__PURE__*/_jsx(\"div\", {\n                className: \"vkuiView__panelIn\",\n                style: {\n                  marginTop: compensateScroll ? -scroll : undefined\n                },\n                children: /*#__PURE__*/_jsx(NavTransitionDirectionProvider, {\n                  isBack: swipingBack || isBack,\n                  children: /*#__PURE__*/_jsx(NavTransitionProvider, {\n                    entering: panelId === nextPanel || panelId === swipeBackNextPanel,\n                    children: panel\n                  })\n                })\n              })\n            }, panelId);\n          })\n        })\n      }))\n    });\n  }\n  constructor(props) {\n    super(props), _define_property(this, \"swipeBackPrevented\", false), _define_property(this, \"scrolls\", scrollsCache[getNavId(this.props, warn)] || {}), _define_property(this, \"transitionFinishTimeout\", undefined), _define_property(this, \"animationFinishTimeout\", undefined), _define_property(this, \"panelNodes\", {}), _define_property(this, \"transitionDisposer\", noop), _define_property(this, \"transitionEndHandler\", () => {\n      if (this.state.prevPanel !== null) {\n        this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));\n      }\n    }), _define_property(this, \"swipingBackTransitionEndHandler\", e => {\n      // indexOf because of vendor prefixes in old browsers\n      if (!e || e.propertyName.includes('transform') && e.target === this.pickPanel(this.state.swipeBackNextPanel)) {\n        switch (this.state.swipeBackResult) {\n          case 'fail':\n            this.onSwipeBackCancel();\n            break;\n          case 'success':\n            this.onSwipeBackSuccess();\n        }\n      }\n    }), _define_property(this, \"handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\", event => {\n      if (this.state.browserSwipe) {\n        return;\n      }\n      const {\n        swipeBackTriggered,\n        viewportStartEdgeTouched,\n        viewportEndEdgeTouched\n      } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);\n      if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n        this.setState({\n          browserSwipe: true\n        });\n      }\n    }), _define_property(this, \"handleTouchMoveXForIOSSwipeBackSimulation\", event => {\n      if (this.swipeBackPrevented || swipeBackExcluded(event)) {\n        return;\n      }\n      const {\n        swipedToOpposite,\n        swipeBackTriggered,\n        viewportStartEdgeTouched\n      } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);\n      if (this.state.animated && swipeBackTriggered) {\n        return;\n      }\n      if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {\n        if (swipedToOpposite) {\n          this.swipeBackPrevented = true;\n          return;\n        }\n        if (!swipeBackTriggered) {\n          return;\n        }\n        if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {\n          this.swipeBackPrevented = true;\n          return;\n        }\n        // Начался свайп назад\n        if (this.props.onSwipeBackStart) {\n          const payload = this.props.onSwipeBackStart(this.state.activePanel);\n          if (payload === 'prevent') {\n            this.swipeBackPrevented = true;\n            return;\n          }\n        }\n        if (this.state.activePanel !== null) {\n          var _this_props_scroll;\n          // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n          this.blurActiveElement();\n          const prevScrolls = this.scrolls[this.state.activePanel] || [];\n          this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {\n            [this.state.activePanel]: [...prevScrolls, (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y]\n          });\n        }\n        this.setState({\n          swipingBack: true,\n          swipeBackStartX: event.startX,\n          swipeBackPrevPanel: this.state.activePanel,\n          swipeBackNextPanel: this.props.history.slice(-2)[0]\n        });\n      }\n      if (this.state.swipingBack) {\n        if (event.shiftX < 0) {\n          this.setState({\n            swipeBackShift: 0\n          });\n        } else if (event.shiftX > this.window.innerWidth - this.state.swipeBackStartX) {\n          this.setState({\n            swipeBackShift: this.window.innerWidth\n          });\n        } else {\n          this.setState({\n            swipeBackShift: event.shiftX\n          });\n        }\n      }\n    }), _define_property(this, \"handleTouchEndForIOSSwipeBackSimulation\", event => {\n      this.swipeBackPrevented = false;\n      if (this.state.swipingBack && this.window) {\n        const speed = this.state.swipeBackShift / event.duration * 1000;\n        if (this.state.swipeBackShift === 0) {\n          this.onSwipeBackCancel();\n        } else if (this.state.swipeBackShift >= this.window.innerWidth) {\n          this.onSwipeBackSuccess();\n        } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {\n          this.setState({\n            swipeBackResult: 'success'\n          });\n        } else {\n          this.setState({\n            swipeBackResult: 'fail'\n          });\n        }\n      }\n    });\n    this.state = {\n      animated: false,\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n      swipingBack: undefined,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n      browserSwipe: false\n    };\n  }\n}\n_define_property(ViewInfiniteComponent, \"defaultProps\", {\n  history: []\n});\nexport const ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, 'splitCol'), ConfigProviderContext, 'configProvider'), ScrollContext, 'scroll');","map":{"version":3,"names":["React","classNames","noop","withContext","withPlatform","canUseDOM","withDOM","getNavId","warnOnce","ScrollContext","ConfigProviderContext","NavViewIdContext","NavTransitionProvider","NavTransitionDirectionProvider","SplitColContext","Touch","getSwipeBackPredicates","hasHorizontalScrollableElementWithScrolledToLeft","swipeBackExcluded","warn","scrollsCache","_React_Component","ViewInfiniteComponent","Component","document","props","window","panels","Children","toArray","children","componentWillUnmount","id","scrolls","animationFinishTimeout","clearTimeout","componentDidUpdate","prevProps","prevState","activePanel","swipingBack","browserSwipe","_this_props_scroll","isBack","isBackCheck","from","to","firstLayerId","map","panel","find","blurActiveElement","prevScrolls","_object_spread_props","_object_spread","scroll","getScroll","compensateKeyboardHeight","y","shouldDisableTransitionMotion","flushTransition","setState","visiblePanels","prevPanel","nextPanel","animated","state","swipeBackNextPanel","swipeBackPrevPanel","scrollPosition","undefined","prevPanelScrolls","slice","newPanelScrolls","pop","swipeBackResult","swipeBackStartX","swipeBackShift","scrollTo","onTransition","waitTransitionFinish","pickPanel","swipingBackTransitionEndHandler","_this_props_scroll1","_this_props_configProvider","_this_props_splitCol","configProvider","transitionMotionEnabled","splitCol","animate","platform","disposeTransition","transitionDisposer","elem","eventHandler","transitionFinishTimeout","setTimeout","addEventListener","removeEventListener","_this_document","activeElement","blur","panelNodes","onSwipeBackSuccess","onSwipeBack","onSwipeBackCancel","calcPanelSwipeStyles","panelId","isPrev","isNext","prevPanelTranslate","nextPanelTranslate","innerWidth","prevPanelShadow","boxShadow","transform","render","_this_props","_1","history","nav","onSwipeBackStart","className","restProps","_object_without_properties","filter","includes","sort","isPrevPanel","isNextPanel","disableAnimation","iOSSwipeBackSimulationEnabled","isWebView","Boolean","_jsx","Provider","value","onMoveX","handleTouchMoveXForIOSSwipeBackSimulation","handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext","onEnd","handleTouchEndForIOSSwipeBackSimulation","compensateScroll","isTransitionTarget","scrollList","length","onAnimationEnd","transitionEndHandler","ref","el","style","marginTop","entering","constructor","_define_property","e","propertyName","target","event","swipeBackTriggered","viewportStartEdgeTouched","viewportEndEdgeTouched","startX","shiftX","swipeBackPrevented","swipedToOpposite","originalEvent","payload","speed","duration","ViewInfinite"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/View/ViewInfinite.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { withContext } from '../../hoc/withContext';\nimport { withPlatform } from '../../hoc/withPlatform';\nimport { canUseDOM, type DOMProps, withDOM } from '../../lib/dom';\nimport { getNavId, type NavIdProps } from '../../lib/getNavId';\nimport { warnOnce } from '../../lib/warnOnce';\nimport type { HasPlatform, HTMLAttributesWithRootRef } from '../../types';\nimport { ScrollContext, type ScrollContextInterface } from '../AppRoot/ScrollContext';\nimport {\n  ConfigProviderContext,\n  type ConfigProviderContextInterface,\n} from '../ConfigProvider/ConfigProviderContext';\nimport { NavViewIdContext } from '../NavIdContext/NavIdContext';\nimport { NavTransitionProvider } from '../NavTransitionContext/NavTransitionContext';\nimport { NavTransitionDirectionProvider } from '../NavTransitionDirectionContext/NavTransitionDirectionContext';\nimport { SplitColContext, type SplitColContextProps } from '../SplitCol/SplitColContext';\nimport { type CustomTouchEvent, Touch } from '../Touch/Touch';\nimport {\n  getSwipeBackPredicates,\n  hasHorizontalScrollableElementWithScrolledToLeft,\n  swipeBackExcluded,\n} from './utils';\nimport styles from './View.module.css';\n\nconst warn = warnOnce('ViewInfinite');\n\ninterface Scrolls {\n  [index: string]: Array<number | undefined>;\n}\n\ninterface ViewsScrolls {\n  [index: string]: Scrolls;\n}\n\ntype TransitionEventHandler = (e?: TransitionEvent) => void;\n\nexport let scrollsCache: ViewsScrolls = {};\n\nexport type TransitionParams = { from: string | null; to: string | null };\n\nexport interface ViewInfiniteProps\n  extends HTMLAttributesWithRootRef<HTMLElement>,\n    HasPlatform,\n    NavIdProps {\n  activePanel: string;\n  onTransition?: (params: TransitionParams & { isBack: boolean }) => void;\n  /**\n   * callback свайпа назад\n   */\n  onSwipeBack?: () => void;\n  /**\n   * callback начала анимации свайпа назад.\n   */\n  onSwipeBackStart?: (activePanel: string | null) => void | 'prevent';\n  /**\n   * callback завершения анимации отмененного пользователем свайпа\n   */\n  onSwipeBackCancel?: () => void;\n  history?: string[];\n  isBackCheck?: (params: TransitionParams) => boolean;\n  /**\n   * @ignore\n   */\n  splitCol?: SplitColContextProps;\n  /**\n   * @ignore\n   */\n  configProvider?: ConfigProviderContextInterface;\n  /**\n   * @ignore\n   */\n  scroll?: ScrollContextInterface;\n}\n\nexport interface ViewInfiniteState {\n  animated: boolean;\n\n  visiblePanels: Array<string | null>;\n  activePanel: string | null;\n  isBack?: boolean;\n  prevPanel: string | null;\n  nextPanel: string | null;\n\n  swipingBack?: boolean;\n  swipeBackStartX: number;\n  swipeBackShift: number;\n  swipeBackNextPanel: string | null;\n  swipeBackPrevPanel: string | null;\n  swipeBackResult: 'success' | 'fail' | null;\n\n  browserSwipe: boolean;\n}\n\nclass ViewInfiniteComponent extends React.Component<\n  ViewInfiniteProps & DOMProps,\n  ViewInfiniteState\n> {\n  constructor(props: ViewInfiniteProps) {\n    super(props);\n\n    this.state = {\n      animated: false,\n\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n\n      swipingBack: undefined,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n\n      browserSwipe: false,\n    };\n  }\n\n  static defaultProps: Partial<ViewInfiniteProps> = {\n    history: [],\n  };\n\n  private swipeBackPrevented = false;\n  private scrolls = scrollsCache[getNavId(this.props, warn) as string] || {};\n  private transitionFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n  private readonly animationFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n\n  get document() {\n    return this.props.document;\n  }\n\n  get window() {\n    return this.props.window;\n  }\n\n  get panels() {\n    return React.Children.toArray(this.props.children) as Array<React.ReactElement<NavIdProps>>;\n  }\n\n  panelNodes: { [id: string]: HTMLDivElement | null } = {};\n\n  componentWillUnmount() {\n    const id = getNavId(this.props);\n    if (id) {\n      scrollsCache[id] = this.scrolls;\n    }\n    if (this.animationFinishTimeout) {\n      clearTimeout(this.animationFinishTimeout);\n    }\n  }\n\n  componentDidUpdate(prevProps: ViewInfiniteProps, prevState: ViewInfiniteState) {\n    // Нужен переход\n    if (\n      prevProps.activePanel !== this.props.activePanel &&\n      !prevState.swipingBack &&\n      !prevState.browserSwipe\n    ) {\n      let isBack = false;\n\n      if (this.props.isBackCheck) {\n        isBack = this.props.isBackCheck({\n          from: prevProps.activePanel,\n          to: this.props.activePanel,\n        });\n      } else {\n        const firstLayerId = this.panels\n          .map((panel) => getNavId(panel.props, warn))\n          .find((id) => id === prevProps.activePanel || id === this.props.activePanel);\n        isBack = firstLayerId === this.props.activePanel;\n      }\n\n      this.blurActiveElement();\n\n      const prevScrolls = this.scrolls[prevProps.activePanel] || [];\n      const scrolls = {\n        ...this.scrolls,\n        [prevProps.activePanel]: [\n          ...prevScrolls,\n          this.props.scroll?.getScroll({ compensateKeyboardHeight: false }).y,\n        ],\n      };\n      this.scrolls = scrolls;\n\n      if (this.shouldDisableTransitionMotion()) {\n        this.flushTransition(prevProps.activePanel, isBack);\n      } else {\n        this.setState({\n          visiblePanels: [prevProps.activePanel, this.props.activePanel],\n          prevPanel: prevProps.activePanel,\n          nextPanel: this.props.activePanel,\n          activePanel: null,\n          animated: true,\n          isBack,\n        });\n      }\n    }\n\n    // Закончилась анимация свайпа назад\n    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n      const nextPanel = this.state.swipeBackNextPanel;\n      const prevPanel = this.state.swipeBackPrevPanel;\n      let scrollPosition: undefined | number = undefined;\n\n      this.scrolls = {\n        ...this.scrolls,\n      };\n\n      if (prevPanel !== null) {\n        const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n        this.scrolls[prevPanel] = prevPanelScrolls;\n      }\n      if (nextPanel !== null) {\n        const newPanelScrolls = [...(this.scrolls[nextPanel] || [])];\n        scrollPosition = newPanelScrolls.pop();\n        this.scrolls[nextPanel] = newPanelScrolls;\n      }\n\n      this.setState(\n        {\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel],\n        },\n        () => {\n          this.props.scroll?.scrollTo(0, scrollPosition);\n          prevProps.onTransition &&\n            prevProps.onTransition({\n              isBack: true,\n              from: prevPanel,\n              to: nextPanel,\n            });\n        },\n      );\n    }\n\n    // Началась анимация завершения свайпа назад.\n    if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n      this.waitTransitionFinish(\n        this.pickPanel(this.state.swipeBackNextPanel),\n        this.swipingBackTransitionEndHandler,\n      );\n    }\n\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (\n      prevState.swipeBackResult === 'fail' &&\n      !this.state.swipeBackResult &&\n      this.state.activePanel !== null\n    ) {\n      const newPanelScrolls = [...(this.scrolls[this.state.activePanel] || [])];\n      const scrollPosition = newPanelScrolls.pop();\n      this.scrolls = {\n        ...this.scrolls,\n        [this.state.activePanel]: newPanelScrolls,\n      };\n\n      this.props.scroll?.scrollTo(0, scrollPosition);\n    }\n\n    // Закончился Safari свайп\n    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n      this.setState({\n        browserSwipe: false,\n        nextPanel: null,\n        prevPanel: null,\n        animated: false,\n        visiblePanels: [this.props.activePanel],\n        activePanel: this.props.activePanel,\n      });\n    }\n  }\n\n  shouldDisableTransitionMotion(): boolean {\n    return (\n      this.props.configProvider?.transitionMotionEnabled === false ||\n      !this.props.splitCol?.animate ||\n      this.props.platform === 'vkcom'\n    );\n  }\n\n  private transitionDisposer = noop;\n\n  private disposeTransition() {\n    this.transitionDisposer();\n    this.transitionDisposer = noop;\n  }\n\n  waitTransitionFinish(\n    elem: HTMLElement | null | undefined,\n    eventHandler: TransitionEventHandler,\n  ): void {\n    if (this.shouldDisableTransitionMotion()) {\n      this.disposeTransition();\n      this.transitionFinishTimeout = setTimeout(eventHandler);\n    } else if (elem) {\n      this.disposeTransition();\n      elem.addEventListener('transitionend', eventHandler);\n      this.transitionDisposer = () => {\n        elem.removeEventListener('transitionend', eventHandler);\n      };\n    } else {\n      if (this.transitionFinishTimeout) {\n        clearTimeout(this.transitionFinishTimeout);\n      }\n      this.transitionFinishTimeout = setTimeout(\n        eventHandler,\n        this.props.platform === 'android' || this.props.platform === 'vkcom' ? 300 : 600,\n      );\n    }\n  }\n\n  blurActiveElement(): void {\n    if (typeof this.window !== 'undefined' && this.document?.activeElement) {\n      (this.document.activeElement as HTMLElement).blur();\n    }\n  }\n\n  pickPanel(id: string | null) {\n    if (id === null) {\n      return undefined;\n    }\n    return this.panelNodes[id];\n  }\n\n  flushTransition(prevPanel: string, isBack: boolean) {\n    const activePanel = this.props.activePanel;\n\n    const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n    const newPanelScrolls = [...(this.scrolls[activePanel] || [])];\n    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n    if (isBack) {\n      this.scrolls = {\n        ...this.scrolls,\n        [prevPanel]: prevPanelScrolls,\n        [activePanel]: newPanelScrolls,\n      };\n    }\n\n    this.setState(\n      {\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack,\n      },\n      () => {\n        this.props.scroll?.scrollTo(0, isBack ? scrollPosition : 0);\n        this.props.onTransition &&\n          this.props.onTransition({ isBack, from: prevPanel, to: activePanel });\n      },\n    );\n  }\n\n  transitionEndHandler = (): void => {\n    if (this.state.prevPanel !== null) {\n      this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));\n    }\n  };\n\n  swipingBackTransitionEndHandler = (e?: TransitionEvent): void => {\n    // indexOf because of vendor prefixes in old browsers\n    if (\n      !e ||\n      (e.propertyName.includes('transform') &&\n        e.target === this.pickPanel(this.state.swipeBackNextPanel))\n    ) {\n      switch (this.state.swipeBackResult) {\n        case 'fail':\n          this.onSwipeBackCancel();\n          break;\n        case 'success':\n          this.onSwipeBackSuccess();\n      }\n    }\n  };\n\n  onSwipeBackSuccess(): void {\n    this.props.onSwipeBack && this.props.onSwipeBack();\n  }\n\n  onSwipeBackCancel(): void {\n    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n    this.setState({\n      swipeBackPrevPanel: null,\n      swipeBackNextPanel: null,\n      swipingBack: false,\n      swipeBackResult: null,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n    });\n  }\n\n  handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event: CustomTouchEvent) => {\n    if (this.state.browserSwipe) {\n      return;\n    }\n    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, this.window!.innerWidth);\n\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      this.setState({ browserSwipe: true });\n    }\n  };\n\n  handleTouchMoveXForIOSSwipeBackSimulation = (event: CustomTouchEvent) => {\n    if (this.swipeBackPrevented || swipeBackExcluded(event)) {\n      return;\n    }\n\n    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, this.window!.innerWidth);\n\n    if (this.state.animated && swipeBackTriggered) {\n      return;\n    }\n\n    if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {\n      if (swipedToOpposite) {\n        this.swipeBackPrevented = true;\n        return;\n      }\n\n      if (!swipeBackTriggered) {\n        return;\n      }\n\n      if (\n        !viewportStartEdgeTouched &&\n        hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target as HTMLElement)\n      ) {\n        this.swipeBackPrevented = true;\n        return;\n      }\n      // Начался свайп назад\n      if (this.props.onSwipeBackStart) {\n        const payload = this.props.onSwipeBackStart(this.state.activePanel);\n        if (payload === 'prevent') {\n          this.swipeBackPrevented = true;\n          return;\n        }\n      }\n\n      if (this.state.activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        this.blurActiveElement();\n        const prevScrolls = this.scrolls[this.state.activePanel] || [];\n        this.scrolls = {\n          ...this.scrolls,\n          [this.state.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n        };\n      }\n\n      this.setState({\n        swipingBack: true,\n        swipeBackStartX: event.startX,\n        swipeBackPrevPanel: this.state.activePanel,\n        swipeBackNextPanel: this.props.history.slice(-2)[0],\n      });\n    }\n\n    if (this.state.swipingBack) {\n      if (event.shiftX < 0) {\n        this.setState({ swipeBackShift: 0 });\n      } else if (event.shiftX > this.window!.innerWidth - this.state.swipeBackStartX) {\n        this.setState({ swipeBackShift: this.window!.innerWidth });\n      } else {\n        this.setState({ swipeBackShift: event.shiftX });\n      }\n    }\n  };\n\n  handleTouchEndForIOSSwipeBackSimulation = (event: CustomTouchEvent) => {\n    this.swipeBackPrevented = false;\n\n    if (this.state.swipingBack && this.window) {\n      const speed = (this.state.swipeBackShift / event.duration) * 1000;\n      if (this.state.swipeBackShift === 0) {\n        this.onSwipeBackCancel();\n      } else if (this.state.swipeBackShift >= this.window.innerWidth) {\n        this.onSwipeBackSuccess();\n      } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {\n        this.setState({ swipeBackResult: 'success' });\n      } else {\n        this.setState({ swipeBackResult: 'fail' });\n      }\n    }\n  };\n\n  calcPanelSwipeStyles(panelId: string | undefined): React.CSSProperties {\n    if (!canUseDOM || !this.window) {\n      return {};\n    }\n\n    const isPrev = panelId === this.state.swipeBackPrevPanel;\n    const isNext = panelId === this.state.swipeBackNextPanel;\n\n    if ((!isPrev && !isNext) || this.state.swipeBackResult) {\n      return {};\n    }\n\n    let prevPanelTranslate = `${this.state.swipeBackShift}px`;\n    let nextPanelTranslate = `${\n      -50 + (this.state.swipeBackShift * 100) / this.window.innerWidth / 2\n    }%`;\n    let prevPanelShadow =\n      (0.3 * (this.window.innerWidth - this.state.swipeBackShift)) / this.window.innerWidth;\n\n    if (this.state.swipeBackResult) {\n      return isPrev ? { boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})` } : {};\n    }\n\n    if (isNext) {\n      return {\n        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`,\n      };\n    }\n\n    return {};\n  }\n\n  render() {\n    const {\n      platform,\n      activePanel: _1,\n      splitCol,\n      configProvider,\n      history,\n      id,\n      nav,\n      onTransition,\n      onSwipeBack,\n      onSwipeBackStart,\n      onSwipeBackCancel,\n      window,\n      document,\n      scroll,\n      isBackCheck,\n      className,\n      ...restProps\n    } = this.props;\n    const {\n      prevPanel,\n      nextPanel,\n      activePanel,\n      isBack,\n      animated,\n      swipeBackPrevPanel,\n      swipeBackNextPanel,\n      swipeBackResult,\n      swipingBack,\n    } = this.state;\n\n    const panels = this.panels\n      .filter((panel) => {\n        const panelId = getNavId(panel.props, warn);\n\n        return (\n          (panelId !== undefined && this.state.visiblePanels.includes(panelId)) ||\n          panelId === swipeBackPrevPanel ||\n          panelId === swipeBackNextPanel\n        );\n      })\n      .sort((panel) => {\n        const panelId = getNavId(panel.props, warn);\n        const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n\n        if (isNextPanel) {\n          return swipingBack || this.state.isBack ? -1 : 1;\n        }\n\n        if (isPrevPanel) {\n          return swipingBack || this.state.isBack ? 1 : -1;\n        }\n\n        return 0;\n      });\n\n    const disableAnimation = this.shouldDisableTransitionMotion();\n    const iOSSwipeBackSimulationEnabled =\n      !disableAnimation && platform === 'ios' && configProvider?.isWebView && Boolean(onSwipeBack);\n\n    return (\n      <NavViewIdContext.Provider value={id || nav}>\n        <Touch\n          Component=\"section\"\n          {...restProps}\n          className={classNames(\n            styles.host,\n            platform === 'ios' && classNames(styles.ios, 'vkuiInternalView--ios'),\n            !disableAnimation && this.state.animated && styles.animated,\n            !disableAnimation && this.state.swipingBack && styles.swipingBack,\n            disableAnimation && styles.noMotion,\n            className,\n          )}\n          onMoveX={\n            iOSSwipeBackSimulationEnabled\n              ? this.handleTouchMoveXForIOSSwipeBackSimulation\n              : platform === 'ios'\n                ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\n                : undefined\n          }\n          onEnd={\n            iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : undefined\n          }\n        >\n          <div className={styles.panels}>\n            {panels.map((panel) => {\n              const panelId = getNavId(panel.props, warn);\n              const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n              const compensateScroll =\n                isPrev || panelId === swipeBackNextPanel || (panelId === nextPanel && isBack);\n              const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n              const scrollList = (panelId && this.scrolls[panelId]) || [];\n              const scroll = scrollList[scrollList.length - 1] || 0;\n\n              return (\n                <div\n                  className={classNames(\n                    styles.panel,\n                    panelId === activePanel && styles.panelActive,\n                    panelId === prevPanel && styles.panelPrev,\n                    panelId === nextPanel && styles.panelNext,\n                    panelId === swipeBackPrevPanel && styles.panelSwipeBackPrev,\n                    panelId === swipeBackNextPanel && styles.panelSwipeBackNext,\n                    swipeBackResult === 'success' && styles.panelSwipeBackSuccess,\n                    swipeBackResult === 'fail' && styles.panelSwipeBackFailed,\n                  )}\n                  onAnimationEnd={isTransitionTarget ? this.transitionEndHandler : undefined}\n                  ref={(el) => {\n                    panelId !== undefined && (this.panelNodes[panelId] = el);\n                  }}\n                  style={this.calcPanelSwipeStyles(panelId)}\n                  key={panelId}\n                >\n                  <div\n                    className={styles.panelIn}\n                    style={{ marginTop: compensateScroll ? -scroll : undefined }}\n                  >\n                    <NavTransitionDirectionProvider isBack={swipingBack || isBack}>\n                      <NavTransitionProvider\n                        entering={panelId === nextPanel || panelId === swipeBackNextPanel}\n                      >\n                        {panel}\n                      </NavTransitionProvider>\n                    </NavTransitionDirectionProvider>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </Touch>\n      </NavViewIdContext.Provider>\n    );\n  }\n}\n\nexport const ViewInfinite: React.FC<ViewInfiniteProps> = withContext(\n  withContext(\n    withContext(\n      withPlatform(withDOM<ViewInfiniteProps>(ViewInfiniteComponent)),\n      SplitColContext,\n      'splitCol',\n    ),\n    ConfigProviderContext,\n    'configProvider',\n  ),\n  ScrollContext,\n  'scroll',\n);\n"],"mappings":"AAAA;;;;;;;AAEA,YAAYA,KAAA,MAAW;AACvB,SAASC,UAAU,EAAEC,IAAI,QAAQ;AACjC,SAASC,WAAW,QAAQ;AAC5B,SAASC,YAAY,QAAQ;AAC7B,SAASC,SAAS,EAAiBC,OAAO,QAAQ;AAClD,SAASC,QAAQ,QAAyB;AAC1C,SAASC,QAAQ,QAAQ;AAEzB,SAASC,aAAa,QAAqC;AAC3D,SACEC,qBAAqB,QAEhB;AACP,SAASC,gBAAgB,QAAQ;AACjC,SAASC,qBAAqB,QAAQ;AACtC,SAASC,8BAA8B,QAAQ;AAC/C,SAASC,eAAe,QAAmC;AAC3D,SAAgCC,KAAK,QAAQ;AAC7C,SACEC,sBAAsB,EACtBC,gDAAgD,EAChDC,iBAAiB,QACZ;AAGP,MAAMC,IAAA,GAAOX,QAAA,CAAS;AAYtB,OAAO,IAAIY,YAAA,GAA6B,CAAC;IAyDLC,gBAAA;AAApC,MAAMC,qBAAA,UAA8BD,gBAAA,GAAArB,KAAA,CAAMuB,SAAS,EAAD;EAoChD,IAAIC,SAAA,EAAW;IACb,OAAO,IAAI,CAACC,KAAK,CAACD,QAAQ;EAC5B;EAEA,IAAIE,OAAA,EAAS;IACX,OAAO,IAAI,CAACD,KAAK,CAACC,MAAM;EAC1B;EAEA,IAAIC,OAAA,EAAS;IACX,OAAO3B,KAAA,CAAM4B,QAAQ,CAACC,OAAO,CAAC,IAAI,CAACJ,KAAK,CAACK,QAAQ;EACnD;EAIAC,qBAAA,EAAuB;IACrB,MAAMC,EAAA,GAAKzB,QAAA,CAAS,IAAI,CAACkB,KAAK;IAC9B,IAAIO,EAAA,EAAI;MACNZ,YAAY,CAACY,EAAA,CAAG,GAAG,IAAI,CAACC,OAAO;IACjC;IACA,IAAI,IAAI,CAACC,sBAAsB,EAAE;MAC/BC,YAAA,CAAa,IAAI,CAACD,sBAAsB;IAC1C;EACF;EAEAE,mBAAmBC,SAA4B,EAAEC,SAA4B,EAAE;IAC7E;IACA,IACED,SAAA,CAAUE,WAAW,KAAK,IAAI,CAACd,KAAK,CAACc,WAAW,IAChD,CAACD,SAAA,CAAUE,WAAW,IACtB,CAACF,SAAA,CAAUG,YAAY,EACvB;UAsBIC,kBAAA;MArBJ,IAAIC,MAAA,GAAS;MAEb,IAAI,IAAI,CAAClB,KAAK,CAACmB,WAAW,EAAE;QAC1BD,MAAA,GAAS,IAAI,CAAClB,KAAK,CAACmB,WAAW,CAAC;UAC9BC,IAAA,EAAMR,SAAA,CAAUE,WAAW;UAC3BO,EAAA,EAAI,IAAI,CAACrB,KAAK,CAACc;QACjB;MACF,OAAO;QACL,MAAMQ,YAAA,GAAe,IAAI,CAACpB,MAAM,CAC7BqB,GAAG,CAAEC,KAAA,IAAU1C,QAAA,CAAS0C,KAAA,CAAMxB,KAAK,EAAEN,IAAA,GACrC+B,IAAI,CAAElB,EAAA,IAAOA,EAAA,KAAOK,SAAA,CAAUE,WAAW,IAAIP,EAAA,KAAO,IAAI,CAACP,KAAK,CAACc,WAAW;QAC7EI,MAAA,GAASI,YAAA,KAAiB,IAAI,CAACtB,KAAK,CAACc,WAAW;MAClD;MAEA,IAAI,CAACY,iBAAiB;MAEtB,MAAMC,WAAA,GAAc,IAAI,CAACnB,OAAO,CAACI,SAAA,CAAUE,WAAW,CAAC,IAAI,EAAE;MAC7D,MAAMN,OAAA,GAAUoB,oBAAA,CAAAC,cAAA,KACX,IAAI,CAACrB,OAAO;QACf,CAACI,SAAA,CAAUE,WAAW,GAAG,C,GACpBa,WAAA,E,CACHV,kBAAA,OAAI,CAACjB,KAAK,CAAC8B,MAAM,cAAjBb,kBAAA,uBAAAA,kBAAA,CAAmBc,SAAS,CAAC;UAAEC,wBAAA,EAA0B;QAAM,GAAGC,CAAC;;MAGvE,IAAI,CAACzB,OAAO,GAAGA,OAAA;MAEf,IAAI,IAAI,CAAC0B,6BAA6B,IAAI;QACxC,IAAI,CAACC,eAAe,CAACvB,SAAA,CAAUE,WAAW,EAAEI,MAAA;MAC9C,OAAO;QACL,IAAI,CAACkB,QAAQ,CAAC;UACZC,aAAA,EAAe,CAACzB,SAAA,CAAUE,WAAW,EAAE,IAAI,CAACd,KAAK,CAACc,WAAW,CAAC;UAC9DwB,SAAA,EAAW1B,SAAA,CAAUE,WAAW;UAChCyB,SAAA,EAAW,IAAI,CAACvC,KAAK,CAACc,WAAW;UACjCA,WAAA,EAAa;UACb0B,QAAA,EAAU;UACVtB;QACF;MACF;IACF;IAEA;IACA,IAAIN,SAAA,CAAUE,WAAW,KAAK,IAAI,CAACd,KAAK,CAACc,WAAW,IAAID,SAAA,CAAUE,WAAW,EAAE;MAC7E,MAAMwB,SAAA,GAAY,IAAI,CAACE,KAAK,CAACC,kBAAkB;MAC/C,MAAMJ,SAAA,GAAY,IAAI,CAACG,KAAK,CAACE,kBAAkB;MAC/C,IAAIC,cAAA,GAAqCC,SAAA;MAEzC,IAAI,CAACrC,OAAO,GAAGqB,cAAA,KACV,IAAI,CAACrB,OAAO;MAGjB,IAAI8B,SAAA,KAAc,MAAM;QACtB,MAAMQ,gBAAA,GAAmB,C,IAAK,IAAI,CAACtC,OAAO,CAAC8B,SAAA,CAAU,IAAI,EAAE,EAAE,CAACS,KAAK,CAAC,GAAG,CAAC;QACxE,IAAI,CAACvC,OAAO,CAAC8B,SAAA,CAAU,GAAGQ,gBAAA;MAC5B;MACA,IAAIP,SAAA,KAAc,MAAM;QACtB,MAAMS,eAAA,GAAkB,C,IAAK,IAAI,CAACxC,OAAO,CAAC+B,SAAA,CAAU,IAAI,EAAE,EAAE;QAC5DK,cAAA,GAAiBI,eAAA,CAAgBC,GAAG;QACpC,IAAI,CAACzC,OAAO,CAAC+B,SAAA,CAAU,GAAGS,eAAA;MAC5B;MAEA,IAAI,CAACZ,QAAQ,CACX;QACEO,kBAAA,EAAoB;QACpBD,kBAAA,EAAoB;QACpB3B,WAAA,EAAa;QACbmC,eAAA,EAAiB;QACjBC,eAAA,EAAiB;QACjBC,cAAA,EAAgB;QAChBtC,WAAA,EAAayB,SAAA;QACbF,aAAA,EAAe,CAACE,SAAA;MAClB,GACA;YACEtB,kBAAA;SAAAA,kBAAA,OAAI,CAACjB,KAAK,CAAC8B,MAAM,cAAjBb,kBAAA,uBAAAA,kBAAA,CAAmBoC,QAAQ,CAAC,GAAGT,cAAA;QAC/BhC,SAAA,CAAU0C,YAAY,IACpB1C,SAAA,CAAU0C,YAAY,CAAC;UACrBpC,MAAA,EAAQ;UACRE,IAAA,EAAMkB,SAAA;UACNjB,EAAA,EAAIkB;QACN;MACJ;IAEJ;IAEA;IACA,IAAI,CAAC1B,SAAA,CAAUqC,eAAe,IAAI,IAAI,CAACT,KAAK,CAACS,eAAe,EAAE;MAC5D,IAAI,CAACK,oBAAoB,CACvB,IAAI,CAACC,SAAS,CAAC,IAAI,CAACf,KAAK,CAACC,kBAAkB,GAC5C,IAAI,CAACe,+BAA+B;IAExC;IAEA;IACA,IACE5C,SAAA,CAAUqC,eAAe,KAAK,UAC9B,CAAC,IAAI,CAACT,KAAK,CAACS,eAAe,IAC3B,IAAI,CAACT,KAAK,CAAC3B,WAAW,KAAK,MAC3B;UAQA4C,mBAAA;MAPA,MAAMV,eAAA,GAAkB,C,IAAK,IAAI,CAACxC,OAAO,CAAC,IAAI,CAACiC,KAAK,CAAC3B,WAAW,CAAC,IAAI,EAAE,EAAE;MACzE,MAAM8B,cAAA,GAAiBI,eAAA,CAAgBC,GAAG;MAC1C,IAAI,CAACzC,OAAO,GAAGoB,oBAAA,CAAAC,cAAA,KACV,IAAI,CAACrB,OAAO;QACf,CAAC,IAAI,CAACiC,KAAK,CAAC3B,WAAW,GAAGkC;;OAG5BU,mBAAA,OAAI,CAAC1D,KAAK,CAAC8B,MAAM,cAAjB4B,mBAAA,uBAAAA,mBAAA,CAAmBL,QAAQ,CAAC,GAAGT,cAAA;IACjC;IAEA;IACA,IAAIhC,SAAA,CAAUE,WAAW,KAAK,IAAI,CAACd,KAAK,CAACc,WAAW,IAAI,IAAI,CAAC2B,KAAK,CAACzB,YAAY,EAAE;MAC/E,IAAI,CAACoB,QAAQ,CAAC;QACZpB,YAAA,EAAc;QACduB,SAAA,EAAW;QACXD,SAAA,EAAW;QACXE,QAAA,EAAU;QACVH,aAAA,EAAe,CAAC,IAAI,CAACrC,KAAK,CAACc,WAAW,CAAC;QACvCA,WAAA,EAAa,IAAI,CAACd,KAAK,CAACc;MAC1B;IACF;EACF;EAEAoB,8BAAA,EAAyC;QAErCyB,0BAAA,EACCC,oBAAA;IAFH,OACE,EAAAD,0BAAA,OAAI,CAAC3D,KAAK,CAAC6D,cAAc,cAAzBF,0BAAA,uBAAAA,0BAAA,CAA2BG,uBAAuB,MAAK,SACvD,GAACF,oBAAA,OAAI,CAAC5D,KAAK,CAAC+D,QAAQ,cAAnBH,oBAAA,uBAAAA,oBAAA,CAAqBI,OAAO,KAC7B,IAAI,CAAChE,KAAK,CAACiE,QAAQ,KAAK;EAE5B;EAIQC,kBAAA,EAAoB;IAC1B,IAAI,CAACC,kBAAkB;IACvB,IAAI,CAACA,kBAAkB,GAAG1F,IAAA;EAC5B;EAEA8E,qBACEa,IAAoC,EACpCC,YAAoC,EAC9B;IACN,IAAI,IAAI,CAACnC,6BAA6B,IAAI;MACxC,IAAI,CAACgC,iBAAiB;MACtB,IAAI,CAACI,uBAAuB,GAAGC,UAAA,CAAWF,YAAA;IAC5C,OAAO,IAAID,IAAA,EAAM;MACf,IAAI,CAACF,iBAAiB;MACtBE,IAAA,CAAKI,gBAAgB,CAAC,iBAAiBH,YAAA;MACvC,IAAI,CAACF,kBAAkB,GAAG;QACxBC,IAAA,CAAKK,mBAAmB,CAAC,iBAAiBJ,YAAA;MAC5C;IACF,OAAO;MACL,IAAI,IAAI,CAACC,uBAAuB,EAAE;QAChC5D,YAAA,CAAa,IAAI,CAAC4D,uBAAuB;MAC3C;MACA,IAAI,CAACA,uBAAuB,GAAGC,UAAA,CAC7BF,YAAA,EACA,IAAI,CAACrE,KAAK,CAACiE,QAAQ,KAAK,aAAa,IAAI,CAACjE,KAAK,CAACiE,QAAQ,KAAK,UAAU,MAAM;IAEjF;EACF;EAEAvC,kBAAA,EAA0B;QACkBgD,cAAA;IAA1C,IAAI,OAAO,IAAI,CAACzE,MAAM,KAAK,iBAAeyE,cAAA,OAAI,CAAC3E,QAAQ,cAAb2E,cAAA,uBAAAA,cAAA,CAAeC,aAAa,GAAE;MACrE,IAAI,CAAC5E,QAAQ,CAAC4E,aAAa,CAAiBC,IAAI;IACnD;EACF;EAEApB,UAAUjD,EAAiB,EAAE;IAC3B,IAAIA,EAAA,KAAO,MAAM;MACf,OAAOsC,SAAA;IACT;IACA,OAAO,IAAI,CAACgC,UAAU,CAACtE,EAAA,CAAG;EAC5B;EAEA4B,gBAAgBG,SAAiB,EAAEpB,MAAe,EAAE;IAClD,MAAMJ,WAAA,GAAc,IAAI,CAACd,KAAK,CAACc,WAAW;IAE1C,MAAMgC,gBAAA,GAAmB,C,IAAK,IAAI,CAACtC,OAAO,CAAC8B,SAAA,CAAU,IAAI,EAAE,EAAE,CAACS,KAAK,CAAC,GAAG,CAAC;IACxE,MAAMC,eAAA,GAAkB,C,IAAK,IAAI,CAACxC,OAAO,CAACM,WAAA,CAAY,IAAI,EAAE,EAAE;IAC9D,MAAM8B,cAAA,GAAiB1B,MAAA,GAAS8B,eAAA,CAAgBC,GAAG,KAAK;IACxD,IAAI/B,MAAA,EAAQ;MACV,IAAI,CAACV,OAAO,GAAGoB,oBAAA,CAAAC,cAAA,KACV,IAAI,CAACrB,OAAO;QACf,CAAC8B,SAAA,GAAYQ,gBAAA;QACb,CAAChC,WAAA,GAAckC;;IAEnB;IAEA,IAAI,CAACZ,QAAQ,CACX;MACEE,SAAA,EAAW;MACXC,SAAA,EAAW;MACXF,aAAA,EAAe,CAACvB,WAAA,CAAY;MAC5BA,WAAA,EAAaA,WAAA;MACb0B,QAAA,EAAU;MACVtB;IACF,GACA;UACED,kBAAA;OAAAA,kBAAA,OAAI,CAACjB,KAAK,CAAC8B,MAAM,cAAjBb,kBAAA,uBAAAA,kBAAA,CAAmBoC,QAAQ,CAAC,GAAGnC,MAAA,GAAS0B,cAAA,GAAiB;MACzD,IAAI,CAAC5C,KAAK,CAACsD,YAAY,IACrB,IAAI,CAACtD,KAAK,CAACsD,YAAY,CAAC;QAAEpC,MAAA;QAAQE,IAAA,EAAMkB,SAAA;QAAWjB,EAAA,EAAIP;MAAY;IACvE;EAEJ;EAyBAgE,mBAAA,EAA2B;IACzB,IAAI,CAAC9E,KAAK,CAAC+E,WAAW,IAAI,IAAI,CAAC/E,KAAK,CAAC+E,WAAW;EAClD;EAEAC,kBAAA,EAA0B;IACxB,IAAI,CAAChF,KAAK,CAACgF,iBAAiB,IAAI,IAAI,CAAChF,KAAK,CAACgF,iBAAiB;IAC5D,IAAI,CAAC5C,QAAQ,CAAC;MACZO,kBAAA,EAAoB;MACpBD,kBAAA,EAAoB;MACpB3B,WAAA,EAAa;MACbmC,eAAA,EAAiB;MACjBC,eAAA,EAAiB;MACjBC,cAAA,EAAgB;IAClB;EACF;EAkGA6B,qBAAqBC,OAA2B,EAAuB;IACrE,IAAI,CAACtG,SAAA,IAAa,CAAC,IAAI,CAACqB,MAAM,EAAE;MAC9B,OAAO,CAAC;IACV;IAEA,MAAMkF,MAAA,GAASD,OAAA,KAAY,IAAI,CAACzC,KAAK,CAACE,kBAAkB;IACxD,MAAMyC,MAAA,GAASF,OAAA,KAAY,IAAI,CAACzC,KAAK,CAACC,kBAAkB;IAExD,IAAI,CAAEyC,MAAA,IAAU,CAACC,MAAA,IAAW,IAAI,CAAC3C,KAAK,CAACS,eAAe,EAAE;MACtD,OAAO,CAAC;IACV;IAEA,IAAImC,kBAAA,GAAqB,GAAG,IAAI,CAAC5C,KAAK,CAACW,cAAc,IAAI;IACzD,IAAIkC,kBAAA,GAAqB,GACvB,CAAC,KAAK,IAAK,CAAC7C,KAAK,CAACW,cAAc,GAAG,MAAO,IAAI,CAACnD,MAAM,CAACsF,UAAU,GAAG,IAClE;IACH,IAAIC,eAAA,GACF,GAAC,IAAO,IAAI,CAACvF,MAAM,CAACsF,UAAU,GAAG,IAAI,CAAC9C,KAAK,CAACW,cAAc,CAAD,GAAM,IAAI,CAACnD,MAAM,CAACsF,UAAU;IAEvF,IAAI,IAAI,CAAC9C,KAAK,CAACS,eAAe,EAAE;MAC9B,OAAOiC,MAAA,GAAS;QAAEM,SAAA,EAAW,6BAA6BD,eAAA;MAAmB,IAAI,CAAC;IACpF;IAEA,IAAIJ,MAAA,EAAQ;MACV,OAAO;QACLM,SAAA,EAAW,eAAeJ,kBAAA;MAC5B;IACF;IACA,IAAIH,MAAA,EAAQ;MACV,OAAO;QACLO,SAAA,EAAW,eAAeL,kBAAA,SAA2B;QACrDI,SAAA,EAAW,6BAA6BD,eAAA;MAC1C;IACF;IAEA,OAAO,CAAC;EACV;EAEAG,OAAA,EAAS;IACP,MAkBIC,WAAA,OAAI,CAAC5F,KAAK;MAlBR;QACJiE,QAAQ;QACRnD,WAAA,EAAa+E,EAAE;QACf9B,QAAQ;QACRF,cAAc;QACdiC,OAAO;QACPvF,EAAE;QACFwF,GAAG;QACHzC,YAAY;QACZyB,WAAW;QACXiB,gBAAgB;QAChBhB,iBAAiB;QACjB/E,MAAM;QACNF,QAAQ;QACR+B,MAAM;QACNX,WAAW;QACX8E;MAAS,CAEV,GAAGL,WAAA;MADCM,SAAA,GAAAC,0BAAA,CACDP,WAAA,GAjBF,YACA,eACA,YACA,kBACA,WACA,MACA,OACA,gBACA,eACA,oBACA,qBACA,UACA,YACA,UACA,eACA,Y;IAGF,MAAM;MACJtD,SAAS;MACTC,SAAS;MACTzB,WAAW;MACXI,MAAM;MACNsB,QAAQ;MACRG,kBAAkB;MAClBD,kBAAkB;MAClBQ,eAAe;MACfnC;IAAW,CACZ,GAAG,IAAI,CAAC0B,KAAK;IAEd,MAAMvC,MAAA,GAAS,IAAI,CAACA,MAAM,CACvBkG,MAAM,CAAE5E,KAAA;MACP,MAAM0D,OAAA,GAAUpG,QAAA,CAAS0C,KAAA,CAAMxB,KAAK,EAAEN,IAAA;MAEtC,OACEwF,OAAC,KAAYrC,SAAA,IAAa,IAAI,CAACJ,KAAK,CAACJ,aAAa,CAACgE,QAAQ,CAACnB,OAAA,KAC5DA,OAAA,KAAYvC,kBAAA,IACZuC,OAAA,KAAYxC,kBAAA;IAEhB,GACC4D,IAAI,CAAE9E,KAAA;MACL,MAAM0D,OAAA,GAAUpG,QAAA,CAAS0C,KAAA,CAAMxB,KAAK,EAAEN,IAAA;MACtC,MAAM6G,WAAA,GAAcrB,OAAA,KAAY5C,SAAA,IAAa4C,OAAA,KAAYvC,kBAAA;MACzD,MAAM6D,WAAA,GAActB,OAAA,KAAY3C,SAAA,IAAa2C,OAAA,KAAYxC,kBAAA;MAEzD,IAAI8D,WAAA,EAAa;QACf,OAAOzF,WAAA,IAAe,IAAI,CAAC0B,KAAK,CAACvB,MAAM,GAAG,CAAC,IAAI;MACjD;MAEA,IAAIqF,WAAA,EAAa;QACf,OAAOxF,WAAA,IAAe,IAAI,CAAC0B,KAAK,CAACvB,MAAM,GAAG,IAAI,CAAC;MACjD;MAEA,OAAO;IACT;IAEF,MAAMuF,gBAAA,GAAmB,IAAI,CAACvE,6BAA6B;IAC3D,MAAMwE,6BAAA,GACJ,CAACD,gBAAA,IAAoBxC,QAAA,KAAa,UAASJ,cAAA,aAAAA,cAAA,uBAAAA,cAAA,CAAgB8C,SAAS,KAAIC,OAAA,CAAQ7B,WAAA;IAElF,oBACE8B,IAAA,CAAC3H,gBAAA,CAAiB4H,QAAQ;MAACC,KAAA,EAAOxG,EAAA,IAAMwF,GAAA;gBACtC,aAAAc,IAAA,CAACvH,KAAA,EAAAsC,oBAAA,CAAAC,cAAA;QACC/B,SAAA,EAAU;SACNoG,SAAA;QACJD,SAAA,EAAWzH,UAAA,mBAETyF,QAAA,KAAa,SAASzF,UAAA,kBAAuB,0BAC7C,CAACiI,gBAAA,IAAoB,IAAI,CAAChE,KAAK,CAACD,QAAQ,0BACxC,CAACiE,gBAAA,IAAoB,IAAI,CAAChE,KAAK,CAAC1B,WAAW,6BAC3C0F,gBAAA,0BACAR,SAAA;QAEFe,OAAA,EACEN,6BAAA,GACI,IAAI,CAACO,yCAAyC,GAC9ChD,QAAA,KAAa,QACX,IAAI,CAACiD,gDAAgD,GACrDrE,SAAA;QAERsE,KAAA,EACET,6BAAA,GAAgC,IAAI,CAACU,uCAAuC,GAAGvE,SAAA;kBAGjF,aAAAgE,IAAA,CAAC;UAAIZ,SAAS;oBACX/F,MAAA,CAAOqB,GAAG,CAAEC,KAAA;YACX,MAAM0D,OAAA,GAAUpG,QAAA,CAAS0C,KAAA,CAAMxB,KAAK,EAAEN,IAAA;YACtC,MAAMyF,MAAA,GAASD,OAAA,KAAY5C,SAAA,IAAa4C,OAAA,KAAYvC,kBAAA;YACpD,MAAM0E,gBAAA,GACJlC,MAAA,IAAUD,OAAA,KAAYxC,kBAAA,IAAuBwC,OAAA,KAAY3C,SAAA,IAAarB,MAAA;YACxE,MAAMoG,kBAAA,GAAqB9E,QAAA,IAAY0C,OAAA,MAAahE,MAAA,GAASoB,SAAA,GAAYC,SAAQ;YACjF,MAAMgF,UAAA,GAAarC,OAAC,IAAW,IAAI,CAAC1E,OAAO,CAAC0E,OAAA,CAAQ,IAAK,EAAE;YAC3D,MAAMpD,MAAA,GAASyF,UAAU,CAACA,UAAA,CAAWC,MAAM,GAAG,EAAE,IAAI;YAEpD,oBACEX,IAAA,CAAC;cACCZ,SAAA,EAAWzH,UAAA,oBAET0G,OAAA,KAAYpE,WAAA,6BACZoE,OAAA,KAAY5C,SAAA,2BACZ4C,OAAA,KAAY3C,SAAA,2BACZ2C,OAAA,KAAYvC,kBAAA,oCACZuC,OAAA,KAAYxC,kBAAA,oCACZQ,eAAA,KAAoB,gDACpBA,eAAA,KAAoB;cAEtBuE,cAAA,EAAgBH,kBAAA,GAAqB,IAAI,CAACI,oBAAoB,GAAG7E,SAAA;cACjE8E,GAAA,EAAMC,EAAA;gBACJ1C,OAAA,KAAYrC,SAAA,KAAc,IAAI,CAACgC,UAAU,CAACK,OAAA,CAAQ,GAAG0C,EAAC;cACxD;cACAC,KAAA,EAAO,IAAI,CAAC5C,oBAAoB,CAACC,OAAA;wBAGjC,aAAA2B,IAAA,CAAC;gBACCZ,SAAS;gBACT4B,KAAA,EAAO;kBAAEC,SAAA,EAAWT,gBAAA,GAAmB,CAACvF,MAAA,GAASe;gBAAU;0BAE3D,aAAAgE,IAAA,CAACzH,8BAAA;kBAA+B8B,MAAA,EAAQH,WAAA,IAAeG,MAAA;4BACrD,aAAA2F,IAAA,CAAC1H,qBAAA;oBACC4I,QAAA,EAAU7C,OAAA,KAAY3C,SAAA,IAAa2C,OAAA,KAAYxC,kBAAA;8BAE9ClB;;;;eAVF0D,OAAA;UAgBX;;;;EAKV;EA7jBA8C,YAAYhI,KAAwB,EAAE;IACpC,KAAK,CAACA,KAAA,GA0BRiI,gBAAA,OAAQ,sBAAqB,QAC7BA,gBAAA,OAAQ,WAAUtI,YAAY,CAACb,QAAA,CAAS,IAAI,CAACkB,KAAK,EAAEN,IAAA,EAAgB,IAAI,CAAC,IACzEuI,gBAAA,OAAQ,2BAAqEpF,SAAA,GAC7EoF,gBAAA,OAAiB,0BAAoEpF,SAAA,GAcrFoF,gBAAA,qBAAsD,CAAC,IAmJvDA,gBAAA,OAAQ,sBAAqBxJ,IAAA,GA2E7BwJ,gBAAA,+BAAuB;MACrB,IAAI,IAAI,CAACxF,KAAK,CAACH,SAAS,KAAK,MAAM;QACjC,IAAI,CAACH,eAAe,CAAC,IAAI,CAACM,KAAK,CAACH,SAAS,EAAEsE,OAAA,CAAQ,IAAI,CAACnE,KAAK,CAACvB,MAAM;MACtE;IACF,IAEA+G,gBAAA,0CAAmCC,CAAA;MACjC;MACA,IACE,CAACA,CAAA,IACAA,CAAA,CAAEC,YAAY,CAAC9B,QAAQ,CAAC,gBACvB6B,CAAA,CAAEE,MAAM,KAAK,IAAI,CAAC5E,SAAS,CAAC,IAAI,CAACf,KAAK,CAACC,kBAAkB,GAC3D;QACA,QAAQ,IAAI,CAACD,KAAK,CAACS,eAAe;UAChC,KAAK;YACH,IAAI,CAAC8B,iBAAiB;YACtB;UACF,KAAK;YACH,IAAI,CAACF,kBAAkB;QAC3B;MACF;IACF,IAkBAmD,gBAAA,2DAAoDI,KAAA;MAClD,IAAI,IAAI,CAAC5F,KAAK,CAACzB,YAAY,EAAE;QAC3B;MACF;MACA,MAAM;QAAEsH,kBAAkB;QAAEC,wBAAwB;QAAEC;MAAsB,CAAE,GAC5EjJ,sBAAA,CAAuB8I,KAAA,CAAMI,MAAM,EAAEJ,KAAA,CAAMK,MAAM,EAAE,IAAI,CAACzI,MAAM,CAAEsF,UAAU;MAE5E,IAAI,CAACgD,wBAAA,IAA4BC,sBAAqB,KAAMF,kBAAA,EAAoB;QAC9E,IAAI,CAAClG,QAAQ,CAAC;UAAEpB,YAAA,EAAc;QAAK;MACrC;IACF,IAEAiH,gBAAA,oDAA6CI,KAAA;MAC3C,IAAI,IAAI,CAACM,kBAAkB,IAAIlJ,iBAAA,CAAkB4I,KAAA,GAAQ;QACvD;MACF;MAEA,MAAM;QAAEO,gBAAgB;QAAEN,kBAAkB;QAAEC;MAAwB,CAAE,GACtEhJ,sBAAA,CAAuB8I,KAAA,CAAMI,MAAM,EAAEJ,KAAA,CAAMK,MAAM,EAAE,IAAI,CAACzI,MAAM,CAAEsF,UAAU;MAE5E,IAAI,IAAI,CAAC9C,KAAK,CAACD,QAAQ,IAAI8F,kBAAA,EAAoB;QAC7C;MACF;MAEA,IAAI,CAAC,IAAI,CAAC7F,KAAK,CAAC1B,WAAW,IAAI,IAAI,CAACf,KAAK,CAAC8F,OAAO,IAAI,IAAI,CAAC9F,KAAK,CAAC8F,OAAO,CAAC0B,MAAM,GAAG,GAAG;QAClF,IAAIoB,gBAAA,EAAkB;UACpB,IAAI,CAACD,kBAAkB,GAAG;UAC1B;QACF;QAEA,IAAI,CAACL,kBAAA,EAAoB;UACvB;QACF;QAEA,IACE,CAACC,wBAAA,IACD/I,gDAAA,CAAiD6I,KAAA,CAAMQ,aAAa,CAACT,MAAM,GAC3E;UACA,IAAI,CAACO,kBAAkB,GAAG;UAC1B;QACF;QACA;QACA,IAAI,IAAI,CAAC3I,KAAK,CAACgG,gBAAgB,EAAE;UAC/B,MAAM8C,OAAA,GAAU,IAAI,CAAC9I,KAAK,CAACgG,gBAAgB,CAAC,IAAI,CAACvD,KAAK,CAAC3B,WAAW;UAClE,IAAIgI,OAAA,KAAY,WAAW;YACzB,IAAI,CAACH,kBAAkB,GAAG;YAC1B;UACF;QACF;QAEA,IAAI,IAAI,CAAClG,KAAK,CAAC3B,WAAW,KAAK,MAAM;cAMUG,kBAAA;UAL7C;UACA,IAAI,CAACS,iBAAiB;UACtB,MAAMC,WAAA,GAAc,IAAI,CAACnB,OAAO,CAAC,IAAI,CAACiC,KAAK,CAAC3B,WAAW,CAAC,IAAI,EAAE;UAC9D,IAAI,CAACN,OAAO,GAAGoB,oBAAA,CAAAC,cAAA,KACV,IAAI,CAACrB,OAAO;YACf,CAAC,IAAI,CAACiC,KAAK,CAAC3B,WAAW,GAAG,C,GAAIa,WAAA,E,CAAaV,kBAAA,OAAI,CAACjB,KAAK,CAAC8B,MAAM,cAAjBb,kBAAA,uBAAAA,kBAAA,CAAmBc,SAAS,GAAGE,CAAC;;QAE/E;QAEA,IAAI,CAACG,QAAQ,CAAC;UACZrB,WAAA,EAAa;UACboC,eAAA,EAAiBkF,KAAA,CAAMI,MAAM;UAC7B9F,kBAAA,EAAoB,IAAI,CAACF,KAAK,CAAC3B,WAAW;UAC1C4B,kBAAA,EAAoB,IAAI,CAAC1C,KAAK,CAAC8F,OAAO,CAAC/C,KAAK,CAAC,CAAC,EAAE,CAAC;QACnD;MACF;MAEA,IAAI,IAAI,CAACN,KAAK,CAAC1B,WAAW,EAAE;QAC1B,IAAIsH,KAAA,CAAMK,MAAM,GAAG,GAAG;UACpB,IAAI,CAACtG,QAAQ,CAAC;YAAEgB,cAAA,EAAgB;UAAE;QACpC,OAAO,IAAIiF,KAAA,CAAMK,MAAM,GAAG,IAAI,CAACzI,MAAM,CAAEsF,UAAU,GAAG,IAAI,CAAC9C,KAAK,CAACU,eAAe,EAAE;UAC9E,IAAI,CAACf,QAAQ,CAAC;YAAEgB,cAAA,EAAgB,IAAI,CAACnD,MAAM,CAAEsF;UAAW;QAC1D,OAAO;UACL,IAAI,CAACnD,QAAQ,CAAC;YAAEgB,cAAA,EAAgBiF,KAAA,CAAMK;UAAO;QAC/C;MACF;IACF,IAEAT,gBAAA,kDAA2CI,KAAA;MACzC,IAAI,CAACM,kBAAkB,GAAG;MAE1B,IAAI,IAAI,CAAClG,KAAK,CAAC1B,WAAW,IAAI,IAAI,CAACd,MAAM,EAAE;QACzC,MAAM8I,KAAA,GAAQ,IAAK,CAACtG,KAAK,CAACW,cAAc,GAAGiF,KAAA,CAAMW,QAAQ,GAAI;QAC7D,IAAI,IAAI,CAACvG,KAAK,CAACW,cAAc,KAAK,GAAG;UACnC,IAAI,CAAC4B,iBAAiB;QACxB,OAAO,IAAI,IAAI,CAACvC,KAAK,CAACW,cAAc,IAAI,IAAI,CAACnD,MAAM,CAACsF,UAAU,EAAE;UAC9D,IAAI,CAACT,kBAAkB;QACzB,OAAO,IAAIiE,KAAA,GAAQ,OAAO,IAAI,CAACtG,KAAK,CAACW,cAAc,IAAI,IAAI,CAACnD,MAAM,CAACsF,UAAU,GAAG,GAAG;UACjF,IAAI,CAACnD,QAAQ,CAAC;YAAEc,eAAA,EAAiB;UAAU;QAC7C,OAAO;UACL,IAAI,CAACd,QAAQ,CAAC;YAAEc,eAAA,EAAiB;UAAO;QAC1C;MACF;IACF;IA5YE,IAAI,CAACT,KAAK,GAAG;MACXD,QAAA,EAAU;MAEVH,aAAA,EAAe,CAACrC,KAAA,CAAMc,WAAW,CAAC;MAClCA,WAAA,EAAad,KAAA,CAAMc,WAAW;MAC9BI,MAAA,EAAQ2B,SAAA;MACRP,SAAA,EAAW;MACXC,SAAA,EAAW;MAEXxB,WAAA,EAAa8B,SAAA;MACbM,eAAA,EAAiB;MACjBC,cAAA,EAAgB;MAChBV,kBAAA,EAAoB;MACpBC,kBAAA,EAAoB;MACpBO,eAAA,EAAiB;MAEjBlC,YAAA,EAAc;IAChB;EACF;AAyiBF;AAviBEiH,gBAAA,CA3BIpI,qBAAA,EA2BG,gBAA2C;EAChDiG,OAAA,EAAS;AACX;AAuiBF,OAAO,MAAMmD,YAAA,GAA4CvK,WAAA,CACvDA,WAAA,CACEA,WAAA,CACEC,YAAA,CAAaE,OAAA,CAA2BgB,qBAAA,IACxCR,eAAA,EACA,aAEFJ,qBAAA,EACA,mBAEFD,aAAA,EACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}