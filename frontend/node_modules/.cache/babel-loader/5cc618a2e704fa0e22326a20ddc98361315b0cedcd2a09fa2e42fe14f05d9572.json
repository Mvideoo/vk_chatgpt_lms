{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { clamp } from \"../../helpers/math.js\";\nimport { usePlatform } from \"../../hooks/usePlatform.js\";\nimport { useStateWithPrev } from \"../../hooks/useStateWithPrev.js\";\nimport { initializeBrowserGesturePreventionEffect, useDOM } from \"../../lib/dom.js\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect.js\";\nimport { useScroll } from \"../AppRoot/ScrollContext.js\";\nimport { FixedLayout } from \"../FixedLayout/FixedLayout.js\";\nimport { Touch } from \"../Touch/Touch.js\";\nimport TouchRootContext from \"../Touch/TouchContext.js\";\nimport { PullToRefreshSpinner } from \"./PullToRefreshSpinner.js\";\nconst WAIT_FETCHING_TIMEOUT_MS = 1000;\nfunction cancelEvent(event) {\n  /* istanbul ignore if: неясно в какой ситуации `event` из `Touch` может быть не определён */if (!event) {\n    return false;\n  }\n  if ('preventDefault' in event.originalEvent && event.originalEvent.cancelable) {\n    event.originalEvent.preventDefault();\n  }\n  if ('stopPropagation' in event.originalEvent) {\n    event.originalEvent.stopPropagation();\n  }\n  return false;\n}\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\nexport const PullToRefresh = _param => {\n  var {\n      children,\n      isFetching,\n      onRefresh,\n      className\n    } = _param,\n    restProps = _object_without_properties(_param, [\"children\", \"isFetching\", \"onRefresh\", \"className\"]);\n  const platform = usePlatform();\n  const scroll = useScroll();\n  const {\n    window\n  } = useDOM();\n  const prevIsFetchingRef = React.useRef(undefined);\n  React.useEffect(() => {\n    prevIsFetchingRef.current = isFetching;\n  });\n  const initParams = React.useMemo(() => ({\n    start: platform === 'ios' ? -10 : -45,\n    max: platform === 'ios' ? 50 : 80,\n    maxY: platform === 'ios' ? 400 : 80,\n    refreshing: platform === 'ios' ? 36 : 50,\n    positionMultiplier: platform === 'ios' ? 0.21 : 1\n  }), [platform]);\n  const [spinnerY, setSpinnerY] = React.useState(initParams.start);\n  const [watching, setWatching] = React.useState(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n  const [canRefresh, setCanRefresh] = React.useState(false);\n  const [[touchDown, prevTouchDown], setTouchDown] = useStateWithPrev(false);\n  const touchY = React.useRef(0);\n  const [contentShift, setContentShift] = React.useState(0);\n  const [spinnerProgress, setSpinnerProgress] = React.useState(0);\n  const resetRefreshingState = React.useCallback(() => {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n  const onRefreshingFinish = React.useCallback(() => {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n  const waitFetchingTimeoutId = React.useRef(undefined);\n  useIsomorphicLayoutEffect(() => {\n    const prevIsFetching = prevIsFetchingRef.current;\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [isFetching, onRefreshingFinish]);\n  useIsomorphicLayoutEffect(() => {\n    const prevIsFetching = prevIsFetchingRef.current;\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearTimeout(waitFetchingTimeoutId.current);\n    }\n  }, [isFetching]);\n  const runRefreshing = React.useCallback(() => {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      clearTimeout(waitFetchingTimeoutId.current);\n      waitFetchingTimeoutId.current = setTimeout(onRefreshingFinish, WAIT_FETCHING_TIMEOUT_MS);\n      setRefreshing(true);\n      setSpinnerY(prevSpinnerY => platform === 'ios' ? prevSpinnerY : initParams.refreshing);\n      onRefresh();\n    }\n  }, [refreshing, onRefresh, onRefreshingFinish, platform, initParams.refreshing]);\n  useIsomorphicLayoutEffect(() => {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n        /* istanbul ignore if: TODO написать тест */\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [initParams, isFetching, onRefreshingFinish, prevTouchDown, touchDown, refreshing, canRefresh, runRefreshing]);\n  useIsomorphicLayoutEffect(function toggleDocumentOverscrollBehavior() {\n    return window && (watching || refreshing) ? initializeBrowserGesturePreventionEffect(window) : undefined;\n  }, [window, watching, refreshing]);\n  const startYRef = React.useRef(0);\n  const onTouchStart = event => {\n    if (refreshing) {\n      cancelEvent(event);\n      return;\n    }\n    setTouchDown(true);\n    startYRef.current = event.startY;\n  };\n  const iosRefreshStartedRef = React.useRef(false);\n  const onTouchMove = event => {\n    const {\n      isY,\n      shiftY\n    } = event;\n    const {\n      start,\n      max\n    } = initParams;\n    const pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n    if (watching && touchDown) {\n      cancelEvent(event);\n      const {\n        positionMultiplier,\n        maxY\n      } = initParams;\n      const shift = Math.max(0, shiftY - touchY.current);\n      const currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      const progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n      const iosCanStartRefreshDuringGesture = platform === 'ios' && progress > 85 && !refreshing && !iosRefreshStartedRef.current;\n      if (iosCanStartRefreshDuringGesture) {\n        iosRefreshStartedRef.current = true;\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(event);\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n  const onTouchEnd = () => {\n    setWatching(false);\n    setTouchDown(false);\n    iosRefreshStartedRef.current = false;\n  };\n  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;\n  let contentTransform = '';\n  if (platform === 'ios' && refreshing && !touchDown) {\n    contentTransform = 'translate3d(0, 100px, 0)';\n  } else if (platform === 'ios' && (contentShift || refreshing)) {\n    contentTransform = `translate3d(0, ${contentShift}px, 0)`;\n  }\n  return /*#__PURE__*/_jsx(TouchRootContext.Provider, {\n    value: true,\n    children: /*#__PURE__*/_jsxs(Touch, _object_spread_props(_object_spread({\n      \"aria-live\": \"polite\",\n      \"aria-busy\": !!isFetching\n    }, restProps), {\n      onStart: onTouchStart,\n      onMove: onTouchMove,\n      onEnd: onTouchEnd,\n      className: classNames(\"vkuiPullToRefresh__host\", platform === 'ios' && \"vkuiPullToRefresh__ios\", watching && \"vkuiPullToRefresh__watching\", refreshing && \"vkuiPullToRefresh__refreshing\", className),\n      children: [/*#__PURE__*/_jsx(FixedLayout, {\n        className: \"vkuiPullToRefresh__controls\",\n        useParentWidth: true,\n        children: /*#__PURE__*/_jsx(PullToRefreshSpinner, {\n          style: {\n            transform: spinnerTransform,\n            opacity: watching || refreshing || canRefresh ? 1 : 0\n          },\n          on: refreshing,\n          progress: refreshing ? undefined : spinnerProgress\n        })\n      }), /*#__PURE__*/_jsx(\"div\", {\n        className: \"vkuiPullToRefresh__content\",\n        style: {\n          transform: contentTransform\n        },\n        children: children\n      })]\n    }))\n  });\n};","map":{"version":3,"names":["React","classNames","clamp","usePlatform","useStateWithPrev","initializeBrowserGesturePreventionEffect","useDOM","useIsomorphicLayoutEffect","useScroll","FixedLayout","Touch","TouchRootContext","PullToRefreshSpinner","WAIT_FETCHING_TIMEOUT_MS","cancelEvent","event","originalEvent","cancelable","preventDefault","stopPropagation","PullToRefresh","_param","children","isFetching","onRefresh","className","restProps","_object_without_properties","platform","scroll","window","prevIsFetchingRef","useRef","undefined","useEffect","current","initParams","useMemo","start","max","maxY","refreshing","positionMultiplier","spinnerY","setSpinnerY","useState","watching","setWatching","setRefreshing","canRefresh","setCanRefresh","touchDown","prevTouchDown","setTouchDown","touchY","contentShift","setContentShift","spinnerProgress","setSpinnerProgress","resetRefreshingState","useCallback","onRefreshingFinish","waitFetchingTimeoutId","prevIsFetching","clearTimeout","runRefreshing","setTimeout","prevSpinnerY","toggleDocumentOverscrollBehavior","startYRef","onTouchStart","startY","iosRefreshStartedRef","onTouchMove","isY","shiftY","pageYOffset","getScroll","y","shift","Math","currentY","progress","abs","iosCanStartRefreshDuringGesture","onTouchEnd","spinnerTransform","contentTransform","_jsx","Provider","value","_jsxs","_object_spread_props","_object_spread","onStart","onMove","onEnd","useParentWidth","style","transform","opacity","on"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/PullToRefresh/PullToRefresh.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { useStateWithPrev } from '../../hooks/useStateWithPrev';\nimport { type DOMProps, initializeBrowserGesturePreventionEffect, useDOM } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport type { AnyFunction, HasChildren } from '../../types';\nimport { type ScrollContextInterface, useScroll } from '../AppRoot/ScrollContext';\nimport { FixedLayout } from '../FixedLayout/FixedLayout';\nimport { type CustomTouchEvent, Touch, type TouchProps } from '../Touch/Touch';\nimport TouchRootContext from '../Touch/TouchContext';\nimport { PullToRefreshSpinner } from './PullToRefreshSpinner';\nimport styles from './PullToRefresh.module.css';\n\nconst WAIT_FETCHING_TIMEOUT_MS = 1000;\n\nfunction cancelEvent(event: CustomTouchEvent) {\n  /* istanbul ignore if: неясно в какой ситуации `event` из `Touch` может быть не определён */\n  if (!event) {\n    return false;\n  }\n  if ('preventDefault' in event.originalEvent && event.originalEvent.cancelable) {\n    event.originalEvent.preventDefault();\n  }\n  if ('stopPropagation' in event.originalEvent) {\n    event.originalEvent.stopPropagation();\n  }\n  return false;\n}\n\nexport interface PullToRefreshProps extends DOMProps, TouchProps, HasChildren {\n  /**\n   * Будет вызвана для обновления контента (прим.: функция должна быть мемоизированным коллбэком)\n   */\n  onRefresh: AnyFunction;\n  /**\n   * Определяет, выполняется ли обновление. Для скрытия спиннера после получения контента необходимо передать `false`\n   */\n  isFetching?: boolean;\n  /** @ignore */\n  scroll?: ScrollContextInterface;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\nexport const PullToRefresh = ({\n  children,\n  isFetching,\n  onRefresh,\n  className,\n  ...restProps\n}: PullToRefreshProps): React.ReactNode => {\n  const platform = usePlatform();\n  const scroll = useScroll();\n  const { window } = useDOM();\n\n  const prevIsFetchingRef = React.useRef<boolean | undefined>(undefined);\n  React.useEffect(() => {\n    prevIsFetchingRef.current = isFetching;\n  });\n\n  const initParams = React.useMemo(\n    () => ({\n      start: platform === 'ios' ? -10 : -45,\n      max: platform === 'ios' ? 50 : 80,\n      maxY: platform === 'ios' ? 400 : 80,\n      refreshing: platform === 'ios' ? 36 : 50,\n      positionMultiplier: platform === 'ios' ? 0.21 : 1,\n    }),\n    [platform],\n  );\n\n  const [spinnerY, setSpinnerY] = React.useState(initParams.start);\n  const [watching, setWatching] = React.useState(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n  const [canRefresh, setCanRefresh] = React.useState(false);\n  const [[touchDown, prevTouchDown], setTouchDown] = useStateWithPrev(false);\n\n  const touchY = React.useRef(0);\n  const [contentShift, setContentShift] = React.useState(0);\n  const [spinnerProgress, setSpinnerProgress] = React.useState(0);\n\n  const resetRefreshingState = React.useCallback(() => {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n\n  const onRefreshingFinish = React.useCallback(() => {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n\n  const waitFetchingTimeoutId = React.useRef<ReturnType<typeof setTimeout>>(undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    const prevIsFetching = prevIsFetchingRef.current;\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [isFetching, onRefreshingFinish]);\n\n  useIsomorphicLayoutEffect(() => {\n    const prevIsFetching = prevIsFetchingRef.current;\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearTimeout(waitFetchingTimeoutId.current);\n    }\n  }, [isFetching]);\n\n  const runRefreshing = React.useCallback(() => {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      clearTimeout(waitFetchingTimeoutId.current);\n      waitFetchingTimeoutId.current = setTimeout(onRefreshingFinish, WAIT_FETCHING_TIMEOUT_MS);\n\n      setRefreshing(true);\n      setSpinnerY((prevSpinnerY) => (platform === 'ios' ? prevSpinnerY : initParams.refreshing));\n\n      onRefresh();\n    }\n  }, [refreshing, onRefresh, onRefreshingFinish, platform, initParams.refreshing]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n        /* istanbul ignore if: TODO написать тест */\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [\n    initParams,\n    isFetching,\n    onRefreshingFinish,\n    prevTouchDown,\n    touchDown,\n    refreshing,\n    canRefresh,\n    runRefreshing,\n  ]);\n\n  useIsomorphicLayoutEffect(\n    function toggleDocumentOverscrollBehavior() {\n      return window && (watching || refreshing)\n        ? initializeBrowserGesturePreventionEffect(window)\n        : undefined;\n    },\n    [window, watching, refreshing],\n  );\n\n  const startYRef = React.useRef(0);\n\n  const onTouchStart = (event: CustomTouchEvent) => {\n    if (refreshing) {\n      cancelEvent(event);\n      return;\n    }\n    setTouchDown(true);\n    startYRef.current = event.startY;\n  };\n\n  const iosRefreshStartedRef = React.useRef(false);\n  const onTouchMove = (event: CustomTouchEvent) => {\n    const { isY, shiftY } = event;\n    const { start, max } = initParams;\n    const pageYOffset = scroll?.getScroll().y;\n\n    if (watching && touchDown) {\n      cancelEvent(event);\n\n      const { positionMultiplier, maxY } = initParams;\n\n      const shift = Math.max(0, shiftY - touchY.current);\n\n      const currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      const progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n\n      const iosCanStartRefreshDuringGesture =\n        platform === 'ios' && progress > 85 && !refreshing && !iosRefreshStartedRef.current;\n      if (iosCanStartRefreshDuringGesture) {\n        iosRefreshStartedRef.current = true;\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(event);\n\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n\n  const onTouchEnd = () => {\n    setWatching(false);\n    setTouchDown(false);\n    iosRefreshStartedRef.current = false;\n  };\n\n  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;\n  let contentTransform = '';\n\n  if (platform === 'ios' && refreshing && !touchDown) {\n    contentTransform = 'translate3d(0, 100px, 0)';\n  } else if (platform === 'ios' && (contentShift || refreshing)) {\n    contentTransform = `translate3d(0, ${contentShift}px, 0)`;\n  }\n\n  return (\n    <TouchRootContext.Provider value={true}>\n      <Touch\n        aria-live=\"polite\"\n        aria-busy={!!isFetching}\n        {...restProps}\n        onStart={onTouchStart}\n        onMove={onTouchMove}\n        onEnd={onTouchEnd}\n        className={classNames(\n          styles.host,\n          platform === 'ios' && styles.ios,\n          watching && styles.watching,\n          refreshing && styles.refreshing,\n          className,\n        )}\n      >\n        <FixedLayout className={styles.controls} useParentWidth>\n          <PullToRefreshSpinner\n            style={{\n              transform: spinnerTransform,\n              opacity: watching || refreshing || canRefresh ? 1 : 0,\n            }}\n            on={refreshing}\n            progress={refreshing ? undefined : spinnerProgress}\n          />\n        </FixedLayout>\n\n        <div\n          className={styles.content}\n          style={{\n            transform: contentTransform,\n          }}\n        >\n          {children}\n        </div>\n      </Touch>\n    </TouchRootContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}