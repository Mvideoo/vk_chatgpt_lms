{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { clamp } from \"../../helpers/math.js\";\nimport { mergeStyle } from \"../../helpers/mergeStyle.js\";\nimport { useAdaptivity } from \"../../hooks/useAdaptivity.js\";\nimport { useConfigDirection } from \"../../hooks/useConfigDirection.js\";\nimport { useExternRef } from \"../../hooks/useExternRef.js\";\nimport { Touch } from \"../Touch/Touch.js\";\nimport { SliderThumb } from \"./SliderThumb/SliderThumb.js\";\nimport { extractSliderAriaAttributesFromRestProps, getDraggingTypeByTargetDataset, isMultipleValues, offsetToValue, snapDirection, toPercent, updateInternalStateValue, updateInternalStateValueByNativeChange } from \"./helpers.js\";\nconst sizeYClassNames = {\n  none: \"vkuiSlider__sizeYNone\",\n  compact: \"vkuiSlider__sizeYCompact\"\n};\nconst sizeClassNames = {\n  l: \"vkuiSlider__sizeL\",\n  m: \"vkuiSlider__sizeM\",\n  s: \"vkuiSlider__sizeS\"\n};\n/**\n * @see https://vkcom.github.io/VKUI/#/Slider\n */\nexport const Slider = _param => {\n  var {\n      step = 1,\n      min = 0,\n      max = 100,\n      value: valueProp,\n      multiple: multipleProp,\n      defaultValue = multipleProp ? [min, max] : min,\n      disabled,\n      className,\n      getRootRef,\n      getAriaLabel,\n      getAriaValueText,\n      startThumbTestId,\n      endThumbTestId,\n      onChange,\n      withTooltip,\n      size = 'l',\n      style: styleProp\n    } = _param,\n    restProps = _object_without_properties(_param, [\"step\", \"min\", \"max\", \"value\", \"multiple\", \"defaultValue\", \"disabled\", \"className\", \"getRootRef\", \"getAriaLabel\", \"getAriaValueText\", \"startThumbTestId\", \"endThumbTestId\", \"onChange\", \"withTooltip\", \"size\", \"style\"]);\n  const {\n    sizeY = 'none'\n  } = useAdaptivity();\n  const direction = useConfigDirection();\n  const isRtl = direction === 'rtl';\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = React.useState(defaultValue);\n  const value = React.useMemo(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n    return Array.isArray(resolvedValue) ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)] : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n  const startValueInPercent = toPercent(startValue, min, max);\n  const endReversedValueInPercent = multiple ? toPercent(endValue, min, max) : 0;\n  const [activeThumb, setActiveThumb] = React.useState(null);\n  const gesture = React.useRef({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0\n  }).current;\n  const thumbsContainerRef = useExternRef(getRootRef);\n  const thumbStartInputRef = React.useRef(null);\n  const thumbEndInputRef = React.useRef(null);\n  const _extractSliderAriaAttributesFromRestProps = extractSliderAriaAttributesFromRestProps(restProps),\n    {\n      ariaLabel,\n      ariaValueText,\n      ariaLabelledBy\n    } = _extractSliderAriaAttributesFromRestProps,\n    restPropsWithoutAriaAttributes = _object_without_properties(_extractSliderAriaAttributesFromRestProps, [\"ariaLabel\", \"ariaValueText\", \"ariaLabelledBy\"]);\n  const changeValue = (nextValue, event) => {\n    if (disabled || value[0] === nextValue[0] && value[1] === nextValue[1]) {\n      return;\n    }\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n  const handlePointerStart = event => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n    const {\n      left: nextContainerX,\n      width: nextContainerWidth\n    } = thumbsContainerRef.current.getBoundingClientRect();\n    // @ts-expect-error: TS2345 в VKUITouchEvent плохо описаны типы. `target` это просто `EventTarget`.\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n    let nextStartX = event.startX - nextContainerX;\n    if (isRtl) {\n      nextStartX = nextContainerWidth - nextStartX;\n    }\n    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = snapDirection(value, nextValue, foundDraggingType);\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n    const updatedInternalStateValue = updateInternalStateValue(value, nextValue, min, max, nextDragging);\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (thumbStartInputRef.current && (foundDraggingType === 'start' || nextStartValue !== startValue && nextEndValue === endValue)) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (thumbEndInputRef.current && (foundDraggingType === 'end' || nextEndValue !== endValue && nextStartValue === startValue)) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n    changeValue(updatedInternalStateValue, event);\n    event.originalEvent.stopPropagation();\n    setActiveThumb(gesture.dragging);\n  };\n  const handlePointerMove = event => {\n    const {\n      startX,\n      containerWidth,\n      dragging\n    } = gesture;\n    const {\n      shiftX = 0\n    } = event;\n    const nextStartX = startX + (isRtl ? -shiftX : shiftX);\n    const nextValue = offsetToValue(nextStartX, containerWidth, min, max, step);\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n  const handlePointerEnd = event => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n    setActiveThumb(null);\n  };\n  const handleChangeByNativeInput = event => {\n    changeValue(updateInternalStateValueByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), event);\n  };\n  const style = {\n    '--vkui_internal--Slider_start_value': String(startValueInPercent),\n    '--vkui_internal--Slider_end_value': String(endReversedValueInPercent)\n  };\n  return /*#__PURE__*/_jsxs(Touch, _object_spread_props(_object_spread({\n    \"data-value\": multiple ? `${startValue},${endValue}` : startValue\n  }, restPropsWithoutAriaAttributes), {\n    className: classNames(\"vkuiSlider__host\", disabled && \"vkuiSlider__disabled\", sizeY !== 'regular' && sizeYClassNames[sizeY], sizeClassNames[size], multiple && \"vkuiSlider__multiple\", isRtl && \"vkuiSlider__rtl\", className),\n    style: mergeStyle(styleProp, style),\n    getRootRef: getRootRef,\n    onStart: disabled ? undefined : handlePointerStart,\n    onMove: disabled ? undefined : handlePointerMove,\n    onEnd: disabled ? undefined : handlePointerEnd,\n    children: [/*#__PURE__*/_jsx(\"div\", {\n      className: \"vkuiSlider__track\"\n    }), /*#__PURE__*/_jsx(\"div\", {\n      className: \"vkuiSlider__trackFill\"\n    }), /*#__PURE__*/_jsxs(\"div\", {\n      ref: thumbsContainerRef,\n      className: \"vkuiSlider__thumbs\",\n      children: [/*#__PURE__*/_jsx(SliderThumb, {\n        \"data-type\": \"start\",\n        className: classNames(\"vkuiSlider__thumb\", \"vkuiSlider__thumbStart\"),\n        style: {\n          // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.\n          zIndex: multiple && startValueInPercent >= 50 ? 2 : undefined\n        },\n        withTooltip: withTooltip,\n        inputProps: {\n          'data-type': 'start',\n          'data-testid': startThumbTestId,\n          'ref': thumbStartInputRef,\n          'step': step,\n          'min': min,\n          'value': startValue,\n          'max': multiple ? endValue : max,\n          'disabled': disabled,\n          'aria-label': getAriaLabel ? getAriaLabel(0) : ariaLabel,\n          'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,\n          'aria-labelledby': ariaLabelledBy,\n          'onChange': handleChangeByNativeInput\n        },\n        isActive: activeThumb === 'start'\n      }), multiple && /*#__PURE__*/_jsx(SliderThumb, {\n        \"data-type\": \"end\",\n        className: classNames(\"vkuiSlider__thumb\", \"vkuiSlider__thumbEnd\"),\n        withTooltip: withTooltip,\n        inputProps: {\n          'data-type': 'end',\n          'data-testid': endThumbTestId,\n          'ref': thumbEndInputRef,\n          'step': step,\n          'min': startValue,\n          'value': endValue,\n          'max': max,\n          'disabled': disabled,\n          'aria-label': getAriaLabel ? getAriaLabel(1) : ariaLabel,\n          'aria-valuetext': getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,\n          'aria-labelledby': ariaLabelledBy,\n          'onChange': handleChangeByNativeInput\n        },\n        isActive: activeThumb === 'end'\n      })]\n    })]\n  }));\n};","map":{"version":3,"names":["React","classNames","clamp","mergeStyle","useAdaptivity","useConfigDirection","useExternRef","Touch","SliderThumb","extractSliderAriaAttributesFromRestProps","getDraggingTypeByTargetDataset","isMultipleValues","offsetToValue","snapDirection","toPercent","updateInternalStateValue","updateInternalStateValueByNativeChange","sizeYClassNames","none","compact","sizeClassNames","l","m","s","Slider","_param","step","min","max","value","valueProp","multiple","multipleProp","defaultValue","disabled","className","getRootRef","getAriaLabel","getAriaValueText","startThumbTestId","endThumbTestId","onChange","withTooltip","size","style","styleProp","restProps","_object_without_properties","sizeY","direction","isRtl","isControlled","undefined","localValue","setValue","useState","useMemo","resolvedValue","Array","isArray","startValue","endValue","startValueInPercent","endReversedValueInPercent","activeThumb","setActiveThumb","gesture","useRef","dragging","startX","containerWidth","current","thumbsContainerRef","thumbStartInputRef","thumbEndInputRef","_extractSliderAriaAttributesFromRestProps","ariaLabel","ariaValueText","ariaLabelledBy","restPropsWithoutAriaAttributes","changeValue","nextValue","event","handlePointerStart","left","nextContainerX","width","nextContainerWidth","getBoundingClientRect","foundDraggingType","originalEvent","target","nextStartX","nextDragging","updatedInternalStateValue","nextStartValue","nextEndValue","focus","preventDefault","stopPropagation","handlePointerMove","shiftX","handlePointerEnd","handleChangeByNativeInput","Number","String","_jsxs","_object_spread_props","_object_spread","onStart","onMove","onEnd","_jsx","ref","zIndex","inputProps","isActive"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/Slider/Slider.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { mergeStyle } from '../../helpers/mergeStyle';\nimport { useAdaptivity } from '../../hooks/useAdaptivity';\nimport { useConfigDirection } from '../../hooks/useConfigDirection';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport type { CSSCustomProperties, HTMLAttributesWithRootRef } from '../../types';\nimport { type CustomTouchEvent, type CustomTouchEventHandler, Touch } from '../Touch/Touch';\nimport { SliderThumb } from './SliderThumb/SliderThumb';\nimport {\n  extractSliderAriaAttributesFromRestProps,\n  getDraggingTypeByTargetDataset,\n  isMultipleValues,\n  offsetToValue,\n  snapDirection,\n  toPercent,\n  updateInternalStateValue,\n  updateInternalStateValueByNativeChange,\n} from './helpers';\nimport type { InternalDraggingType, InternalGestureRef, InternalValueState } from './types';\nimport styles from './Slider.module.css';\n\nconst sizeYClassNames = {\n  none: styles.sizeYNone,\n  compact: styles.sizeYCompact,\n};\n\nconst sizeClassNames = {\n  l: styles.sizeL,\n  m: styles.sizeM,\n  s: styles.sizeS,\n};\n\nexport interface SliderBaseProps\n  extends Omit<HTMLAttributesWithRootRef<HTMLDivElement>, 'value' | 'defaultValue' | 'onChange'> {\n  min?: number;\n  max?: number;\n  step?: number;\n  disabled?: boolean;\n  /**\n   * Тоже самое, что и `aria-label`, но на вход можно получать индекс текущего ползунка и в зависимости от этого выдавать разный текст.\n   *\n   * > Перебивает `aria-label`.\n   */\n  getAriaLabel?: (index: number) => string;\n  /**\n   * В отличие от `aria-valuetext`, позволяет более гибко форматировать текст в зависимости от значения ползунка.\n   *\n   * Полезно при использовании компонента как неконтролируемого.\n   *\n   * > Перебивает `aria-valuetext`.\n   */\n  getAriaValueText?: (value: number, index: number) => string;\n  withTooltip?: boolean;\n  /**\n   * Размер ползунка.\n   */\n  size?: 's' | 'm' | 'l';\n  /**\n   * Передает атрибут `data-testid` для первого ползунка\n   */\n  startThumbTestId?: string;\n  /**\n   * Передает атрибут `data-testid` для второго ползунка когда `multiple=true`\n   */\n  endThumbTestId?: string;\n}\n\nexport interface SliderProps extends SliderBaseProps {\n  multiple?: false;\n  value?: number;\n  defaultValue?: number;\n  onChange?: (value: number, event: CustomTouchEvent | React.ChangeEvent) => void;\n}\n\nexport interface SliderMultipleProps extends SliderBaseProps {\n  multiple: true;\n  value?: [number, number];\n  defaultValue?: [number, number];\n  onChange?: (value: [number, number], event: CustomTouchEvent | React.ChangeEvent) => void;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Slider\n */\nexport const Slider = ({\n  step = 1,\n  min = 0,\n  max = 100,\n  value: valueProp,\n  multiple: multipleProp,\n  defaultValue = multipleProp ? [min, max] : min,\n  disabled,\n  className,\n  getRootRef,\n  getAriaLabel,\n  getAriaValueText,\n  startThumbTestId,\n  endThumbTestId,\n  onChange,\n  withTooltip,\n  size = 'l',\n  style: styleProp,\n  ...restProps\n}: SliderProps | SliderMultipleProps): React.ReactNode => {\n  const { sizeY = 'none' } = useAdaptivity();\n  const direction = useConfigDirection();\n  const isRtl = direction === 'rtl';\n\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = React.useState(defaultValue);\n\n  const value = React.useMemo<InternalValueState>(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n    return Array.isArray(resolvedValue)\n      ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)]\n      : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n  const startValueInPercent = toPercent(startValue, min, max);\n  const endReversedValueInPercent = multiple ? toPercent(endValue, min, max) : 0;\n  const [activeThumb, setActiveThumb] = React.useState<InternalDraggingType | null>(null);\n\n  const gesture = React.useRef<InternalGestureRef>({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n  const thumbsContainerRef = useExternRef(getRootRef);\n  const thumbStartInputRef = React.useRef<HTMLInputElement>(null);\n  const thumbEndInputRef = React.useRef<HTMLInputElement>(null);\n\n  const { ariaLabel, ariaValueText, ariaLabelledBy, ...restPropsWithoutAriaAttributes } =\n    extractSliderAriaAttributesFromRestProps(restProps);\n\n  const changeValue = (\n    nextValue: InternalValueState,\n    event: CustomTouchEvent | React.ChangeEvent,\n  ) => {\n    if (disabled || (value[0] === nextValue[0] && value[1] === nextValue[1])) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  const handlePointerStart: CustomTouchEventHandler = (event: CustomTouchEvent) => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    const { left: nextContainerX, width: nextContainerWidth } =\n      thumbsContainerRef.current.getBoundingClientRect();\n\n    // @ts-expect-error: TS2345 в VKUITouchEvent плохо описаны типы. `target` это просто `EventTarget`.\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n\n    let nextStartX = event.startX - nextContainerX;\n    if (isRtl) {\n      nextStartX = nextContainerWidth - nextStartX;\n    }\n    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = snapDirection(value, nextValue, foundDraggingType);\n\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n\n    const updatedInternalStateValue = updateInternalStateValue(\n      value,\n      nextValue,\n      min,\n      max,\n      nextDragging,\n    );\n\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (\n      thumbStartInputRef.current &&\n      (foundDraggingType === 'start' ||\n        (nextStartValue !== startValue && nextEndValue === endValue))\n    ) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (\n      thumbEndInputRef.current &&\n      (foundDraggingType === 'end' || (nextEndValue !== endValue && nextStartValue === startValue))\n    ) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n\n    event.originalEvent.stopPropagation();\n    setActiveThumb(gesture.dragging);\n  };\n\n  const handlePointerMove: CustomTouchEventHandler = (event: CustomTouchEvent) => {\n    const { startX, containerWidth, dragging } = gesture;\n\n    const { shiftX = 0 } = event;\n    const nextStartX = startX + (isRtl ? -shiftX : shiftX);\n    const nextValue = offsetToValue(nextStartX, containerWidth, min, max, step);\n\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const handlePointerEnd: CustomTouchEventHandler = (event) => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n    setActiveThumb(null);\n  };\n\n  const handleChangeByNativeInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n    changeValue(\n      updateInternalStateValueByNativeChange(\n        value,\n        Number(event.target.value),\n        getDraggingTypeByTargetDataset(event.target),\n      ),\n      event,\n    );\n  };\n\n  const style: CSSCustomProperties = {\n    '--vkui_internal--Slider_start_value': String(startValueInPercent),\n    '--vkui_internal--Slider_end_value': String(endReversedValueInPercent),\n  };\n\n  return (\n    <Touch\n      data-value={multiple ? `${startValue},${endValue}` : startValue}\n      {...restPropsWithoutAriaAttributes}\n      className={classNames(\n        styles.host,\n        disabled && styles.disabled,\n        sizeY !== 'regular' && sizeYClassNames[sizeY],\n        sizeClassNames[size],\n        multiple && styles.multiple,\n        isRtl && styles.rtl,\n        className,\n      )}\n      style={mergeStyle(styleProp, style)}\n      getRootRef={getRootRef}\n      onStart={disabled ? undefined : handlePointerStart}\n      onMove={disabled ? undefined : handlePointerMove}\n      onEnd={disabled ? undefined : handlePointerEnd}\n    >\n      <div className={styles.track} />\n      <div className={styles.trackFill} />\n      <div ref={thumbsContainerRef} className={styles.thumbs}>\n        <SliderThumb\n          data-type=\"start\"\n          className={classNames(styles.thumb, styles.thumbStart)}\n          style={{\n            // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.\n            zIndex: multiple && startValueInPercent >= 50 ? 2 : undefined,\n          }}\n          withTooltip={withTooltip}\n          inputProps={{\n            'data-type': 'start',\n            'data-testid': startThumbTestId,\n            'ref': thumbStartInputRef,\n            'step': step,\n            'min': min,\n            'value': startValue,\n            'max': multiple ? endValue : max,\n            'disabled': disabled,\n            'aria-label': getAriaLabel ? getAriaLabel(0) : ariaLabel,\n            'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,\n            'aria-labelledby': ariaLabelledBy,\n            'onChange': handleChangeByNativeInput,\n          }}\n          isActive={activeThumb === 'start'}\n        />\n        {multiple && (\n          <SliderThumb\n            data-type=\"end\"\n            className={classNames(styles.thumb, styles.thumbEnd)}\n            withTooltip={withTooltip}\n            inputProps={{\n              'data-type': 'end',\n              'data-testid': endThumbTestId,\n              'ref': thumbEndInputRef,\n              'step': step,\n              'min': startValue,\n              'value': endValue,\n              'max': max,\n              'disabled': disabled,\n              'aria-label': getAriaLabel ? getAriaLabel(1) : ariaLabel,\n              'aria-valuetext': getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,\n              'aria-labelledby': ariaLabelledBy,\n              'onChange': handleChangeByNativeInput,\n            }}\n            isActive={activeThumb === 'end'}\n          />\n        )}\n      </div>\n    </Touch>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}