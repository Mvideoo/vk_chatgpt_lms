{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { useStableCallback } from \"../../hooks/useStableCallback.js\";\nimport { getWindow, isHTMLElement } from \"../../lib/dom.js\";\nimport { coordX, coordY, touchEnabled } from \"../../lib/touch/index.js\";\n/**\n * @see https://vkcom.github.io/VKUI/#/Touch\n */\nexport const Touch = _param => {\n  var {\n      onStart,\n      onStartX,\n      onStartY,\n      onMove,\n      onMoveX,\n      onMoveY,\n      onEnter,\n      onLeave,\n      onEnd,\n      onEndX,\n      onEndY,\n      onClickCapture,\n      usePointerHover,\n      slideThreshold = 5,\n      useCapture = false,\n      Component = 'div',\n      getRootRef,\n      noSlideClick = false,\n      stopPropagation = false\n    } = _param,\n    restProps = _object_without_properties(_param, [\"onStart\", \"onStartX\", \"onStartY\", \"onMove\", \"onMoveX\", \"onMoveY\", \"onEnter\", \"onLeave\", \"onEnd\", \"onEndX\", \"onEndY\", \"onClickCapture\", \"usePointerHover\", \"slideThreshold\", \"useCapture\", \"Component\", \"getRootRef\", \"noSlideClick\", \"stopPropagation\"]);\n  const [isTouchEnabled] = React.useState(touchEnabled);\n  const gestureRef = React.useRef(null);\n  const didSlide = React.useRef(false);\n  const disposeTargetNativeGestureEvents = React.useRef(null);\n  const cleanupTargetNativeGestureEvents = () => {\n    gestureRef.current = null;\n    if (disposeTargetNativeGestureEvents.current) {\n      disposeTargetNativeGestureEvents.current();\n      disposeTargetNativeGestureEvents.current = null;\n    }\n  };\n  React.useEffect(() => cleanupTargetNativeGestureEvents, []);\n  /**\n  * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onEnd`/`onEndX`/`onEndY`.\n  */\n  const handleNativePointerUp = useStableCallback(event => {\n    const gesture = gestureRef.current;\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n    if (gesture.isPressed) {\n      dispatchUserHandlers(event, gesture, [onEnd, onEndX, onEndY], stopPropagation);\n    }\n    if (isTouchEnabled) {\n      // https://github.com/VKCOM/VKUI/issues/4414\n      // если тач-устройство и был зафиксирован touchmove,\n      // то событие клика не вызывается\n      if (gesture.isSlide) {\n        didSlide.current = false;\n      }\n      // Если это был тач-евент, симулируем отмену hover\n      if (onLeave) {\n        onLeave(event);\n      }\n    } else {\n      didSlide.current = Boolean(gesture.isSlide);\n    }\n    cleanupTargetNativeGestureEvents();\n  });\n  /**\n  * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onMove`/`onMoveX`/`onMoveY`.\n  */\n  const handleNativePointerMove = useStableCallback(event => {\n    const gesture = gestureRef.current;\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n    const clientX = coordX(event);\n    const clientY = coordY(event);\n    // смещения\n    const shiftX = clientX - gesture.startX;\n    const shiftY = clientY - gesture.startY;\n    // абсолютные значения смещений\n    const shiftXAbs = Math.abs(shiftX);\n    const shiftYAbs = Math.abs(shiftY);\n    // Если определяем мультитач, то прерываем жест\n    if ('touches' in event && event.touches.length > 1) {\n      return handleNativePointerUp(event);\n    }\n    // если мы ещё не определились\n    if (!gesture.isX && !gesture.isY) {\n      const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;\n      const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;\n      const willBeSlidedX = willBeX && (!!onMoveX || !!onMove);\n      const willBeSlidedY = willBeY && (!!onMoveY || !!onMove);\n      gesture.isY = willBeY;\n      gesture.isX = willBeX;\n      gesture.isSlideX = willBeSlidedX;\n      gesture.isSlideY = willBeSlidedY;\n      gesture.isSlide = willBeSlidedX || willBeSlidedY;\n    }\n    if (gesture.isSlide) {\n      gesture.clientX = clientX;\n      gesture.clientY = clientY;\n      gesture.shiftX = shiftX;\n      gesture.shiftY = shiftY;\n      gesture.shiftXAbs = shiftXAbs;\n      gesture.shiftYAbs = shiftYAbs;\n      dispatchUserHandlers(event, gesture, [onMove, onMoveX, onMoveY], stopPropagation);\n    }\n  });\n  const handlePointerDown = event => {\n    const nativeEvent = event.nativeEvent;\n    gestureRef.current = initGesture(coordX(nativeEvent), coordY(nativeEvent));\n    const shouldCallDirectionHandlerOnlyIsSlide = false;\n    dispatchUserHandlers(event, gestureRef.current, [onStart, onStartX, onStartY], stopPropagation, shouldCallDirectionHandlerOnlyIsSlide);\n    const eventOptions = {\n      capture: useCapture,\n      passive: false\n    };\n    // FIXME: заменить touch/mouse-события ниже на pointer-события после того, как бразуеры из\n    // .browserslistrc начнут поддерживать его (см. https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events#browser_compatibility).\n    if (isTouchEnabled) {\n      if (isHTMLElement(event.target)) {\n        // Тач-события не всплывают, поэтому навешиваем события на целевой элемент\n        // см. #235, #1968, https://stackoverflow.com/a/45760014\n        const target = event.target;\n        target.addEventListener('touchmove', handleNativePointerMove, eventOptions);\n        target.addEventListener('touchend', handleNativePointerUp, eventOptions);\n        target.addEventListener('touchcancel', handleNativePointerUp, eventOptions);\n        disposeTargetNativeGestureEvents.current = () => {\n          target.removeEventListener('touchmove', handleNativePointerMove, eventOptions);\n          target.removeEventListener('touchend', handleNativePointerUp, eventOptions);\n          target.removeEventListener('touchcancel', handleNativePointerUp, eventOptions);\n        };\n      }\n    } else {\n      // Используем события на Document, т.к. mouse-события на целевом элементе могут теряться при\n      // выходе за границы этого элемента.\n      const doc = getWindow(event.currentTarget).document;\n      doc.addEventListener('mousemove', handleNativePointerMove, eventOptions);\n      doc.addEventListener('mouseup', handleNativePointerUp, eventOptions);\n      doc.addEventListener('mouseleave', handleNativePointerUp, eventOptions);\n      disposeTargetNativeGestureEvents.current = () => {\n        doc.removeEventListener('mousemove', handleNativePointerMove, eventOptions);\n        doc.removeEventListener('mouseup', handleNativePointerUp, eventOptions);\n        doc.removeEventListener('mouseleave', handleNativePointerUp, eventOptions);\n      };\n    }\n  };\n  const handlePointerEnter = onEnter ? event => onEnter(event.nativeEvent) : undefined;\n  const handlePointerLeave = onLeave ? event => onLeave(event.nativeEvent) : undefined;\n  /**\n  * Отменяет нативное браузерное поведение для вложенных ссылок и изображений\n  */\n  const handleDragStart = event => {\n    const target = event.target;\n    if (target.tagName === 'A' || target.tagName === 'IMG') {\n      event.preventDefault();\n    }\n  };\n  /**\n  * Отменяет переход по вложенной ссылке, если был зафиксирован свайп\n  */\n  const handleClickCapture = event => {\n    if (!didSlide.current) {\n      return onClickCapture && onClickCapture(event);\n    }\n    if (noSlideClick) {\n      event.stopPropagation();\n      // https://github.com/VKCOM/VKUI/issues/1977\n      // https://github.com/VKCOM/VKUI/issues/3892\n      event.preventDefault();\n    } else {\n      onClickCapture && onClickCapture(event);\n    }\n    didSlide.current = false;\n  };\n  return /*#__PURE__*/_jsx(Component, _object_spread_props(_object_spread({}, restProps), {\n    ref: getRootRef,\n    onDragStart: handleDragStart,\n    onClickCapture: handleClickCapture,\n    // onEnter\n    onPointerEnter: usePointerHover ? handlePointerEnter : undefined,\n    onMouseEnter: !usePointerHover ? handlePointerEnter : undefined,\n    // onLeave\n    onPointerLeave: usePointerHover ? handlePointerLeave : undefined,\n    onMouseLeave: !usePointerHover ? handlePointerLeave : undefined,\n    // handlePointerDown\n    onTouchStartCapture: isTouchEnabled && useCapture ? handlePointerDown : undefined,\n    onTouchStart: isTouchEnabled && !useCapture ? handlePointerDown : undefined,\n    onMouseDownCapture: !isTouchEnabled && useCapture ? handlePointerDown : undefined,\n    onMouseDown: !isTouchEnabled && !useCapture ? handlePointerDown : undefined\n  }));\n};\nfunction initGesture(startX, startY) {\n  return {\n    startX,\n    startY,\n    startT: new Date(),\n    duration: 0,\n    isPressed: true,\n    isY: false,\n    isX: false,\n    isSlideX: false,\n    isSlideY: false,\n    isSlide: false,\n    clientX: 0,\n    clientY: 0,\n    shiftX: 0,\n    shiftY: 0,\n    shiftXAbs: 0,\n    shiftYAbs: 0\n  };\n}\nfunction dispatchUserHandlers(event, gesture, _ref, stopPropagation) {\n  let [handler, handlerX, handlerY] = _ref;\n  let shouldCallDirectionHandlerOnlyIsSlide = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  if (stopPropagation) {\n    event.stopPropagation();\n  }\n  const data = _object_spread_props(_object_spread({}, gesture), {\n    originalEvent: event,\n    duration: Date.now() - gesture.startT.getTime()\n  });\n  if (handler) {\n    handler(data);\n  }\n  if (handlerX) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideX) {\n        handlerX(data);\n      }\n    } else {\n      handlerX(data);\n    }\n  }\n  if (handlerY) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideY) {\n        handlerY(data);\n      }\n    } else {\n      handlerY(data);\n    }\n  }\n}","map":{"version":3,"names":["React","useStableCallback","getWindow","isHTMLElement","coordX","coordY","touchEnabled","Touch","_param","onStart","onStartX","onStartY","onMove","onMoveX","onMoveY","onEnter","onLeave","onEnd","onEndX","onEndY","onClickCapture","usePointerHover","slideThreshold","useCapture","Component","getRootRef","noSlideClick","stopPropagation","restProps","_object_without_properties","isTouchEnabled","useState","gestureRef","useRef","didSlide","disposeTargetNativeGestureEvents","cleanupTargetNativeGestureEvents","current","useEffect","handleNativePointerUp","event","gesture","isPressed","dispatchUserHandlers","isSlide","Boolean","handleNativePointerMove","clientX","clientY","shiftX","startX","shiftY","startY","shiftXAbs","Math","abs","shiftYAbs","touches","length","isX","isY","willBeX","willBeY","willBeSlidedX","willBeSlidedY","isSlideX","isSlideY","handlePointerDown","nativeEvent","initGesture","shouldCallDirectionHandlerOnlyIsSlide","eventOptions","capture","passive","target","addEventListener","removeEventListener","doc","currentTarget","document","handlePointerEnter","undefined","handlePointerLeave","handleDragStart","tagName","preventDefault","handleClickCapture","_jsx","_object_spread_props","_object_spread","ref","onDragStart","onPointerEnter","onMouseEnter","onPointerLeave","onMouseLeave","onTouchStartCapture","onTouchStart","onMouseDownCapture","onMouseDown","startT","Date","duration","_ref","handler","handlerX","handlerY","arguments","data","originalEvent","now","getTime"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/Touch/Touch.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { useStableCallback } from '../../hooks/useStableCallback';\nimport { getWindow, isHTMLElement } from '../../lib/dom';\nimport { coordX, coordY, touchEnabled, type VKUITouchEvent } from '../../lib/touch';\nimport type { HasComponent, HasRootRef } from '../../types';\n\nexport interface CustomTouchEvent extends Gesture {\n  originalEvent: VKUITouchEvent;\n}\n\nexport type HoverHandler = (outputEvent: MouseEvent) => void;\n\nexport type CustomTouchEventHandler = (event: CustomTouchEvent) => void;\n\nexport interface TouchProps\n  extends React.AllHTMLAttributes<HTMLElement>,\n    HasRootRef<HTMLElement>,\n    HasComponent {\n  /**\n   * Привязать onEnter и onLeave через pointer-events - работает на disabled-инпутах\n   */\n  usePointerHover?: boolean;\n  useCapture?: boolean;\n  slideThreshold?: number;\n  noSlideClick?: boolean;\n  onEnter?: HoverHandler;\n  onLeave?: HoverHandler;\n  onStart?: CustomTouchEventHandler;\n  onStartX?: CustomTouchEventHandler;\n  onStartY?: CustomTouchEventHandler;\n  onMove?: CustomTouchEventHandler;\n  onMoveX?: CustomTouchEventHandler;\n  onMoveY?: CustomTouchEventHandler;\n  onEnd?: CustomTouchEventHandler;\n  onEndX?: CustomTouchEventHandler;\n  onEndY?: CustomTouchEventHandler;\n  stopPropagation?: boolean;\n}\n\nexport interface Gesture {\n  startX: number;\n  startY: number;\n  startT: Date;\n  duration: number;\n  isPressed: boolean;\n  isY: boolean;\n  isX: boolean;\n  isSlideX: boolean;\n  isSlideY: boolean;\n  isSlide: boolean;\n  clientX: number;\n  clientY: number;\n  shiftX: number;\n  shiftY: number;\n  shiftXAbs: number;\n  shiftYAbs: number;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Touch\n */\nexport const Touch = ({\n  onStart,\n  onStartX,\n  onStartY,\n  onMove,\n  onMoveX,\n  onMoveY,\n  onEnter,\n  onLeave,\n  onEnd,\n  onEndX,\n  onEndY,\n  onClickCapture,\n  usePointerHover,\n  slideThreshold = 5,\n  useCapture = false,\n  Component = 'div',\n  getRootRef,\n  noSlideClick = false,\n  stopPropagation = false,\n  ...restProps\n}: TouchProps) => {\n  const [isTouchEnabled] = React.useState(touchEnabled);\n  const gestureRef = React.useRef<Gesture | null>(null);\n  const didSlide = React.useRef(false);\n  const disposeTargetNativeGestureEvents = React.useRef<VoidFunction | null>(null);\n\n  const cleanupTargetNativeGestureEvents = () => {\n    gestureRef.current = null;\n    if (disposeTargetNativeGestureEvents.current) {\n      disposeTargetNativeGestureEvents.current();\n      disposeTargetNativeGestureEvents.current = null;\n    }\n  };\n\n  React.useEffect(() => cleanupTargetNativeGestureEvents, []);\n\n  /**\n   * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onEnd`/`onEndX`/`onEndY`.\n   */\n  const handleNativePointerUp = useStableCallback((event: MouseEvent | TouchEvent) => {\n    const gesture = gestureRef.current;\n\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n\n    if (gesture.isPressed) {\n      dispatchUserHandlers(event, gesture, [onEnd, onEndX, onEndY], stopPropagation);\n    }\n\n    if (isTouchEnabled) {\n      // https://github.com/VKCOM/VKUI/issues/4414\n      // если тач-устройство и был зафиксирован touchmove,\n      // то событие клика не вызывается\n      if (gesture.isSlide) {\n        didSlide.current = false;\n      }\n      // Если это был тач-евент, симулируем отмену hover\n      if (onLeave) {\n        onLeave(event as MouseEvent);\n      }\n    } else {\n      didSlide.current = Boolean(gesture.isSlide);\n    }\n\n    cleanupTargetNativeGestureEvents();\n  });\n\n  /**\n   * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onMove`/`onMoveX`/`onMoveY`.\n   */\n  const handleNativePointerMove = useStableCallback((event: MouseEvent | TouchEvent) => {\n    const gesture = gestureRef.current;\n\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n\n    const clientX = coordX(event);\n    const clientY = coordY(event);\n\n    // смещения\n    const shiftX = clientX - gesture.startX;\n    const shiftY = clientY - gesture.startY;\n\n    // абсолютные значения смещений\n    const shiftXAbs = Math.abs(shiftX);\n    const shiftYAbs = Math.abs(shiftY);\n\n    // Если определяем мультитач, то прерываем жест\n    if ('touches' in event && event.touches.length > 1) {\n      return handleNativePointerUp(event);\n    }\n\n    // если мы ещё не определились\n    if (!gesture.isX && !gesture.isY) {\n      const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;\n      const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;\n      const willBeSlidedX = willBeX && (!!onMoveX || !!onMove);\n      const willBeSlidedY = willBeY && (!!onMoveY || !!onMove);\n\n      gesture.isY = willBeY;\n      gesture.isX = willBeX;\n      gesture.isSlideX = willBeSlidedX;\n      gesture.isSlideY = willBeSlidedY;\n      gesture.isSlide = willBeSlidedX || willBeSlidedY;\n    }\n\n    if (gesture.isSlide) {\n      gesture.clientX = clientX;\n      gesture.clientY = clientY;\n      gesture.shiftX = shiftX;\n      gesture.shiftY = shiftY;\n      gesture.shiftXAbs = shiftXAbs;\n      gesture.shiftYAbs = shiftYAbs;\n\n      dispatchUserHandlers(event, gesture, [onMove, onMoveX, onMoveY], stopPropagation);\n    }\n  });\n\n  const handlePointerDown = (\n    event: React.MouseEvent<HTMLElement> | React.TouchEvent<HTMLElement>,\n  ) => {\n    const nativeEvent = event.nativeEvent;\n\n    gestureRef.current = initGesture(coordX(nativeEvent), coordY(nativeEvent));\n\n    const shouldCallDirectionHandlerOnlyIsSlide = false;\n    dispatchUserHandlers(\n      event,\n      gestureRef.current,\n      [onStart, onStartX, onStartY],\n      stopPropagation,\n      shouldCallDirectionHandlerOnlyIsSlide,\n    );\n\n    const eventOptions = { capture: useCapture, passive: false };\n\n    // FIXME: заменить touch/mouse-события ниже на pointer-события после того, как бразуеры из\n    // .browserslistrc начнут поддерживать его (см. https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events#browser_compatibility).\n    if (isTouchEnabled) {\n      if (isHTMLElement(event.target)) {\n        // Тач-события не всплывают, поэтому навешиваем события на целевой элемент\n        // см. #235, #1968, https://stackoverflow.com/a/45760014\n        const target = event.target;\n\n        target.addEventListener('touchmove', handleNativePointerMove, eventOptions);\n        target.addEventListener('touchend', handleNativePointerUp, eventOptions);\n        target.addEventListener('touchcancel', handleNativePointerUp, eventOptions);\n\n        disposeTargetNativeGestureEvents.current = () => {\n          target.removeEventListener('touchmove', handleNativePointerMove, eventOptions);\n          target.removeEventListener('touchend', handleNativePointerUp, eventOptions);\n          target.removeEventListener('touchcancel', handleNativePointerUp, eventOptions);\n        };\n      }\n    } else {\n      // Используем события на Document, т.к. mouse-события на целевом элементе могут теряться при\n      // выходе за границы этого элемента.\n      const doc = getWindow(event.currentTarget).document;\n\n      doc.addEventListener('mousemove', handleNativePointerMove, eventOptions);\n      doc.addEventListener('mouseup', handleNativePointerUp, eventOptions);\n      doc.addEventListener('mouseleave', handleNativePointerUp, eventOptions);\n\n      disposeTargetNativeGestureEvents.current = () => {\n        doc.removeEventListener('mousemove', handleNativePointerMove, eventOptions);\n        doc.removeEventListener('mouseup', handleNativePointerUp, eventOptions);\n        doc.removeEventListener('mouseleave', handleNativePointerUp, eventOptions);\n      };\n    }\n  };\n\n  const handlePointerEnter = onEnter\n    ? (event: React.MouseEvent<HTMLElement>) => onEnter(event.nativeEvent)\n    : undefined;\n\n  const handlePointerLeave = onLeave\n    ? (event: React.MouseEvent<HTMLElement>) => onLeave(event.nativeEvent)\n    : undefined;\n\n  /**\n   * Отменяет нативное браузерное поведение для вложенных ссылок и изображений\n   */\n  const handleDragStart = (event: React.DragEvent<HTMLElement>) => {\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'A' || target.tagName === 'IMG') {\n      event.preventDefault();\n    }\n  };\n\n  /**\n   * Отменяет переход по вложенной ссылке, если был зафиксирован свайп\n   */\n  const handleClickCapture: typeof onClickCapture = (event) => {\n    if (!didSlide.current) {\n      return onClickCapture && onClickCapture(event);\n    }\n\n    if (noSlideClick) {\n      event.stopPropagation();\n\n      // https://github.com/VKCOM/VKUI/issues/1977\n      // https://github.com/VKCOM/VKUI/issues/3892\n      event.preventDefault();\n    } else {\n      onClickCapture && onClickCapture(event);\n    }\n\n    didSlide.current = false;\n  };\n\n  return (\n    <Component\n      {...restProps}\n      ref={getRootRef}\n      onDragStart={handleDragStart}\n      onClickCapture={handleClickCapture}\n      // onEnter\n      onPointerEnter={usePointerHover ? handlePointerEnter : undefined}\n      onMouseEnter={!usePointerHover ? handlePointerEnter : undefined}\n      // onLeave\n      onPointerLeave={usePointerHover ? handlePointerLeave : undefined}\n      onMouseLeave={!usePointerHover ? handlePointerLeave : undefined}\n      // handlePointerDown\n      onTouchStartCapture={isTouchEnabled && useCapture ? handlePointerDown : undefined}\n      onTouchStart={isTouchEnabled && !useCapture ? handlePointerDown : undefined}\n      onMouseDownCapture={!isTouchEnabled && useCapture ? handlePointerDown : undefined}\n      onMouseDown={!isTouchEnabled && !useCapture ? handlePointerDown : undefined}\n    />\n  );\n};\n\nfunction initGesture(startX: number, startY: number): Gesture {\n  return {\n    startX,\n    startY,\n    startT: new Date(),\n    duration: 0,\n    isPressed: true,\n    isY: false,\n    isX: false,\n    isSlideX: false,\n    isSlideY: false,\n    isSlide: false,\n    clientX: 0,\n    clientY: 0,\n    shiftX: 0,\n    shiftY: 0,\n    shiftXAbs: 0,\n    shiftYAbs: 0,\n  };\n}\n\ntype Handlers = [\n  CustomTouchEventHandler | undefined,\n  CustomTouchEventHandler | undefined,\n  CustomTouchEventHandler | undefined,\n];\n\nfunction dispatchUserHandlers(\n  event: MouseEvent | TouchEvent | React.MouseEvent | React.TouchEvent,\n  gesture: Gesture,\n  [handler, handlerX, handlerY]: Handlers,\n  stopPropagation?: boolean,\n  shouldCallDirectionHandlerOnlyIsSlide = true,\n) {\n  if (stopPropagation) {\n    event.stopPropagation();\n  }\n\n  const data = {\n    ...gesture,\n    originalEvent: event as unknown as VKUITouchEvent,\n    duration: Date.now() - gesture.startT.getTime(),\n  };\n\n  if (handler) {\n    handler(data);\n  }\n\n  if (handlerX) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideX) {\n        handlerX(data);\n      }\n    } else {\n      handlerX(data);\n    }\n  }\n\n  if (handlerY) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideY) {\n        handlerY(data);\n      }\n    } else {\n      handlerY(data);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}