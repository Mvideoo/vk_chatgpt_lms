{"ast":null,"code":"import { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport * as React from \"react\";\nimport { isFunction } from \"@vkontakte/vkjs\";\nimport { useIsomorphicLayoutEffect } from \"../lib/useIsomorphicLayoutEffect.js\";\nimport { warnOnce } from \"../lib/warnOnce.js\";\nexport function useEnsuredControl(_param) {\n  var {\n      onChange: onChangeProp,\n      disabled\n    } = _param,\n    props = _object_without_properties(_param, [\"onChange\", \"disabled\"]);\n  const [value, onChangeValue] = useCustomEnsuredControl(props);\n  const onChange = React.useCallback(e => {\n    if (disabled) {\n      return;\n    }\n    onChangeValue(e.target.value);\n    onChangeProp && onChangeProp(e);\n  }, [onChangeValue, onChangeProp, disabled]);\n  return [value, onChange];\n}\nconst warn = warnOnce('useCustomEnsuredControl');\nexport function useCustomEnsuredControl(_ref) {\n  let {\n    value,\n    defaultValue,\n    disabled,\n    onChange: onChangeProp\n  } = _ref;\n  const isControlled = value !== undefined;\n  const [localValue, setLocalValue] = React.useState(defaultValue);\n  const preservedControlledValueRef = React.useRef(undefined);\n  useIsomorphicLayoutEffect(() => {\n    preservedControlledValueRef.current = value;\n  });\n  /*\n  * Для ситуации, когда nextValue это пользовательская функция,\n  * и в качестве аргумента мы должны передать prevValue.\n  * Обычно в качестве prevValue используется preservedControlledValueRef, но оно может быть undefined, если\n  * некотролируемое value вдруг стало контролируемым\n  * (value = undefined ---> value = true)\n  * Если в момент вызова onChange preservedControlledValueRef ещё не был\n  * обновлён в useEffect, то мы не можем использовать preservedControlledValueRef как prevValue\n  * В качестве запасного варианта мы храним текущее значение value в currentFallbackValueRef, чтобы\n  * использовать его вместо preservedControlledValueRef.\n  */\n  const currentFallbackValueRef = React.useRef(value);\n  currentFallbackValueRef.current = value;\n  const onChange = React.useCallback(nextValue => {\n    if (disabled) {\n      return;\n    }\n    if (isFunction(nextValue)) {\n      if (!isControlled) {\n        setLocalValue(prevValue => {\n          const resolvedValue = nextValue(prevValue);\n          if (onChangeProp) {\n            onChangeProp(resolvedValue);\n          }\n          return resolvedValue;\n        });\n      } else if (onChangeProp) {\n        if (process.env.NODE_ENV === 'development') {\n          if (preservedControlledValueRef.current === undefined) {\n            warn(`Похоже, что при вызове onChange с аргументом nextValue в виде коллбэка, состояние компонента было переведено из неконтролируемого (\"undefined\") в контролируемое. Пожалуйста, старайтесь сохранять либо неконтролируемое состояние, либо контролируемое на всём промежутке жизненного цикла компонента, чтобы получать предсказуемое значение prevValue в коллбэке nextValue((prevValue: V) => V)`, 'error');\n          }\n        }\n        const prevValue = preservedControlledValueRef.current === undefined ? currentFallbackValueRef.current : preservedControlledValueRef.current;\n        // В теории prevValue не может быть undefined,\n        // но лучше не вызывать nextValue с таким значением\n        if (prevValue !== undefined) {\n          const resolvedValue = nextValue(prevValue);\n          onChangeProp(resolvedValue);\n        }\n      }\n    } else {\n      if (onChangeProp) {\n        onChangeProp(nextValue);\n      }\n      if (!isControlled) {\n        setLocalValue(nextValue);\n      }\n    }\n  }, [disabled, isControlled, onChangeProp]);\n  return [isControlled ? value : localValue, onChange];\n}","map":{"version":3,"names":["React","isFunction","useIsomorphicLayoutEffect","warnOnce","useEnsuredControl","_param","onChange","onChangeProp","disabled","props","_object_without_properties","value","onChangeValue","useCustomEnsuredControl","useCallback","e","target","warn","_ref","defaultValue","isControlled","undefined","localValue","setLocalValue","useState","preservedControlledValueRef","useRef","current","currentFallbackValueRef","nextValue","prevValue","resolvedValue","process","env","NODE_ENV"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/hooks/useEnsuredControl.ts"],"sourcesContent":["import * as React from 'react';\nimport { isFunction } from '@vkontakte/vkjs';\nimport { useIsomorphicLayoutEffect } from '../lib/useIsomorphicLayoutEffect';\nimport { warnOnce } from '../lib/warnOnce';\n\nexport interface UseEnsuredControlProps<V, E extends React.ChangeEvent<any>> {\n  value?: V;\n  defaultValue: V;\n  disabled?: boolean | undefined;\n  onChange?: (this: void, e: E) => any;\n}\n\nexport function useEnsuredControl<V, E extends React.ChangeEvent<any>>({\n  onChange: onChangeProp,\n  disabled,\n  ...props\n}: UseEnsuredControlProps<V, E>): [V, (e: E) => any] {\n  const [value, onChangeValue] = useCustomEnsuredControl(props);\n\n  const onChange = React.useCallback(\n    (e: E) => {\n      if (disabled) {\n        return;\n      }\n\n      onChangeValue(e.target.value);\n      onChangeProp && onChangeProp(e);\n    },\n    [onChangeValue, onChangeProp, disabled],\n  );\n\n  return [value, onChange];\n}\n\nexport interface UseCustomEnsuredControlProps<V> {\n  value?: V;\n  defaultValue: V;\n  disabled?: boolean | undefined;\n  onChange?: (this: void, v: V) => any;\n}\n\nconst warn = warnOnce('useCustomEnsuredControl');\n\nexport function useCustomEnsuredControl<V = any>({\n  value,\n  defaultValue,\n  disabled,\n  onChange: onChangeProp,\n}: UseCustomEnsuredControlProps<V>): [V, React.Dispatch<React.SetStateAction<V>>] {\n  const isControlled = value !== undefined;\n  const [localValue, setLocalValue] = React.useState(defaultValue);\n\n  const preservedControlledValueRef = React.useRef<V | undefined>(undefined);\n  useIsomorphicLayoutEffect(() => {\n    preservedControlledValueRef.current = value;\n  });\n\n  /*\n   * Для ситуации, когда nextValue это пользовательская функция,\n   * и в качестве аргумента мы должны передать prevValue.\n   * Обычно в качестве prevValue используется preservedControlledValueRef, но оно может быть undefined, если\n   * некотролируемое value вдруг стало контролируемым\n   * (value = undefined ---> value = true)\n   * Если в момент вызова onChange preservedControlledValueRef ещё не был\n   * обновлён в useEffect, то мы не можем использовать preservedControlledValueRef как prevValue\n   * В качестве запасного варианта мы храним текущее значение value в currentFallbackValueRef, чтобы\n   * использовать его вместо preservedControlledValueRef.\n   */\n  const currentFallbackValueRef = React.useRef<V | undefined>(value);\n  currentFallbackValueRef.current = value;\n\n  const onChange = React.useCallback(\n    (nextValue: React.SetStateAction<V>) => {\n      if (disabled) {\n        return;\n      }\n\n      if (isFunction(nextValue)) {\n        if (!isControlled) {\n          setLocalValue((prevValue) => {\n            const resolvedValue = nextValue(prevValue);\n            if (onChangeProp) {\n              onChangeProp(resolvedValue);\n            }\n            return resolvedValue;\n          });\n        } else if (onChangeProp) {\n          if (process.env.NODE_ENV === 'development') {\n            if (preservedControlledValueRef.current === undefined) {\n              warn(\n                `Похоже, что при вызове onChange с аргументом nextValue в виде коллбэка, состояние компонента было переведено из неконтролируемого (\"undefined\") в контролируемое. Пожалуйста, старайтесь сохранять либо неконтролируемое состояние, либо контролируемое на всём промежутке жизненного цикла компонента, чтобы получать предсказуемое значение prevValue в коллбэке nextValue((prevValue: V) => V)`,\n                'error',\n              );\n            }\n          }\n\n          const prevValue =\n            preservedControlledValueRef.current === undefined\n              ? currentFallbackValueRef.current\n              : preservedControlledValueRef.current;\n          // В теории prevValue не может быть undefined,\n          // но лучше не вызывать nextValue с таким значением\n          if (prevValue !== undefined) {\n            const resolvedValue = nextValue(prevValue);\n            onChangeProp(resolvedValue);\n          }\n        }\n      } else {\n        if (onChangeProp) {\n          onChangeProp(nextValue);\n        }\n        if (!isControlled) {\n          setLocalValue(nextValue);\n        }\n      }\n    },\n    [disabled, isControlled, onChangeProp],\n  );\n\n  return [isControlled ? value : localValue, onChange];\n}\n"],"mappings":";AAAA,YAAYA,KAAA,MAAW;AACvB,SAASC,UAAU,QAAQ;AAC3B,SAASC,yBAAyB,QAAQ;AAC1C,SAASC,QAAQ,QAAQ;AASzB,OAAO,SAASC,kBAAuDC,MAAA;MAAA;MACrEC,QAAA,EAAUC,YAAY;MACtBC;IAAQ,CAEqB,GAJwCH,MAAA;IAGlEI,KAAA,GAAAC,0BAAA,CAHkEL,MAAA,GACrE,YACA,W;EAGA,MAAM,CAACM,KAAA,EAAOC,aAAA,CAAc,GAAGC,uBAAA,CAAwBJ,KAAA;EAEvD,MAAMH,QAAA,GAAWN,KAAA,CAAMc,WAAW,CAC/BC,CAAA;IACC,IAAIP,QAAA,EAAU;MACZ;IACF;IAEAI,aAAA,CAAcG,CAAA,CAAEC,MAAM,CAACL,KAAK;IAC5BJ,YAAA,IAAgBA,YAAA,CAAaQ,CAAA;EAC/B,GACA,CAACH,aAAA,EAAeL,YAAA,EAAcC,QAAA,CAAS;EAGzC,OAAO,CAACG,KAAA,EAAOL,QAAA,CAAS;AAC1B;AASA,MAAMW,IAAA,GAAOd,QAAA,CAAS;AAEtB,OAAO,SAASU,wBAAAK,IAAA,EAKkB;EAAA,IALe;IAC/CP,KAAK;IACLQ,YAAY;IACZX,QAAQ;IACRF,QAAA,EAAUC;EAAY,CACU,GAAAW,IAAA;EAChC,MAAME,YAAA,GAAeT,KAAA,KAAUU,SAAA;EAC/B,MAAM,CAACC,UAAA,EAAYC,aAAA,CAAc,GAAGvB,KAAA,CAAMwB,QAAQ,CAACL,YAAA;EAEnD,MAAMM,2BAAA,GAA8BzB,KAAA,CAAM0B,MAAM,CAAgBL,SAAA;EAChEnB,yBAAA,CAA0B;IACxBuB,2BAAA,CAA4BE,OAAO,GAAGhB,KAAA;EACxC;EAEA;;;;;;;;;;;EAWA,MAAMiB,uBAAA,GAA0B5B,KAAA,CAAM0B,MAAM,CAAgBf,KAAA;EAC5DiB,uBAAA,CAAwBD,OAAO,GAAGhB,KAAA;EAElC,MAAML,QAAA,GAAWN,KAAA,CAAMc,WAAW,CAC/Be,SAAA;IACC,IAAIrB,QAAA,EAAU;MACZ;IACF;IAEA,IAAIP,UAAA,CAAW4B,SAAA,GAAY;MACzB,IAAI,CAACT,YAAA,EAAc;QACjBG,aAAA,CAAeO,SAAA;UACb,MAAMC,aAAA,GAAgBF,SAAA,CAAUC,SAAA;UAChC,IAAIvB,YAAA,EAAc;YAChBA,YAAA,CAAawB,aAAA;UACf;UACA,OAAOA,aAAA;QACT;MACF,OAAO,IAAIxB,YAAA,EAAc;QACvB,IAAIyB,OAAA,CAAQC,GAAG,CAACC,QAAQ,KAAK,eAAe;UAC1C,IAAIT,2BAAA,CAA4BE,OAAO,KAAKN,SAAA,EAAW;YACrDJ,IAAA,CACE,mYAAmY,EACnY;UAEJ;QACF;QAEA,MAAMa,SAAA,GACJL,2BAAA,CAA4BE,OAAO,KAAKN,SAAA,GACpCO,uBAAA,CAAwBD,OAAO,GAC/BF,2BAAA,CAA4BE,OAAO;QACzC;QACA;QACA,IAAIG,SAAA,KAAcT,SAAA,EAAW;UAC3B,MAAMU,aAAA,GAAgBF,SAAA,CAAUC,SAAA;UAChCvB,YAAA,CAAawB,aAAA;QACf;MACF;IACF,OAAO;MACL,IAAIxB,YAAA,EAAc;QAChBA,YAAA,CAAasB,SAAA;MACf;MACA,IAAI,CAACT,YAAA,EAAc;QACjBG,aAAA,CAAcM,SAAA;MAChB;IACF;EACF,GACA,CAACrB,QAAA,EAAUY,YAAA,EAAcb,YAAA,CAAa;EAGxC,OAAO,CAACa,YAAA,GAAeT,KAAA,GAAQW,UAAA,EAAYhB,QAAA,CAAS;AACtD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}