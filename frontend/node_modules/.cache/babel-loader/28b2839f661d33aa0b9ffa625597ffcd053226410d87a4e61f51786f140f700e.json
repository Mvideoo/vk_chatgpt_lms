{"ast":null,"code":"import { TZDateMini } from \"@date-fns/tz\";\nimport { lightFormat } from \"date-fns\";\nexport function parse(input, format) {\n  let referenceDate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Date();\n  const match2 = /^\\d\\d/; // 00 - 99\n  const match4 = /^\\d{4}/; // 0000 - 9999\n  const entries = [['yyyy', match4, val => ['Y', +val, true]], ['MM', match2, val => {\n    const numVal = +val;\n    const okay = numVal > 0 && numVal <= 12;\n    return ['M', numVal - 1, okay];\n  }], ['dd', match2, val => ['D', +val, true]], ['HH', match2, val => {\n    const numVal = parseInt(val, 10);\n    const okay = numVal >= 0 && numVal < 24;\n    return ['h', numVal, okay];\n  }], ['mm', match2, val => {\n    const numVal = parseInt(val, 10);\n    const okay = numVal >= 0 && numVal < 60;\n    return ['m', numVal, okay];\n  }]];\n  const superRegExp = new RegExp(entries.map(item => item[0]).join('|'), 'g');\n  const store = {\n    y: referenceDate.getFullYear(),\n    M: referenceDate.getMonth(),\n    d: referenceDate.getDate(),\n    h: referenceDate.getHours(),\n    m: referenceDate.getMinutes(),\n    s: referenceDate.getSeconds(),\n    ms: referenceDate.getMilliseconds()\n  };\n  let prevInputIndex = 0;\n  let lastNonFormatting = '';\n  let lastFormatIndex = 0;\n  let found = false;\n  while (true) {\n    const match = superRegExp.exec(format);\n    if (!match) {\n      break;\n    }\n    const length = match[0].length;\n    const atIndex = superRegExp.lastIndex - length;\n    const item = entries.find(item => item[0] === match[0]);\n    lastNonFormatting = format.slice(lastFormatIndex, atIndex);\n    lastFormatIndex = superRegExp.lastIndex;\n    if (input.slice(prevInputIndex, prevInputIndex + lastNonFormatting.length) !== lastNonFormatting) {\n      return new Date('');\n    }\n    const value = input.slice(prevInputIndex + lastNonFormatting.length).match(item[1]);\n    if (!value) {\n      return new Date('');\n    }\n    prevInputIndex = prevInputIndex + lastNonFormatting.length + value[0].length;\n    const [key, newValue, okay] = item[2](value[0]);\n    if (!okay) {\n      return new Date('');\n    }\n    store[key] = newValue;\n    found = true;\n  }\n  if (!found) {\n    return new Date('');\n  }\n  const date = new Date(store.Y, store.M, store.D, store.h, store.m, store.s, store.ms);\n  // Since days of months are dynamic, they can't be validated in entries,\n  // so we check it here, in the finalized date\n  if (date.getMonth() !== store.M || date.getDate() !== store.D) {\n    return new Date('');\n  }\n  return date;\n}\nexport const convertDateToTimeZone = (date, timezone) => {\n  if (!timezone) {\n    return date;\n  }\n  return date ? TZDateMini.tz(timezone, date) : undefined;\n};\nexport const convertDateFromTimeZone = (date, timezone) => {\n  if (!timezone) {\n    return date;\n  }\n  // eslint-disable-next-line new-cap\n  const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n  return date ? TZDateMini.tz(systemTimezone, date) : undefined;\n};\nexport function format(date, format) {\n  return lightFormat(date, format);\n}\nexport function isMatch(input, format) {\n  return !isNaN(+parse(input, format));\n}","map":{"version":3,"names":["TZDateMini","lightFormat","parse","input","format","referenceDate","arguments","length","undefined","Date","match2","match4","entries","val","numVal","okay","parseInt","superRegExp","RegExp","map","item","join","store","y","getFullYear","M","getMonth","d","getDate","h","getHours","m","getMinutes","s","getSeconds","ms","getMilliseconds","prevInputIndex","lastNonFormatting","lastFormatIndex","found","match","exec","atIndex","lastIndex","find","slice","value","key","newValue","date","Y","D","convertDateToTimeZone","timezone","tz","convertDateFromTimeZone","systemTimezone","Intl","DateTimeFormat","resolvedOptions","timeZone","isMatch","isNaN"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/lib/date.ts"],"sourcesContent":["import { TZDateMini } from '@date-fns/tz';\nimport { lightFormat } from 'date-fns';\n\nexport function parse(input: string, format: string, referenceDate: Date = new Date()): Date {\n  const match2 = /^\\d\\d/; // 00 - 99\n  const match4 = /^\\d{4}/; // 0000 - 9999\n\n  const entries: Array<[string, RegExp, (val: string) => [string, number, boolean]]> = [\n    ['yyyy', match4, (val) => ['Y', +val, true]],\n    [\n      'MM',\n      match2,\n      (val) => {\n        const numVal = +val;\n        const okay = numVal > 0 && numVal <= 12;\n\n        return ['M', numVal - 1, okay];\n      },\n    ],\n    ['dd', match2, (val) => ['D', +val, true]],\n    [\n      'HH',\n      match2,\n      (val) => {\n        const numVal = parseInt(val, 10);\n        const okay = numVal >= 0 && numVal < 24;\n\n        return ['h', numVal, okay];\n      },\n    ],\n    [\n      'mm',\n      match2,\n      (val) => {\n        const numVal = parseInt(val, 10);\n        const okay = numVal >= 0 && numVal < 60;\n\n        return ['m', numVal, okay];\n      },\n    ],\n  ];\n\n  const superRegExp = new RegExp(entries.map((item) => item[0]).join('|'), 'g');\n\n  const store: {\n    [key: string]: number;\n  } = {\n    y: referenceDate.getFullYear(),\n    M: referenceDate.getMonth(),\n    d: referenceDate.getDate(),\n    h: referenceDate.getHours(),\n    m: referenceDate.getMinutes(),\n    s: referenceDate.getSeconds(),\n    ms: referenceDate.getMilliseconds(),\n  };\n\n  let prevInputIndex = 0;\n  let lastNonFormatting = '';\n  let lastFormatIndex = 0;\n  let found = false;\n\n  while (true) {\n    const match = superRegExp.exec(format);\n\n    if (!match) {\n      break;\n    }\n\n    const length = match[0].length;\n    const atIndex = superRegExp.lastIndex - length;\n\n    const item = entries.find((item) => item[0] === match[0])!;\n\n    lastNonFormatting = format.slice(lastFormatIndex, atIndex);\n    lastFormatIndex = superRegExp.lastIndex;\n\n    if (\n      input.slice(prevInputIndex, prevInputIndex + lastNonFormatting.length) !== lastNonFormatting\n    ) {\n      return new Date('');\n    }\n\n    const value = input.slice(prevInputIndex + lastNonFormatting.length).match(item[1]);\n\n    if (!value) {\n      return new Date('');\n    }\n\n    prevInputIndex = prevInputIndex + lastNonFormatting.length + value[0].length;\n\n    const [key, newValue, okay] = item[2](value[0]);\n\n    if (!okay) {\n      return new Date('');\n    }\n\n    store[key] = newValue;\n    found = true;\n  }\n\n  if (!found) {\n    return new Date('');\n  }\n\n  const date = new Date(store.Y, store.M, store.D, store.h, store.m, store.s, store.ms);\n\n  // Since days of months are dynamic, they can't be validated in entries,\n  // so we check it here, in the finalized date\n  if (date.getMonth() !== store.M || date.getDate() !== store.D) {\n    return new Date('');\n  }\n\n  return date;\n}\n\nexport const convertDateToTimeZone = (\n  date?: Date | null,\n  timezone?: string,\n): Date | undefined | null => {\n  if (!timezone) {\n    return date;\n  }\n  return date ? TZDateMini.tz(timezone, date) : undefined;\n};\n\nexport const convertDateFromTimeZone = (\n  date?: Date | null,\n  timezone?: string,\n): Date | undefined | null => {\n  if (!timezone) {\n    return date;\n  }\n  // eslint-disable-next-line new-cap\n  const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n  return date ? TZDateMini.tz(systemTimezone, date) : undefined;\n};\n\nexport function format(date: Date | number, format: string): string {\n  return lightFormat(date, format);\n}\n\nexport function isMatch(input: string, format: string): boolean {\n  return !isNaN(+parse(input, format));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}