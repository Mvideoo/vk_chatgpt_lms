{"ast":null,"code":"'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { useAdaptivityHasPointer } from \"../../hooks/useAdaptivityHasPointer.js\";\nimport { useConfigDirection } from \"../../hooks/useConfigDirection.js\";\nimport { useExternRef } from \"../../hooks/useExternRef.js\";\nimport { useMutationObserver } from \"../../hooks/useMutationObserver.js\";\nimport { useResizeObserver } from \"../../hooks/useResizeObserver.js\";\nimport { useDOM } from \"../../lib/dom.js\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect.js\";\nimport { warnOnce } from \"../../lib/warnOnce.js\";\nimport { RootComponent } from \"../RootComponent/RootComponent.js\";\nimport { Bullets } from \"./Bullets.js\";\nimport { CarouselViewPort } from \"./CarouselViewPort.js\";\nimport { ScrollArrows } from \"./ScrollArrows.js\";\nimport { ANIMATION_DURATION, CONTROL_ELEMENTS_STATE, SLIDE_THRESHOLD, SLIDES_MANAGER_STATE } from \"./constants.js\";\nimport { calcMax, calcMin, calculateIndent, getLoopPoints, getTargetIndex, isBigger, isBiggerOrEqual, isLowerOrEqual, revertRtlValue, validateIndent } from \"./helpers.js\";\nimport { useSlideAnimation } from \"./hooks.js\";\nconst warn = warnOnce('Gallery');\nexport const CarouselBase = _param => {\n  var {\n      bullets = false,\n      getRootRef,\n      children,\n      slideWidth = '100%',\n      slideIndex = 0,\n      dragDisabled = false,\n      resizeSource = 'window',\n      onDragStart,\n      onDragEnd,\n      onChange,\n      onPrevClick,\n      onNextClick,\n      align = 'left',\n      showArrows,\n      getRef,\n      arrowSize,\n      arrowAreaHeight,\n      slideTestId,\n      bulletTestId,\n      nextArrowTestId,\n      prevArrowTestId,\n      looped = false\n    } = _param,\n    restProps = _object_without_properties(_param, [\"bullets\", \"getRootRef\", \"children\", \"slideWidth\", \"slideIndex\", \"dragDisabled\", \"resizeSource\", \"onDragStart\", \"onDragEnd\", \"onChange\", \"onPrevClick\", \"onNextClick\", \"align\", \"showArrows\", \"getRef\", \"arrowSize\", \"arrowAreaHeight\", \"slideTestId\", \"bulletTestId\", \"nextArrowTestId\", \"prevArrowTestId\", \"looped\"]);\n  const slidesStore = React.useRef({});\n  const slidesManager = React.useRef(SLIDES_MANAGER_STATE);\n  const textDirection = useConfigDirection();\n  const isRtl = textDirection === 'rtl';\n  const rootRef = useExternRef(getRootRef);\n  const viewportRef = useExternRef(getRef);\n  const layerRef = React.useRef(null);\n  const animationFrameRef = React.useRef(null);\n  const shiftXCurrentRef = React.useRef(0);\n  const shiftXDeltaRef = React.useRef(0);\n  const initialized = React.useRef(false);\n  const {\n    addToAnimationQueue,\n    getAnimateFunction,\n    startAnimation\n  } = useSlideAnimation();\n  const isDragging = React.useRef(false);\n  const [controlElementsState, setControlElementsState] = React.useState(CONTROL_ELEMENTS_STATE);\n  const hasPointer = useAdaptivityHasPointer();\n  const isCenterAlign = align === 'center';\n  const calculateCanSlideLeft = () => {\n    if (looped) {\n      return !slidesManager.current.isFullyVisible;\n    }\n    const isStartShiftX = isBiggerOrEqual(shiftXCurrentRef.current, 0, isRtl);\n    return !slidesManager.current.isFullyVisible && !isStartShiftX;\n  };\n  const calculateCanSlideRight = () => {\n    if (looped) {\n      return !slidesManager.current.isFullyVisible;\n    }\n    var _slidesManager_current_layerWidth;\n    return !slidesManager.current.isFullyVisible && (\n    // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n    align === 'left' && slidesManager.current.containerWidth - revertRtlValue(shiftXCurrentRef.current, isRtl) < ((_slidesManager_current_layerWidth = slidesManager.current.layerWidth) !== null && _slidesManager_current_layerWidth !== void 0 ? _slidesManager_current_layerWidth : 0) ||\n    // otherwise we need to check current slide index (align = right or align = center)\n    align !== 'left' && slideIndex < slidesManager.current.slides.length - 1);\n  };\n  const transformCssStyles = function (shiftX) {\n    let animation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    shiftX = Math.round(shiftX);\n    if (looped) {\n      slidesManager.current.loopPoints.forEach(loopPoint => {\n        const {\n          target,\n          index\n        } = loopPoint;\n        const slide = slidesStore.current[index];\n        if (slide) {\n          slide.style.transform = `translate3d(${target(shiftX)}px, 0, 0)`;\n        }\n      });\n    } else {\n      Object.values(slidesStore.current).forEach(slide => {\n        if (slide) {\n          slide.style.transform = '';\n        }\n      });\n    }\n    if (layerRef.current) {\n      const indent = isDragging.current && !looped ? validateIndent(slidesManager.current, shiftXCurrentRef.current + shiftXDeltaRef.current, isRtl, false) : shiftX;\n      layerRef.current.style.transform = `translate3d(${indent}px, 0, 0)`;\n      layerRef.current.style.transition = animation ? `transform ${ANIMATION_DURATION}ms cubic-bezier(.1, 0, .25, 1)` : '';\n    }\n  };\n  const checkShiftOutOfBoundsFromStart = (shiftX, snaps) => isBigger(shiftX, snaps[0], isRtl);\n  const checkShiftOutOfBoundsFromEnd = (shiftX, slides) => {\n    /**\n    * Поскольку при `align=\"center\"` слайды сдвинуты, прежде чем рассчитать крайнюю правую точку,\n    * нужно вычесть сдвиг слайдов\n    */\n    const firstSlideShift = align === 'center' ? (slidesManager.current.containerWidth - slidesManager.current.slides[0].width) / 2 : 0;\n    const lastPoint = slides[slides.length - 1].width + slides[slides.length - 1].coordX - firstSlideShift;\n    return isRtl ? shiftX >= lastPoint : shiftX <= -lastPoint;\n  };\n  const requestTransform = function (shiftX) {\n    let animation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      snaps,\n      contentSize,\n      slides\n    } = slidesManager.current;\n    if (animationFrameRef.current !== null) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      /**\n      * Для бесконечной галереи проверяем, что при dnd мы прокрутили левее, чем первый слайд,\n      * чтобы сбросить `shiftXCurrentRef`\n      */\n      if (looped && checkShiftOutOfBoundsFromStart(shiftX, snaps)) {\n        const firstSnap = revertRtlValue(snaps[0], isRtl);\n        shiftXCurrentRef.current = revertRtlValue(-contentSize + firstSnap, isRtl);\n        shiftX = shiftXCurrentRef.current + shiftXDeltaRef.current;\n      }\n      /**\n      * Для бесконечной галереи проверяем, что при dnd мы прокрутили правее, чем последний слайд,\n      * чтобы правильно пересчитать `shiftXCurrentRef`\n      */\n      if (looped && checkShiftOutOfBoundsFromEnd(shiftX, slides)) {\n        shiftXCurrentRef.current = Math.abs(shiftXDeltaRef.current) + snaps[0];\n      }\n      transformCssStyles(shiftX, animation);\n    });\n  };\n  const initializeSlides = () => {\n    var _localSlides_slideIndex;\n    if (!rootRef.current || !viewportRef.current || !layerRef.current) {\n      return;\n    }\n    const layerOffsetWidth = layerRef.current.offsetWidth;\n    const calcRtlCoord = element => {\n      const offsetLeft = element.offsetLeft;\n      const offsetWidth = element.offsetWidth;\n      return layerOffsetWidth - offsetLeft - offsetWidth;\n    };\n    let localSlides = React.Children.map(children, (_item, i) => {\n      const elem = slidesStore.current[i];\n      if (!elem) {\n        return {\n          coordX: 0,\n          width: 0\n        };\n      }\n      const coordX = isRtl ? calcRtlCoord(elem) : elem.offsetLeft;\n      return {\n        coordX,\n        width: elem.offsetWidth\n      };\n    }) || [];\n    if (localSlides.length === 0) {\n      initialized.current = false;\n      return;\n    }\n    const containerWidth = rootRef.current.offsetWidth;\n    const viewportOffsetWidth = viewportRef.current.offsetWidth;\n    const layerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);\n    if (process.env.NODE_ENV === 'development' && looped) {\n      let remainingWidth = containerWidth;\n      let slideIndex = 0;\n      while (remainingWidth > 0 && slideIndex < localSlides.length) {\n        remainingWidth -= localSlides[slideIndex].width;\n        slideIndex++;\n      }\n      if (remainingWidth <= 0 && slideIndex === localSlides.length) {\n        warn('Ширины слайдов недостаточно для корректной работы свойства \"looped\". Пожалуйста, сделайте её больше.');\n      }\n    }\n    var _localSlides_slideIndex_width;\n    const currentSlideOffsetOnCenterAlignment = (containerWidth - ((_localSlides_slideIndex_width = (_localSlides_slideIndex = localSlides[slideIndex]) === null || _localSlides_slideIndex === void 0 ? void 0 : _localSlides_slideIndex.width) !== null && _localSlides_slideIndex_width !== void 0 ? _localSlides_slideIndex_width : 0)) / 2;\n    const isFullyVisible = align === 'center' ? layerWidth + currentSlideOffsetOnCenterAlignment <= containerWidth : layerWidth <= containerWidth;\n    const onlyOneSlide = localSlides.length === 1;\n    slidesManager.current = _object_spread_props(_object_spread({}, slidesManager.current), {\n      layerWidth,\n      containerWidth,\n      viewportOffsetWidth,\n      slides: localSlides,\n      isFullyVisible,\n      max: looped || onlyOneSlide ? null : calcMax({\n        slides: localSlides,\n        containerWidth,\n        isCenterAlign,\n        isRtl\n      }),\n      min: looped || onlyOneSlide ? null : calcMin({\n        containerWidth,\n        layerWidth,\n        slides: localSlides,\n        viewportOffsetWidth,\n        isFullyVisible,\n        align,\n        isRtl\n      })\n    });\n    const snaps = localSlides.map((_, index) => calculateIndent({\n      targetIndex: index,\n      slidesManager: slidesManager.current,\n      isCenter: isCenterAlign,\n      looped,\n      isRtl\n    }));\n    let contentSize = Math.abs(snaps[snaps.length - 1]) + localSlides[localSlides.length - 1].width;\n    if (align === 'center') {\n      contentSize += revertRtlValue(snaps[0], isRtl);\n    }\n    slidesManager.current.snaps = snaps;\n    slidesManager.current.contentSize = contentSize;\n    // Если галерея не зациклена и слайд всего один, то рассчитывать loopPoints тоже не надо\n    if (looped && !onlyOneSlide && !isFullyVisible) {\n      slidesManager.current.loopPoints = getLoopPoints(slidesManager.current, containerWidth, isRtl);\n    }\n    shiftXCurrentRef.current = snaps[slideIndex];\n    initialized.current = true;\n    setControlElementsState({\n      canSlideLeft: calculateCanSlideLeft(),\n      canSlideRight: calculateCanSlideRight(),\n      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible)\n    });\n    requestTransform(shiftXCurrentRef.current);\n  };\n  const onResize = () => {\n    if (initialized.current) {\n      initializeSlides();\n    }\n  };\n  const {\n    window\n  } = useDOM();\n  useResizeObserver(resizeSource === 'element' ? rootRef : window, onResize);\n  const loopedSlideChangePerform = () => {\n    const {\n      snaps,\n      slides\n    } = slidesManager.current;\n    const indent = snaps[slideIndex];\n    let startPoint = shiftXCurrentRef.current;\n    const fromLastToFirst = isLowerOrEqual(shiftXCurrentRef.current, snaps[snaps.length - 1], isRtl);\n    /**\n    * Переключаемся с последнего элемента на первый\n    * Для корректной анимации мы прокручиваем последний слайд на всю длину (shiftX) \"вперед\"\n    * В конце анимации при отрисовке следующего кадра задаем всем слайдам начальные значения\n    */\n    if (indent === snaps[0] && fromLastToFirst) {\n      const endEdge = revertRtlValue(Math.abs(snaps[snaps.length - 1]) + slides[slides.length - 1].width, isRtl);\n      const distance = endEdge + startPoint;\n      addToAnimationQueue(getAnimateFunction(progress => {\n        const shiftX = startPoint + progress * distance * -1;\n        transformCssStyles(shiftX);\n        if (shiftX <= snaps[snaps.length - 1] - slides[slides.length - 1].width) {\n          requestAnimationFrame(() => {\n            shiftXCurrentRef.current = indent;\n            transformCssStyles(snaps[0]);\n          });\n        }\n      }));\n      /**\n      * Переключаемся с первого слайда на последний\n      * Для корректной анимации сначала задаем первым видимым слайдам смещение\n      * В следующем кадре начинаем анимация прокрутки \"назад\"\n      */\n    } else if (indent === snaps[snaps.length - 1] && shiftXCurrentRef.current === snaps[0]) {\n      startPoint = indent - revertRtlValue(slides[slides.length - 1].width, isRtl);\n      addToAnimationQueue(() => {\n        requestAnimationFrame(() => {\n          const shiftX = indent - revertRtlValue(slides[slides.length - 1].width, isRtl);\n          transformCssStyles(shiftX);\n          getAnimateFunction(progress => {\n            const diff = revertRtlValue(progress * slides[slides.length - 1].width, isRtl);\n            transformCssStyles(startPoint + diff);\n          })();\n        });\n      });\n      /**\n      * Если не обработаны `corner`-кейсы выше, то просто проигрываем анимацию смещения\n      */\n    } else {\n      addToAnimationQueue(() => {\n        const distance = Math.abs(indent - startPoint);\n        let direction = startPoint <= indent ? 1 : -1;\n        getAnimateFunction(progress => {\n          const shiftX = startPoint + progress * distance * direction;\n          transformCssStyles(shiftX);\n        })();\n      });\n    }\n  };\n  const simpleSlideChangePerform = () => {\n    const {\n      snaps\n    } = slidesManager.current;\n    requestTransform(snaps[slideIndex], true);\n  };\n  useIsomorphicLayoutEffect(function performSlideChange() {\n    if (!initialized.current) {\n      return;\n    }\n    const {\n      snaps\n    } = slidesManager.current;\n    const indent = snaps[slideIndex];\n    if (looped) {\n      loopedSlideChangePerform();\n    } else {\n      simpleSlideChangePerform();\n    }\n    startAnimation();\n    shiftXCurrentRef.current = indent;\n    setControlElementsState(v => _object_spread_props(_object_spread({}, v), {\n      canSlideLeft: calculateCanSlideLeft(),\n      canSlideRight: calculateCanSlideRight()\n    }));\n  }, [slideIndex]);\n  useIsomorphicLayoutEffect(function updateIsDraggable() {\n    setControlElementsState(v => _object_spread_props(_object_spread({}, v), {\n      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible)\n    }));\n  }, [dragDisabled]);\n  useMutationObserver(layerRef, initializeSlides);\n  useIsomorphicLayoutEffect(initializeSlides, [align, slideWidth, looped, isRtl]);\n  const calculateMinDeltaXToSlide = () => {\n    return slidesManager.current.slides[slideIndex].width * SLIDE_THRESHOLD;\n  };\n  const slideLeft = event => {\n    if (slideIndex > 0) {\n      shiftXCurrentRef.current += revertRtlValue(calculateMinDeltaXToSlide(), isRtl);\n    }\n    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex - 1 + slidesManager.current.slides.length) % slidesManager.current.slides.length);\n    onPrevClick === null || onPrevClick === void 0 ? void 0 : onPrevClick(event);\n  };\n  const slideRight = event => {\n    if (slideIndex < slidesManager.current.slides.length - 1) {\n      shiftXCurrentRef.current -= revertRtlValue(calculateMinDeltaXToSlide(), isRtl);\n    }\n    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex + 1) % slidesManager.current.slides.length);\n    onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(event);\n  };\n  const onStart = e => {\n    e.originalEvent.stopPropagation();\n    if (controlElementsState.isDraggable) {\n      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e);\n      shiftXCurrentRef.current = slidesManager.current.snaps[slideIndex];\n      shiftXDeltaRef.current = 0;\n    }\n  };\n  const onMoveX = e => {\n    if (controlElementsState.isDraggable) {\n      e.originalEvent.preventDefault();\n      if (e.isSlideX) {\n        isDragging.current = true;\n        if (shiftXDeltaRef.current !== e.shiftX) {\n          shiftXDeltaRef.current = e.shiftX;\n          requestTransform(shiftXCurrentRef.current + shiftXDeltaRef.current);\n        }\n      }\n    }\n  };\n  const onEnd = e => {\n    if (controlElementsState.isDraggable) {\n      isDragging.current = false;\n      let targetIndex = slideIndex;\n      if (e.isSlide) {\n        targetIndex = getTargetIndex({\n          slides: slidesManager.current.slides,\n          slideIndex,\n          currentShiftX: shiftXCurrentRef.current,\n          currentShiftXDelta: shiftXDeltaRef.current,\n          max: slidesManager.current.max,\n          looped,\n          isRtl\n        });\n      }\n      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e, targetIndex);\n      if (targetIndex !== slideIndex) {\n        shiftXCurrentRef.current = shiftXCurrentRef.current + shiftXDeltaRef.current;\n        onChange === null || onChange === void 0 ? void 0 : onChange(targetIndex);\n      } else {\n        const initialShiftX = slidesManager.current.snaps[targetIndex];\n        requestTransform(initialShiftX, true);\n      }\n    }\n  };\n  const setSlideRef = (slideRef, slideIndex) => {\n    slidesStore.current[slideIndex] = slideRef;\n  };\n  const {\n    isDraggable,\n    canSlideRight,\n    canSlideLeft\n  } = controlElementsState;\n  return /*#__PURE__*/_jsxs(RootComponent, _object_spread_props(_object_spread({}, restProps), {\n    baseClassName: classNames(\"vkuiCarouselBase__host\", slideWidth === 'custom' && \"vkuiCarouselBase__customWidth\", isDraggable && \"vkuiCarouselBase__draggable\"),\n    getRootRef: rootRef,\n    children: [/*#__PURE__*/_jsx(CarouselViewPort, {\n      slideWidth: slideWidth,\n      slideTestId: slideTestId,\n      onStart: onStart,\n      onMoveX: onMoveX,\n      onEnd: onEnd,\n      getRootRef: viewportRef,\n      layerRef: layerRef,\n      setSlideRef: setSlideRef,\n      children: children\n    }), bullets && /*#__PURE__*/_jsx(Bullets, {\n      bullets: bullets,\n      slideIndex: slideIndex,\n      count: React.Children.count(children),\n      bulletTestId: bulletTestId\n    }), /*#__PURE__*/_jsx(ScrollArrows, {\n      hasPointer: hasPointer,\n      canSlideLeft: canSlideLeft,\n      canSlideRight: canSlideRight,\n      onSlideRight: slideRight,\n      onSlideLeft: slideLeft,\n      showArrows: showArrows,\n      arrowSize: arrowSize,\n      arrowAreaHeight: arrowAreaHeight,\n      prevArrowTestId: prevArrowTestId,\n      nextArrowTestId: nextArrowTestId\n    })]\n  }));\n};","map":{"version":3,"names":["React","classNames","useAdaptivityHasPointer","useConfigDirection","useExternRef","useMutationObserver","useResizeObserver","useDOM","useIsomorphicLayoutEffect","warnOnce","RootComponent","Bullets","CarouselViewPort","ScrollArrows","ANIMATION_DURATION","CONTROL_ELEMENTS_STATE","SLIDE_THRESHOLD","SLIDES_MANAGER_STATE","calcMax","calcMin","calculateIndent","getLoopPoints","getTargetIndex","isBigger","isBiggerOrEqual","isLowerOrEqual","revertRtlValue","validateIndent","useSlideAnimation","warn","CarouselBase","_param","bullets","getRootRef","children","slideWidth","slideIndex","dragDisabled","resizeSource","onDragStart","onDragEnd","onChange","onPrevClick","onNextClick","align","showArrows","getRef","arrowSize","arrowAreaHeight","slideTestId","bulletTestId","nextArrowTestId","prevArrowTestId","looped","restProps","_object_without_properties","slidesStore","useRef","slidesManager","textDirection","isRtl","rootRef","viewportRef","layerRef","animationFrameRef","shiftXCurrentRef","shiftXDeltaRef","initialized","addToAnimationQueue","getAnimateFunction","startAnimation","isDragging","controlElementsState","setControlElementsState","useState","hasPointer","isCenterAlign","calculateCanSlideLeft","current","isFullyVisible","isStartShiftX","calculateCanSlideRight","_slidesManager_current_layerWidth","containerWidth","layerWidth","slides","length","transformCssStyles","shiftX","animation","arguments","undefined","Math","round","loopPoints","forEach","loopPoint","target","index","slide","style","transform","Object","values","indent","transition","checkShiftOutOfBoundsFromStart","snaps","checkShiftOutOfBoundsFromEnd","firstSlideShift","width","lastPoint","coordX","requestTransform","contentSize","cancelAnimationFrame","requestAnimationFrame","firstSnap","abs","initializeSlides","_localSlides_slideIndex","layerOffsetWidth","offsetWidth","calcRtlCoord","element","offsetLeft","localSlides","Children","map","_item","i","elem","viewportOffsetWidth","reduce","val","process","env","NODE_ENV","remainingWidth","_localSlides_slideIndex_width","currentSlideOffsetOnCenterAlignment","onlyOneSlide","_object_spread_props","_object_spread","max","min","_","targetIndex","isCenter","canSlideLeft","canSlideRight","isDraggable","onResize","window","loopedSlideChangePerform","startPoint","fromLastToFirst","endEdge","distance","progress","diff","direction","simpleSlideChangePerform","performSlideChange","v","updateIsDraggable","calculateMinDeltaXToSlide","slideLeft","event","slideRight","onStart","e","originalEvent","stopPropagation","onMoveX","preventDefault","isSlideX","onEnd","isSlide","currentShiftX","currentShiftXDelta","initialShiftX","setSlideRef","slideRef","_jsxs","baseClassName","_jsx","count","onSlideRight","onSlideLeft"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/CarouselBase/CarouselBase.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { useConfigDirection } from '../../hooks/useConfigDirection';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { useMutationObserver } from '../../hooks/useMutationObserver';\nimport { useResizeObserver } from '../../hooks/useResizeObserver';\nimport { useDOM } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { warnOnce } from '../../lib/warnOnce';\nimport { RootComponent } from '../RootComponent/RootComponent';\nimport { type CustomTouchEvent } from '../Touch/Touch';\nimport { Bullets } from './Bullets';\nimport { CarouselViewPort } from './CarouselViewPort';\nimport { ScrollArrows } from './ScrollArrows';\nimport {\n  ANIMATION_DURATION,\n  CONTROL_ELEMENTS_STATE,\n  SLIDE_THRESHOLD,\n  SLIDES_MANAGER_STATE,\n} from './constants';\nimport {\n  calcMax,\n  calcMin,\n  calculateIndent,\n  getLoopPoints,\n  getTargetIndex,\n  isBigger,\n  isBiggerOrEqual,\n  isLowerOrEqual,\n  revertRtlValue,\n  validateIndent,\n} from './helpers';\nimport { useSlideAnimation } from './hooks';\nimport {\n  type BaseGalleryProps,\n  type ControlElementsState,\n  type GallerySlidesState,\n  type SlidesManagerState,\n} from './types';\nimport styles from './CarouselBase.module.css';\n\nconst warn = warnOnce('Gallery');\n\nexport const CarouselBase = ({\n  bullets = false,\n  getRootRef,\n  children,\n  slideWidth = '100%',\n  slideIndex = 0,\n  dragDisabled = false,\n  resizeSource = 'window',\n  onDragStart,\n  onDragEnd,\n  onChange,\n  onPrevClick,\n  onNextClick,\n  align = 'left',\n  showArrows,\n  getRef,\n  arrowSize,\n  arrowAreaHeight,\n  slideTestId,\n  bulletTestId,\n  nextArrowTestId,\n  prevArrowTestId,\n  looped = false,\n  ...restProps\n}: BaseGalleryProps): React.ReactNode => {\n  const slidesStore = React.useRef<Record<string, HTMLDivElement | null>>({});\n  const slidesManager = React.useRef<SlidesManagerState>(SLIDES_MANAGER_STATE);\n  const textDirection = useConfigDirection();\n  const isRtl = textDirection === 'rtl';\n\n  const rootRef = useExternRef(getRootRef);\n  const viewportRef = useExternRef(getRef);\n  const layerRef = React.useRef<HTMLDivElement>(null);\n  const animationFrameRef = React.useRef<ReturnType<typeof requestAnimationFrame> | null>(null);\n  const shiftXCurrentRef = React.useRef<number>(0);\n  const shiftXDeltaRef = React.useRef<number>(0);\n  const initialized = React.useRef<boolean>(false);\n  const { addToAnimationQueue, getAnimateFunction, startAnimation } = useSlideAnimation();\n  const isDragging = React.useRef(false);\n\n  const [controlElementsState, setControlElementsState] =\n    React.useState<ControlElementsState>(CONTROL_ELEMENTS_STATE);\n\n  const hasPointer = useAdaptivityHasPointer();\n\n  const isCenterAlign = align === 'center';\n\n  const calculateCanSlideLeft = () => {\n    if (looped) {\n      return !slidesManager.current.isFullyVisible;\n    }\n    const isStartShiftX = isBiggerOrEqual(shiftXCurrentRef.current, 0, isRtl);\n    return !slidesManager.current.isFullyVisible && !isStartShiftX;\n  };\n\n  const calculateCanSlideRight = () => {\n    if (looped) {\n      return !slidesManager.current.isFullyVisible;\n    }\n    return (\n      !slidesManager.current.isFullyVisible &&\n      // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      ((align === 'left' &&\n        slidesManager.current.containerWidth - revertRtlValue(shiftXCurrentRef.current, isRtl) <\n          (slidesManager.current.layerWidth ?? 0)) ||\n        // otherwise we need to check current slide index (align = right or align = center)\n        (align !== 'left' && slideIndex < slidesManager.current.slides.length - 1))\n    );\n  };\n\n  const transformCssStyles = (shiftX: number, animation = false) => {\n    shiftX = Math.round(shiftX);\n    if (looped) {\n      slidesManager.current.loopPoints.forEach((loopPoint) => {\n        const { target, index } = loopPoint;\n        const slide = slidesStore.current[index];\n        if (slide) {\n          slide.style.transform = `translate3d(${target(shiftX)}px, 0, 0)`;\n        }\n      });\n    } else {\n      Object.values(slidesStore.current).forEach((slide) => {\n        if (slide) {\n          slide.style.transform = '';\n        }\n      });\n    }\n\n    if (layerRef.current) {\n      const indent =\n        isDragging.current && !looped\n          ? validateIndent(\n              slidesManager.current,\n              shiftXCurrentRef.current + shiftXDeltaRef.current,\n              isRtl,\n              false,\n            )\n          : shiftX;\n\n      layerRef.current.style.transform = `translate3d(${indent}px, 0, 0)`;\n      layerRef.current.style.transition = animation\n        ? `transform ${ANIMATION_DURATION}ms cubic-bezier(.1, 0, .25, 1)`\n        : '';\n    }\n  };\n\n  const checkShiftOutOfBoundsFromStart = (shiftX: number, snaps: number[]) =>\n    isBigger(shiftX, snaps[0], isRtl);\n\n  const checkShiftOutOfBoundsFromEnd = (shiftX: number, slides: GallerySlidesState[]) => {\n    /**\n     * Поскольку при `align=\"center\"` слайды сдвинуты, прежде чем рассчитать крайнюю правую точку,\n     * нужно вычесть сдвиг слайдов\n     */\n    const firstSlideShift =\n      align === 'center'\n        ? (slidesManager.current.containerWidth - slidesManager.current.slides[0].width) / 2\n        : 0;\n\n    const lastPoint =\n      slides[slides.length - 1].width + slides[slides.length - 1].coordX - firstSlideShift;\n    return isRtl ? shiftX >= lastPoint : shiftX <= -lastPoint;\n  };\n\n  const requestTransform = (shiftX: number, animation = false) => {\n    const { snaps, contentSize, slides } = slidesManager.current;\n\n    if (animationFrameRef.current !== null) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      /**\n       * Для бесконечной галереи проверяем, что при dnd мы прокрутили левее, чем первый слайд,\n       * чтобы сбросить `shiftXCurrentRef`\n       */\n      if (looped && checkShiftOutOfBoundsFromStart(shiftX, snaps)) {\n        const firstSnap = revertRtlValue(snaps[0], isRtl);\n        shiftXCurrentRef.current = revertRtlValue(-contentSize + firstSnap, isRtl);\n        shiftX = shiftXCurrentRef.current + shiftXDeltaRef.current;\n      }\n\n      /**\n       * Для бесконечной галереи проверяем, что при dnd мы прокрутили правее, чем последний слайд,\n       * чтобы правильно пересчитать `shiftXCurrentRef`\n       */\n      if (looped && checkShiftOutOfBoundsFromEnd(shiftX, slides)) {\n        shiftXCurrentRef.current = Math.abs(shiftXDeltaRef.current) + snaps[0];\n      }\n      transformCssStyles(shiftX, animation);\n    });\n  };\n\n  const initializeSlides = () => {\n    if (!rootRef.current || !viewportRef.current || !layerRef.current) {\n      return;\n    }\n    const layerOffsetWidth = layerRef.current.offsetWidth;\n\n    const calcRtlCoord = (element: HTMLDivElement) => {\n      const offsetLeft = element.offsetLeft;\n      const offsetWidth = element.offsetWidth;\n      return layerOffsetWidth - offsetLeft - offsetWidth;\n    };\n\n    let localSlides =\n      React.Children.map(children, (_item, i): GallerySlidesState => {\n        const elem = slidesStore.current[i];\n        if (!elem) {\n          return { coordX: 0, width: 0 };\n        }\n        const coordX = isRtl ? calcRtlCoord(elem) : elem.offsetLeft;\n        return { coordX, width: elem.offsetWidth };\n      }) || [];\n\n    if (localSlides.length === 0) {\n      initialized.current = false;\n      return;\n    }\n\n    const containerWidth = rootRef.current.offsetWidth;\n    const viewportOffsetWidth = viewportRef.current.offsetWidth;\n    const layerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);\n\n    if (process.env.NODE_ENV === 'development' && looped) {\n      let remainingWidth = containerWidth;\n      let slideIndex = 0;\n\n      while (remainingWidth > 0 && slideIndex < localSlides.length) {\n        remainingWidth -= localSlides[slideIndex].width;\n        slideIndex++;\n      }\n      if (remainingWidth <= 0 && slideIndex === localSlides.length) {\n        warn(\n          'Ширины слайдов недостаточно для корректной работы свойства \"looped\". Пожалуйста, сделайте её больше.',\n        );\n      }\n    }\n\n    const currentSlideOffsetOnCenterAlignment =\n      (containerWidth - (localSlides[slideIndex]?.width ?? 0)) / 2;\n    const isFullyVisible =\n      align === 'center'\n        ? layerWidth + currentSlideOffsetOnCenterAlignment <= containerWidth\n        : layerWidth <= containerWidth;\n\n    const onlyOneSlide = localSlides.length === 1;\n\n    slidesManager.current = {\n      ...slidesManager.current,\n      layerWidth,\n      containerWidth,\n      viewportOffsetWidth,\n      slides: localSlides,\n      isFullyVisible,\n      max:\n        looped || onlyOneSlide\n          ? null\n          : calcMax({\n              slides: localSlides,\n              containerWidth,\n              isCenterAlign,\n              isRtl,\n            }),\n      min:\n        looped || onlyOneSlide\n          ? null\n          : calcMin({\n              containerWidth,\n              layerWidth,\n              slides: localSlides,\n              viewportOffsetWidth,\n              isFullyVisible,\n              align,\n              isRtl,\n            }),\n    };\n    const snaps = localSlides.map((_, index) =>\n      calculateIndent({\n        targetIndex: index,\n        slidesManager: slidesManager.current,\n        isCenter: isCenterAlign,\n        looped,\n        isRtl,\n      }),\n    );\n\n    let contentSize = Math.abs(snaps[snaps.length - 1]) + localSlides[localSlides.length - 1].width;\n    if (align === 'center') {\n      contentSize += revertRtlValue(snaps[0], isRtl);\n    }\n\n    slidesManager.current.snaps = snaps;\n    slidesManager.current.contentSize = contentSize;\n    // Если галерея не зациклена и слайд всего один, то рассчитывать loopPoints тоже не надо\n    if (looped && !onlyOneSlide && !isFullyVisible) {\n      slidesManager.current.loopPoints = getLoopPoints(\n        slidesManager.current,\n        containerWidth,\n        isRtl,\n      );\n    }\n\n    shiftXCurrentRef.current = snaps[slideIndex];\n    initialized.current = true;\n\n    setControlElementsState({\n      canSlideLeft: calculateCanSlideLeft(),\n      canSlideRight: calculateCanSlideRight(),\n      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible),\n    });\n    requestTransform(shiftXCurrentRef.current);\n  };\n\n  const onResize = () => {\n    if (initialized.current) {\n      initializeSlides();\n    }\n  };\n  const { window } = useDOM();\n  useResizeObserver(resizeSource === 'element' ? rootRef : window, onResize);\n\n  const loopedSlideChangePerform = () => {\n    const { snaps, slides } = slidesManager.current;\n    const indent = snaps[slideIndex];\n    let startPoint = shiftXCurrentRef.current;\n\n    const fromLastToFirst = isLowerOrEqual(\n      shiftXCurrentRef.current,\n      snaps[snaps.length - 1],\n      isRtl,\n    );\n    /**\n     * Переключаемся с последнего элемента на первый\n     * Для корректной анимации мы прокручиваем последний слайд на всю длину (shiftX) \"вперед\"\n     * В конце анимации при отрисовке следующего кадра задаем всем слайдам начальные значения\n     */\n    if (indent === snaps[0] && fromLastToFirst) {\n      const endEdge = revertRtlValue(\n        Math.abs(snaps[snaps.length - 1]) + slides[slides.length - 1].width,\n        isRtl,\n      );\n      const distance = endEdge + startPoint;\n      addToAnimationQueue(\n        getAnimateFunction((progress) => {\n          const shiftX = startPoint + progress * distance * -1;\n\n          transformCssStyles(shiftX);\n\n          if (shiftX <= snaps[snaps.length - 1] - slides[slides.length - 1].width) {\n            requestAnimationFrame(() => {\n              shiftXCurrentRef.current = indent;\n              transformCssStyles(snaps[0]);\n            });\n          }\n        }),\n      );\n      /**\n       * Переключаемся с первого слайда на последний\n       * Для корректной анимации сначала задаем первым видимым слайдам смещение\n       * В следующем кадре начинаем анимация прокрутки \"назад\"\n       */\n    } else if (indent === snaps[snaps.length - 1] && shiftXCurrentRef.current === snaps[0]) {\n      startPoint = indent - revertRtlValue(slides[slides.length - 1].width, isRtl);\n\n      addToAnimationQueue(() => {\n        requestAnimationFrame(() => {\n          const shiftX = indent - revertRtlValue(slides[slides.length - 1].width, isRtl);\n          transformCssStyles(shiftX);\n\n          getAnimateFunction((progress) => {\n            const diff = revertRtlValue(progress * slides[slides.length - 1].width, isRtl);\n            transformCssStyles(startPoint + diff);\n          })();\n        });\n      });\n      /**\n       * Если не обработаны `corner`-кейсы выше, то просто проигрываем анимацию смещения\n       */\n    } else {\n      addToAnimationQueue(() => {\n        const distance = Math.abs(indent - startPoint);\n        let direction = startPoint <= indent ? 1 : -1;\n\n        getAnimateFunction((progress) => {\n          const shiftX = startPoint + progress * distance * direction;\n          transformCssStyles(shiftX);\n        })();\n      });\n    }\n  };\n\n  const simpleSlideChangePerform = () => {\n    const { snaps } = slidesManager.current;\n    requestTransform(snaps[slideIndex], true);\n  };\n\n  useIsomorphicLayoutEffect(\n    function performSlideChange() {\n      if (!initialized.current) {\n        return;\n      }\n      const { snaps } = slidesManager.current;\n      const indent = snaps[slideIndex];\n\n      if (looped) {\n        loopedSlideChangePerform();\n      } else {\n        simpleSlideChangePerform();\n      }\n\n      startAnimation();\n\n      shiftXCurrentRef.current = indent;\n\n      setControlElementsState((v) => ({\n        ...v,\n        canSlideLeft: calculateCanSlideLeft(),\n        canSlideRight: calculateCanSlideRight(),\n      }));\n    },\n    [slideIndex],\n  );\n\n  useIsomorphicLayoutEffect(\n    function updateIsDraggable() {\n      setControlElementsState((v) => ({\n        ...v,\n        isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible),\n      }));\n    },\n    [dragDisabled],\n  );\n\n  useMutationObserver(layerRef, initializeSlides);\n\n  useIsomorphicLayoutEffect(initializeSlides, [align, slideWidth, looped, isRtl]);\n\n  const calculateMinDeltaXToSlide = () => {\n    return slidesManager.current.slides[slideIndex].width * SLIDE_THRESHOLD;\n  };\n\n  const slideLeft = (event: React.MouseEvent) => {\n    if (slideIndex > 0) {\n      shiftXCurrentRef.current += revertRtlValue(calculateMinDeltaXToSlide(), isRtl);\n    }\n    onChange?.(\n      (slideIndex - 1 + slidesManager.current.slides.length) % slidesManager.current.slides.length,\n    );\n    onPrevClick?.(event);\n  };\n\n  const slideRight = (event: React.MouseEvent) => {\n    if (slideIndex < slidesManager.current.slides.length - 1) {\n      shiftXCurrentRef.current -= revertRtlValue(calculateMinDeltaXToSlide(), isRtl);\n    }\n    onChange?.((slideIndex + 1) % slidesManager.current.slides.length);\n    onNextClick?.(event);\n  };\n\n  const onStart = (e: CustomTouchEvent) => {\n    e.originalEvent.stopPropagation();\n    if (controlElementsState.isDraggable) {\n      onDragStart?.(e);\n      shiftXCurrentRef.current = slidesManager.current.snaps[slideIndex];\n      shiftXDeltaRef.current = 0;\n    }\n  };\n\n  const onMoveX = (e: CustomTouchEvent) => {\n    if (controlElementsState.isDraggable) {\n      e.originalEvent.preventDefault();\n\n      if (e.isSlideX) {\n        isDragging.current = true;\n        if (shiftXDeltaRef.current !== e.shiftX) {\n          shiftXDeltaRef.current = e.shiftX;\n          requestTransform(shiftXCurrentRef.current + shiftXDeltaRef.current);\n        }\n      }\n    }\n  };\n\n  const onEnd = (e: CustomTouchEvent) => {\n    if (controlElementsState.isDraggable) {\n      isDragging.current = false;\n      let targetIndex = slideIndex;\n      if (e.isSlide) {\n        targetIndex = getTargetIndex({\n          slides: slidesManager.current.slides,\n          slideIndex,\n          currentShiftX: shiftXCurrentRef.current,\n          currentShiftXDelta: shiftXDeltaRef.current,\n          max: slidesManager.current.max,\n          looped,\n          isRtl,\n        });\n      }\n      onDragEnd?.(e, targetIndex);\n\n      if (targetIndex !== slideIndex) {\n        shiftXCurrentRef.current = shiftXCurrentRef.current + shiftXDeltaRef.current;\n        onChange?.(targetIndex);\n      } else {\n        const initialShiftX = slidesManager.current.snaps[targetIndex];\n        requestTransform(initialShiftX, true);\n      }\n    }\n  };\n\n  const setSlideRef = (slideRef: HTMLDivElement | null, slideIndex: number) => {\n    slidesStore.current[slideIndex] = slideRef;\n  };\n\n  const { isDraggable, canSlideRight, canSlideLeft } = controlElementsState;\n\n  return (\n    <RootComponent\n      {...restProps}\n      baseClassName={classNames(\n        styles.host,\n        slideWidth === 'custom' && styles.customWidth,\n        isDraggable && styles.draggable,\n      )}\n      getRootRef={rootRef}\n    >\n      <CarouselViewPort\n        slideWidth={slideWidth}\n        slideTestId={slideTestId}\n        onStart={onStart}\n        onMoveX={onMoveX}\n        onEnd={onEnd}\n        getRootRef={viewportRef}\n        layerRef={layerRef}\n        setSlideRef={setSlideRef}\n      >\n        {children}\n      </CarouselViewPort>\n\n      {bullets && (\n        <Bullets\n          bullets={bullets}\n          slideIndex={slideIndex}\n          count={React.Children.count(children)}\n          bulletTestId={bulletTestId}\n        />\n      )}\n      <ScrollArrows\n        hasPointer={hasPointer}\n        canSlideLeft={canSlideLeft}\n        canSlideRight={canSlideRight}\n        onSlideRight={slideRight}\n        onSlideLeft={slideLeft}\n        showArrows={showArrows}\n        arrowSize={arrowSize}\n        arrowAreaHeight={arrowAreaHeight}\n        prevArrowTestId={prevArrowTestId}\n        nextArrowTestId={nextArrowTestId}\n      />\n    </RootComponent>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}