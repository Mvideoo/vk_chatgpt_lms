{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport * as React from \"react\";\nimport { classNames, noop } from \"@vkontakte/vkjs\";\nimport { mergeCalls } from \"../../lib/mergeCalls.js\";\nimport { useStateWithDelay } from \"./useStateWithDelay.js\";\nexport const DEFAULT_ACTIVE_EFFECT_DELAY = 600;\nconst ACTIVE_DELAY = 70;\n/**\n * Управляет наведением на компонент, игнорирует тач события\n */\nfunction useHover(_ref) {\n  let {\n    hovered,\n    hasHover = true,\n    lockState,\n    setParentStateLock\n  } = _ref;\n  const [hoveredStateLocal, setHoveredStateLocal] = React.useState(false);\n  const prevIsHoveredRef = React.useRef(undefined);\n  const handleHover = React.useCallback(isHover => {\n    setHoveredStateLocal(isHover);\n    const isHovered = hovered !== null && hovered !== void 0 ? hovered : calculateStateValue({\n      hasState: hasHover,\n      isLocked: lockState,\n      stateValueLocal: isHover\n    });\n    // проверка сделана чтобы реже вызывать обновление состояния\n    // контекста родителя\n    if (isHovered !== prevIsHoveredRef.current) {\n      prevIsHoveredRef.current = isHovered;\n      setParentStateLock(isHovered);\n    }\n  }, [setParentStateLock, hasHover, hovered, lockState]);\n  const onPointerEnter = e => {\n    if (e.pointerType === 'touch') {\n      return;\n    }\n    handleHover(true);\n  };\n  const onPointerLeave = () => {\n    handleHover(false);\n  };\n  const isHovered = hovered !== null && hovered !== void 0 ? hovered : calculateStateValue({\n    hasState: hasHover,\n    isLocked: lockState,\n    stateValueLocal: hoveredStateLocal\n  });\n  return {\n    isHovered,\n    onPointerEnter: hasHover ? onPointerEnter : noop,\n    onPointerLeave: hasHover ? onPointerLeave : noop\n  };\n}\n/**\n * Управляет активацией компонента\n */\nfunction useActive(_ref2) {\n  let {\n    activated,\n    activeEffectDelay,\n    hasActive = true,\n    lockStateRef,\n    setParentStateLock\n  } = _ref2;\n  // передаём setParentStateLock, чтобы функция вызывалась вместе с установкой стейта,\n  // если установка отложена c помощью delay, то и вызов будет отложен\n  const [activatedState, setActivated] = useStateWithDelay(false, 0, setParentStateLock);\n  // Список нажатий которые не требуется отменять\n  const pointersUp = React.useMemo(() => new Set(), []);\n  const onPointerDown = () => {\n    if (lockStateRef.current) {\n      return;\n    }\n    setActivated(true, ACTIVE_DELAY);\n    // намеренно выставляем lock, так как setActivated вызов отложен\n    // а у отложенного setActivated setParentStateLock тоже вызовится отложенно\n    // родитель сейчас тоже обработает это же событие PointerDown\n    // если мы не залочим activatedState у родителя сейчас, то родитель выставит active состояние\n    setParentStateLock(true);\n  };\n  const onPointerCancel = e => {\n    if (pointersUp.has(e.pointerId)) {\n      pointersUp.delete(e.pointerId);\n      return;\n    }\n    setActivated(false);\n  };\n  const onPointerUp = e => {\n    pointersUp.add(e.pointerId);\n    if (lockStateRef.current) {\n      return;\n    }\n    setActivated(true);\n    setActivated(false, activeEffectDelay);\n  };\n  const isActivated = activated !== null && activated !== void 0 ? activated : calculateStateValue({\n    hasState: hasActive,\n    isLocked: lockStateRef.current,\n    stateValueLocal: activatedState\n  });\n  return {\n    isActivated,\n    onPointerLeave: hasActive ? onPointerCancel : noop,\n    onPointerDown: hasActive ? onPointerDown : noop,\n    onPointerCancel: hasActive ? onPointerCancel : noop,\n    onPointerUp: hasActive ? onPointerUp : noop\n  };\n}\nexport const ClickableLockStateContext = /*#__PURE__*/React.createContext({\n  lockHoverStateBubbling: undefined,\n  lockActiveStateBubbling: undefined\n});\n/**\n * Блокирует стейт на всплытие\n */\nfunction useLockState(setParentStateLockBubbling) {\n  const [lockState, setLockState] = React.useState(false);\n  const setStateLockBubblingImmediate = React.useCallback(isLock => {\n    setLockState(isLock);\n    setParentStateLockBubbling(isLock);\n  }, [setParentStateLockBubbling]);\n  return [lockState, setParentStateLockBubbling, setStateLockBubblingImmediate];\n}\nfunction useLockRef(setParentStateLockBubbling) {\n  const lockStateRef = React.useRef(false);\n  const setStateLockBubblingImmediate = React.useCallback(isLock => {\n    lockStateRef.current = isLock;\n    setParentStateLockBubbling(isLock);\n  }, [setParentStateLockBubbling]);\n  return [lockStateRef, setParentStateLockBubbling, setStateLockBubblingImmediate];\n}\n/**\n * Управляет состоянием компонента\n */\nexport function useState(_ref3) {\n  let {\n    hovered,\n    hasHover,\n    activated,\n    hasActive,\n    activeEffectDelay,\n    unlockParentHover,\n    hoverClassName,\n    activeClassName\n  } = _ref3;\n  const {\n    lockHoverStateBubbling = noop,\n    lockActiveStateBubbling = noop\n  } = React.useContext(ClickableLockStateContext);\n  const [lockHoverState, setParentStateLockHoverBubbling, setLockHoverBubblingImmediate] = useLockState(unlockParentHover ? noop : lockHoverStateBubbling);\n  const [lockActiveStateRef, setParentStateLockActiveBubbling, setLockActiveBubblingImmediate] = useLockRef(lockActiveStateBubbling);\n  const _useHover = useHover({\n      hasHover,\n      hovered,\n      lockState: lockHoverState,\n      setParentStateLock: setParentStateLockHoverBubbling\n    }),\n    {\n      isHovered\n    } = _useHover,\n    hoverEvent = _object_without_properties(_useHover, [\"isHovered\"]);\n  const _useActive = useActive({\n      activated,\n      hasActive,\n      activeEffectDelay,\n      lockStateRef: lockActiveStateRef,\n      setParentStateLock: setParentStateLockActiveBubbling\n    }),\n    {\n      isActivated\n    } = _useActive,\n    activeEvent = _object_without_properties(_useActive, [\"isActivated\"]);\n  const stateClassName = classNames(isHovered && hoverClassName, isActivated && activeClassName);\n  const handlers = mergeCalls(hoverEvent, activeEvent);\n  return _object_spread({\n    stateClassName,\n    setLockHoverBubblingImmediate,\n    setLockActiveBubblingImmediate\n  }, handlers);\n}\n// Общая функция для определения конечного состояния active/hovered\nfunction calculateStateValue(_ref4) {\n  let {\n    hasState,\n    isLocked,\n    stateValueLocal\n  } = _ref4;\n  return hasState && !isLocked && stateValueLocal;\n}","map":{"version":3,"names":["React","classNames","noop","mergeCalls","useStateWithDelay","DEFAULT_ACTIVE_EFFECT_DELAY","ACTIVE_DELAY","useHover","_ref","hovered","hasHover","lockState","setParentStateLock","hoveredStateLocal","setHoveredStateLocal","useState","prevIsHoveredRef","useRef","undefined","handleHover","useCallback","isHover","isHovered","calculateStateValue","hasState","isLocked","stateValueLocal","current","onPointerEnter","e","pointerType","onPointerLeave","useActive","_ref2","activated","activeEffectDelay","hasActive","lockStateRef","activatedState","setActivated","pointersUp","useMemo","Set","onPointerDown","onPointerCancel","has","pointerId","delete","onPointerUp","add","isActivated","ClickableLockStateContext","createContext","lockHoverStateBubbling","lockActiveStateBubbling","useLockState","setParentStateLockBubbling","setLockState","setStateLockBubblingImmediate","isLock","useLockRef","_ref3","unlockParentHover","hoverClassName","activeClassName","useContext","lockHoverState","setParentStateLockHoverBubbling","setLockHoverBubblingImmediate","lockActiveStateRef","setParentStateLockActiveBubbling","setLockActiveBubblingImmediate","_useHover","hoverEvent","_object_without_properties","_useActive","activeEvent","stateClassName","handlers","_object_spread","_ref4"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/components/Clickable/useState.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { mergeCalls } from '../../lib/mergeCalls';\nimport { useStateWithDelay } from './useStateWithDelay';\n\nexport interface StateProps {\n  /**\n   * Указывает, должен ли компонент реагировать на hover-состояние\n   */\n  hasHover?: boolean;\n  /**\n   * Позволяет управлять hovered-состоянием извне\n   */\n  hovered?: boolean;\n  /**\n   * Позволяет управлять activated-состоянием извне\n   */\n  activated?: boolean;\n  /**\n   * Указывает, должен ли компонент реагировать на active-состояние\n   */\n  hasActive?: boolean;\n\n  /**\n   * Позволяет родительскому компоненту\n   * иметь hovered-cостояние при наведении\n   * на любой дочерний элемент.\n   * По умолчанию состояние hovered у родителя сбрасывается.\n   *\n   * Присваивается родителькому компоненту.\n   *\n   * @example\n   * <Tappable hasHoverWithChildren>\n   *   <IconButton />\n   *   <IconButton />\n   *   <IconButton />\n   * </Tappable>\n   */\n  hasHoverWithChildren?: boolean;\n\n  /**\n   * Позволяет родительскому компоненту показывать hovered-состояние при наведении\n   * на текущий дочерний компонент.\n   *\n   * Присваивается дочернему компоненту.\n   *\n   * @example\n   * <Tappable>\n   *   <IconButton unlockParentHover />\n   *   <IconButton unlockParentHover />\n   *   <IconButton />\n   * </Tappable>\n   */\n  unlockParentHover?: boolean;\n\n  /**\n   * Длительность показа `activated`-состояния\n   */\n  activeEffectDelay?: number;\n\n  /**\n   * Стиль подсветки active-состояния\n   */\n  activeClassName?: string;\n\n  /**\n   * Стиль подсветки hover-состояния\n   */\n  hoverClassName?: string;\n}\n\nexport const DEFAULT_ACTIVE_EFFECT_DELAY = 600;\n\nconst ACTIVE_DELAY = 70;\n\ninterface UseHoverProps extends Pick<StateProps, 'hovered' | 'hasHover'> {\n  /**\n   * Блокирование активации состояний\n   */\n  lockState: boolean;\n  setParentStateLock: (v: boolean) => void;\n}\n\n/**\n * Управляет наведением на компонент, игнорирует тач события\n */\nfunction useHover({ hovered, hasHover = true, lockState, setParentStateLock }: UseHoverProps) {\n  const [hoveredStateLocal, setHoveredStateLocal] = React.useState(false);\n\n  const prevIsHoveredRef = React.useRef<boolean | undefined>(undefined);\n\n  const handleHover = React.useCallback(\n    (isHover: boolean) => {\n      setHoveredStateLocal(isHover);\n\n      const isHovered =\n        hovered ??\n        calculateStateValue({\n          hasState: hasHover,\n          isLocked: lockState,\n          stateValueLocal: isHover,\n        });\n\n      // проверка сделана чтобы реже вызывать обновление состояния\n      // контекста родителя\n      if (isHovered !== prevIsHoveredRef.current) {\n        prevIsHoveredRef.current = isHovered;\n        setParentStateLock(isHovered);\n      }\n    },\n    [setParentStateLock, hasHover, hovered, lockState],\n  );\n\n  const onPointerEnter: React.PointerEventHandler<any> = (e) => {\n    if (e.pointerType === 'touch') {\n      return;\n    }\n\n    handleHover(true);\n  };\n\n  const onPointerLeave = () => {\n    handleHover(false);\n  };\n\n  const isHovered =\n    hovered ??\n    calculateStateValue({\n      hasState: hasHover,\n      isLocked: lockState,\n      stateValueLocal: hoveredStateLocal,\n    });\n\n  return {\n    isHovered,\n    onPointerEnter: hasHover ? onPointerEnter : noop,\n    onPointerLeave: hasHover ? onPointerLeave : noop,\n  };\n}\n\ninterface UseActiveProps extends Pick<StateProps, 'activated' | 'activeEffectDelay' | 'hasActive'> {\n  /**\n   * Блокирование активации состояний\n   */\n  lockStateRef: React.RefObject<boolean>;\n  setParentStateLock: (v: boolean) => void;\n}\n\n/**\n * Управляет активацией компонента\n */\nfunction useActive({\n  activated,\n  activeEffectDelay,\n  hasActive = true,\n  lockStateRef,\n  setParentStateLock,\n}: UseActiveProps) {\n  // передаём setParentStateLock, чтобы функция вызывалась вместе с установкой стейта,\n  // если установка отложена c помощью delay, то и вызов будет отложен\n  const [activatedState, setActivated] = useStateWithDelay<boolean>(false, 0, setParentStateLock);\n\n  // Список нажатий которые не требуется отменять\n  const pointersUp = React.useMemo(() => new Set<number>(), []);\n\n  const onPointerDown = () => {\n    if (lockStateRef.current) {\n      return;\n    }\n\n    setActivated(true, ACTIVE_DELAY);\n    // намеренно выставляем lock, так как setActivated вызов отложен\n    // а у отложенного setActivated setParentStateLock тоже вызовится отложенно\n    // родитель сейчас тоже обработает это же событие PointerDown\n    // если мы не залочим activatedState у родителя сейчас, то родитель выставит active состояние\n    setParentStateLock(true);\n  };\n\n  const onPointerCancel: React.PointerEventHandler = (e) => {\n    if (pointersUp.has(e.pointerId)) {\n      pointersUp.delete(e.pointerId);\n      return;\n    }\n\n    setActivated(false);\n  };\n\n  const onPointerUp: React.PointerEventHandler = (e) => {\n    pointersUp.add(e.pointerId);\n\n    if (lockStateRef.current) {\n      return;\n    }\n\n    setActivated(true);\n    setActivated(false, activeEffectDelay);\n  };\n\n  const isActivated =\n    activated ??\n    calculateStateValue({\n      hasState: hasActive,\n      isLocked: lockStateRef.current,\n      stateValueLocal: activatedState,\n    });\n\n  return {\n    isActivated,\n    onPointerLeave: hasActive ? onPointerCancel : noop,\n    onPointerDown: hasActive ? onPointerDown : noop,\n    onPointerCancel: hasActive ? onPointerCancel : noop,\n    onPointerUp: hasActive ? onPointerUp : noop,\n  };\n}\n\ninterface ClickableLockStateContextInterface {\n  lockHoverStateBubbling?: (v: boolean) => void;\n  lockActiveStateBubbling?: (v: boolean) => void;\n}\n\nexport const ClickableLockStateContext: React.Context<ClickableLockStateContextInterface> =\n  React.createContext<ClickableLockStateContextInterface>({\n    lockHoverStateBubbling: undefined,\n    lockActiveStateBubbling: undefined,\n  });\n\n/**\n * Блокирует стейт на всплытие\n */\nfunction useLockState(\n  setParentStateLockBubbling: (v: boolean) => void,\n): readonly [boolean, (v: boolean) => void, (...args: any[]) => void] {\n  const [lockState, setLockState] = React.useState(false);\n\n  const setStateLockBubblingImmediate = React.useCallback(\n    (isLock: boolean) => {\n      setLockState(isLock);\n      setParentStateLockBubbling(isLock);\n    },\n    [setParentStateLockBubbling],\n  );\n\n  return [lockState, setParentStateLockBubbling, setStateLockBubblingImmediate] as const;\n}\n\nfunction useLockRef(\n  setParentStateLockBubbling: (v: boolean) => void,\n): readonly [React.RefObject<boolean>, (v: boolean) => void, (...args: any[]) => void] {\n  const lockStateRef = React.useRef(false);\n\n  const setStateLockBubblingImmediate = React.useCallback(\n    (isLock: boolean) => {\n      lockStateRef.current = isLock;\n      setParentStateLockBubbling(isLock);\n    },\n    [setParentStateLockBubbling],\n  );\n\n  return [lockStateRef, setParentStateLockBubbling, setStateLockBubblingImmediate] as const;\n}\n\n/**\n * Управляет состоянием компонента\n */\nexport function useState({\n  hovered,\n  hasHover,\n  activated,\n  hasActive,\n  activeEffectDelay,\n  unlockParentHover,\n  hoverClassName,\n  activeClassName,\n}: StateProps): {\n  stateClassName: string;\n  setLockHoverBubblingImmediate: (...args: any[]) => void;\n  setLockActiveBubblingImmediate: (...args: any[]) => void;\n} {\n  const { lockHoverStateBubbling = noop, lockActiveStateBubbling = noop } =\n    React.useContext(ClickableLockStateContext);\n\n  const [lockHoverState, setParentStateLockHoverBubbling, setLockHoverBubblingImmediate] =\n    useLockState(unlockParentHover ? noop : lockHoverStateBubbling);\n  const [lockActiveStateRef, setParentStateLockActiveBubbling, setLockActiveBubblingImmediate] =\n    useLockRef(lockActiveStateBubbling);\n\n  const { isHovered, ...hoverEvent } = useHover({\n    hasHover,\n    hovered,\n    lockState: lockHoverState,\n    setParentStateLock: setParentStateLockHoverBubbling,\n  });\n\n  const { isActivated, ...activeEvent } = useActive({\n    activated,\n    hasActive,\n    activeEffectDelay,\n    lockStateRef: lockActiveStateRef,\n    setParentStateLock: setParentStateLockActiveBubbling,\n  });\n\n  const stateClassName = classNames(isHovered && hoverClassName, isActivated && activeClassName);\n  const handlers = mergeCalls(hoverEvent, activeEvent);\n\n  return {\n    stateClassName,\n    setLockHoverBubblingImmediate,\n    setLockActiveBubblingImmediate,\n    ...handlers,\n  };\n}\n\n// Общая функция для определения конечного состояния active/hovered\nfunction calculateStateValue({\n  hasState,\n  isLocked,\n  stateValueLocal,\n}: {\n  hasState: boolean;\n  isLocked: boolean;\n  stateValueLocal: boolean;\n}): boolean {\n  return hasState && !isLocked && stateValueLocal;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}