{"ast":null,"code":"import { useRef, useState } from \"react\";\nimport { arraysEquals } from \"../helpers/array.js\";\nimport { FOCUSABLE_ELEMENTS_LIST, Keys, pressedKey } from \"../lib/accessibility.js\";\nimport { contains, getActiveElementByAnotherElement, getWindow, isHTMLElement, useDOM } from \"../lib/dom.js\";\nimport { useIsomorphicLayoutEffect } from \"../lib/useIsomorphicLayoutEffect.js\";\nimport { useMutationObserver } from \"./useMutationObserver.js\";\nimport { useStableCallback } from \"./useStableCallback.js\";\nconst useRestoreFocus = _ref => {\n  let {\n    restoreFocus,\n    timeout,\n    mount,\n    ref\n  } = _ref;\n  const restoreFocusRef = useRef(restoreFocus);\n  restoreFocusRef.current = restoreFocus;\n  const [restoreFocusTo, setRestoreFocusTo] = useState(null);\n  const restoreFocusImpl = useStableCallback(() => {\n    const shouldRestoreFocus = typeof restoreFocusRef.current === 'function' ? restoreFocusRef.current() : restoreFocusRef.current;\n    if (!shouldRestoreFocus) {\n      return;\n    }\n    setTimeout(() => {\n      const restoreFocusElement = isHTMLElement(shouldRestoreFocus) && shouldRestoreFocus || isHTMLElement(restoreFocusTo) && restoreFocusTo || null;\n      if (restoreFocusElement) {\n        restoreFocusElement.focus();\n        setRestoreFocusTo(null);\n      }\n    }, timeout);\n  });\n  useIsomorphicLayoutEffect(function calculateRestoreFocusTo() {\n    if (!ref.current || !restoreFocusRef.current || !mount) {\n      setRestoreFocusTo(null);\n      return;\n    }\n    setRestoreFocusTo(getActiveElementByAnotherElement(ref.current));\n  }, [ref, mount]);\n  useIsomorphicLayoutEffect(function tryToRestoreFocusOnUnmount() {\n    return () => {\n      restoreFocusImpl();\n    };\n  }, [restoreFocusImpl]);\n  useIsomorphicLayoutEffect(function tryToRestoreFocusWhenFakeUnmount() {\n    if (!mount) {\n      restoreFocusImpl();\n    }\n  }, [mount, restoreFocusImpl]);\n};\nconst FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS_LIST.join();\n/**\n * @private\n */\nexport const useFocusTrap = (ref, _ref2) => {\n  let {\n    mount = true,\n    disabled = false,\n    autoFocus = true,\n    restoreFocus = true,\n    timeout = 0,\n    onClose\n  } = _ref2;\n  const {\n    document\n  } = useDOM();\n  const focusableNodesRef = useRef([]);\n  const focusNodeByIndex = nodeIndex => {\n    const element = focusableNodesRef.current[nodeIndex];\n    if (element) {\n      element.focus({\n        preventScroll: true\n      });\n    }\n  };\n  useRestoreFocus({\n    restoreFocus,\n    mount,\n    timeout,\n    ref\n  });\n  const recalculateFocusableNodesRef = parentNode => {\n    // eslint-disable-next-line no-restricted-properties\n    const newFocusableElements = parentNode.querySelectorAll(FOCUSABLE_ELEMENTS);\n    const nodes = [];\n    newFocusableElements.forEach(focusableEl => {\n      const {\n        display,\n        visibility\n      } = getComputedStyle(focusableEl);\n      if (display !== 'none' && visibility !== 'hidden') {\n        nodes.push(focusableEl);\n      }\n    });\n    if (nodes.length === 0) {\n      // Чтобы фокус был хотя бы на родителе\n      nodes.push(parentNode);\n    }\n    focusableNodesRef.current = nodes;\n  };\n  const onMutateParentHandler = parentNode => {\n    const oldFocusableNodes = [...focusableNodesRef.current];\n    recalculateFocusableNodesRef(parentNode);\n    if (disabled || !autoFocus || arraysEquals(oldFocusableNodes, focusableNodesRef.current)) {\n      return;\n    }\n    if (document) {\n      const activeElement = document.activeElement;\n      const currentElementIndex = Math.max(document.activeElement ? focusableNodesRef.current.indexOf(activeElement) : -1, 0);\n      focusNodeByIndex(currentElementIndex);\n    }\n  };\n  useMutationObserver(ref, () => ref.current && onMutateParentHandler(ref.current));\n  useIsomorphicLayoutEffect(() => {\n    ref.current && recalculateFocusableNodesRef(ref.current);\n  }, [ref]);\n  useIsomorphicLayoutEffect(function tryToAutoFocusToFirstNode() {\n    if (!ref.current || !autoFocus || disabled) {\n      return;\n    }\n    const autoFocusToNode = () => {\n      if (!ref.current || !focusableNodesRef.current.length) {\n        return;\n      }\n      const activeElement = getActiveElementByAnotherElement(ref.current);\n      if (!contains(ref.current, activeElement)) {\n        if (autoFocus === 'root') {\n          var _ref_current;\n          (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();\n        } else {\n          focusableNodesRef.current[0].focus();\n        }\n      }\n    };\n    const timeoutId = setTimeout(autoFocusToNode, timeout);\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [autoFocus, timeout, disabled]);\n  useIsomorphicLayoutEffect(function initializeFocusTrap() {\n    if (!ref.current) {\n      return;\n    }\n    const onDocumentKeydown = event => {\n      if (disabled) {\n        return;\n      }\n      const pressedKeyResult = pressedKey(event);\n      switch (pressedKeyResult) {\n        case Keys.TAB:\n          {\n            if (!focusableNodesRef.current.length) {\n              return false;\n            }\n            const lastIdx = focusableNodesRef.current.length - 1;\n            const targetIdx = focusableNodesRef.current.findIndex(node => node === event.target);\n            const shouldFocusFirstNode = targetIdx === -1 || targetIdx === lastIdx && !event.shiftKey;\n            if (shouldFocusFirstNode || targetIdx === 0 && event.shiftKey) {\n              event.preventDefault();\n              const node = focusableNodesRef.current[shouldFocusFirstNode ? 0 : lastIdx];\n              if (node !== getActiveElementByAnotherElement(node)) {\n                node.focus();\n              }\n              return false;\n            }\n            break;\n          }\n        case Keys.ESCAPE:\n          {\n            if (onClose) {\n              event.preventDefault();\n              onClose();\n            }\n          }\n      }\n      return true;\n    };\n    const doc = getWindow(ref.current).document;\n    doc.addEventListener('keydown', onDocumentKeydown, {\n      capture: true\n    });\n    return () => {\n      doc.removeEventListener('keydown', onDocumentKeydown, true);\n    };\n  }, [onClose, ref, disabled]);\n};","map":{"version":3,"names":["useRef","useState","arraysEquals","FOCUSABLE_ELEMENTS_LIST","Keys","pressedKey","contains","getActiveElementByAnotherElement","getWindow","isHTMLElement","useDOM","useIsomorphicLayoutEffect","useMutationObserver","useStableCallback","useRestoreFocus","_ref","restoreFocus","timeout","mount","ref","restoreFocusRef","current","restoreFocusTo","setRestoreFocusTo","restoreFocusImpl","shouldRestoreFocus","setTimeout","restoreFocusElement","focus","calculateRestoreFocusTo","tryToRestoreFocusOnUnmount","tryToRestoreFocusWhenFakeUnmount","FOCUSABLE_ELEMENTS","join","useFocusTrap","_ref2","disabled","autoFocus","onClose","document","focusableNodesRef","focusNodeByIndex","nodeIndex","element","preventScroll","recalculateFocusableNodesRef","parentNode","newFocusableElements","querySelectorAll","nodes","forEach","focusableEl","display","visibility","getComputedStyle","push","length","onMutateParentHandler","oldFocusableNodes","activeElement","currentElementIndex","Math","max","indexOf","tryToAutoFocusToFirstNode","autoFocusToNode","_ref_current","timeoutId","clearTimeout","initializeFocusTrap","onDocumentKeydown","event","pressedKeyResult","TAB","lastIdx","targetIdx","findIndex","node","target","shouldFocusFirstNode","shiftKey","preventDefault","ESCAPE","doc","addEventListener","capture","removeEventListener"],"sources":["/Users/viktoriaromazanova/PycharmProjects/vk_chatgpt/frontend/node_modules/@vkontakte/vkui/src/hooks/useFocusTrap.ts"],"sourcesContent":["import { type RefObject, useRef, useState } from 'react';\nimport { arraysEquals } from '../helpers/array';\nimport { FOCUSABLE_ELEMENTS_LIST, Keys, pressedKey } from '../lib/accessibility';\nimport {\n  contains,\n  getActiveElementByAnotherElement,\n  getWindow,\n  isHTMLElement,\n  useDOM,\n} from '../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../lib/useIsomorphicLayoutEffect';\nimport { useMutationObserver } from './useMutationObserver';\nimport { useStableCallback } from './useStableCallback';\n\nconst useRestoreFocus = ({\n  restoreFocus,\n  timeout,\n  mount,\n  ref,\n}: Pick<UseFocusTrapProps, 'restoreFocus' | 'timeout' | 'mount'> & {\n  ref: RefObject<HTMLElement | null>;\n}) => {\n  const restoreFocusRef = useRef(restoreFocus);\n  restoreFocusRef.current = restoreFocus;\n  const [restoreFocusTo, setRestoreFocusTo] = useState<Element | null>(null);\n\n  const restoreFocusImpl = useStableCallback(() => {\n    const shouldRestoreFocus =\n      typeof restoreFocusRef.current === 'function'\n        ? restoreFocusRef.current()\n        : restoreFocusRef.current;\n\n    if (!shouldRestoreFocus) {\n      return;\n    }\n\n    setTimeout(() => {\n      const restoreFocusElement =\n        (isHTMLElement(shouldRestoreFocus) && shouldRestoreFocus) ||\n        (isHTMLElement(restoreFocusTo) && restoreFocusTo) ||\n        null;\n\n      if (restoreFocusElement) {\n        restoreFocusElement.focus();\n        setRestoreFocusTo(null);\n      }\n    }, timeout);\n  });\n\n  useIsomorphicLayoutEffect(\n    function calculateRestoreFocusTo() {\n      if (!ref.current || !restoreFocusRef.current || !mount) {\n        setRestoreFocusTo(null);\n        return;\n      }\n      setRestoreFocusTo(getActiveElementByAnotherElement(ref.current));\n    },\n    [ref, mount],\n  );\n\n  useIsomorphicLayoutEffect(\n    function tryToRestoreFocusOnUnmount() {\n      return () => {\n        restoreFocusImpl();\n      };\n    },\n    [restoreFocusImpl],\n  );\n\n  useIsomorphicLayoutEffect(\n    function tryToRestoreFocusWhenFakeUnmount() {\n      if (!mount) {\n        restoreFocusImpl();\n      }\n    },\n    [mount, restoreFocusImpl],\n  );\n};\n\nconst FOCUSABLE_ELEMENTS: string = FOCUSABLE_ELEMENTS_LIST.join();\n\nexport type UseFocusTrapProps = {\n  /**\n   * @default true\n   */\n  mount?: boolean;\n  /**\n   * Форсированное отключение захвата фокуса\n   *\n   * @default false\n   */\n  disabled?: boolean;\n  /**\n   * @default true\n   */\n  autoFocus?: boolean | 'root';\n  /**\n   * @default true\n   */\n  restoreFocus?: boolean | (() => boolean | HTMLElement);\n  /**\n   * @default 0\n   */\n  timeout?: number;\n  /**\n   * Вызывается при нажатии на кнопку `Escape`.\n   */\n  onClose?: VoidFunction;\n};\n\n/**\n * @private\n */\nexport const useFocusTrap = (\n  ref: RefObject<HTMLElement | null>,\n  {\n    mount = true,\n    disabled = false,\n    autoFocus = true,\n    restoreFocus = true,\n    timeout = 0,\n    onClose,\n  }: UseFocusTrapProps,\n) => {\n  const { document } = useDOM();\n\n  const focusableNodesRef = useRef<HTMLElement[]>([]);\n\n  const focusNodeByIndex = (nodeIndex: number) => {\n    const element = focusableNodesRef.current[nodeIndex];\n\n    if (element) {\n      element.focus({\n        preventScroll: true,\n      });\n    }\n  };\n\n  useRestoreFocus({\n    restoreFocus,\n    mount,\n    timeout,\n    ref,\n  });\n\n  const recalculateFocusableNodesRef = (parentNode: HTMLElement) => {\n    // eslint-disable-next-line no-restricted-properties\n    const newFocusableElements = parentNode.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENTS);\n\n    const nodes: HTMLElement[] = [];\n    newFocusableElements.forEach((focusableEl) => {\n      const { display, visibility } = getComputedStyle(focusableEl);\n      if (display !== 'none' && visibility !== 'hidden') {\n        nodes.push(focusableEl);\n      }\n    });\n    if (nodes.length === 0) {\n      // Чтобы фокус был хотя бы на родителе\n      nodes.push(parentNode);\n    }\n    focusableNodesRef.current = nodes;\n  };\n\n  const onMutateParentHandler = (parentNode: HTMLElement) => {\n    const oldFocusableNodes = [...focusableNodesRef.current];\n\n    recalculateFocusableNodesRef(parentNode);\n\n    if (disabled || !autoFocus || arraysEquals(oldFocusableNodes, focusableNodesRef.current)) {\n      return;\n    }\n\n    if (document) {\n      const activeElement = document.activeElement as HTMLElement;\n      const currentElementIndex = Math.max(\n        document.activeElement ? focusableNodesRef.current.indexOf(activeElement) : -1,\n        0,\n      );\n      focusNodeByIndex(currentElementIndex);\n    }\n  };\n\n  useMutationObserver(ref, () => ref.current && onMutateParentHandler(ref.current));\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current && recalculateFocusableNodesRef(ref.current);\n  }, [ref]);\n\n  useIsomorphicLayoutEffect(\n    function tryToAutoFocusToFirstNode() {\n      if (!ref.current || !autoFocus || disabled) {\n        return;\n      }\n\n      const autoFocusToNode = () => {\n        if (!ref.current || !focusableNodesRef.current.length) {\n          return;\n        }\n        const activeElement = getActiveElementByAnotherElement(ref.current);\n        if (!contains(ref.current, activeElement)) {\n          if (autoFocus === 'root') {\n            ref.current?.focus();\n          } else {\n            focusableNodesRef.current[0].focus();\n          }\n        }\n      };\n      const timeoutId = setTimeout(autoFocusToNode, timeout);\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    },\n    [autoFocus, timeout, disabled],\n  );\n\n  useIsomorphicLayoutEffect(\n    function initializeFocusTrap() {\n      if (!ref.current) {\n        return;\n      }\n\n      const onDocumentKeydown = (event: KeyboardEvent) => {\n        if (disabled) {\n          return;\n        }\n\n        const pressedKeyResult = pressedKey(event);\n\n        switch (pressedKeyResult) {\n          case Keys.TAB: {\n            if (!focusableNodesRef.current.length) {\n              return false;\n            }\n\n            const lastIdx = focusableNodesRef.current.length - 1;\n            const targetIdx = focusableNodesRef.current.findIndex((node) => node === event.target);\n\n            const shouldFocusFirstNode =\n              targetIdx === -1 || (targetIdx === lastIdx && !event.shiftKey);\n\n            if (shouldFocusFirstNode || (targetIdx === 0 && event.shiftKey)) {\n              event.preventDefault();\n\n              const node = focusableNodesRef.current[shouldFocusFirstNode ? 0 : lastIdx];\n\n              if (node !== getActiveElementByAnotherElement(node)) {\n                node.focus();\n              }\n\n              return false;\n            }\n\n            break;\n          }\n          case Keys.ESCAPE: {\n            if (onClose) {\n              event.preventDefault();\n              onClose();\n            }\n          }\n        }\n\n        return true;\n      };\n\n      const doc = getWindow(ref.current).document;\n      doc.addEventListener('keydown', onDocumentKeydown, {\n        capture: true,\n      });\n      return () => {\n        doc.removeEventListener('keydown', onDocumentKeydown, true);\n      };\n    },\n    [onClose, ref, disabled],\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}